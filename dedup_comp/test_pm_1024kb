c ISO/IEC N3242=11-0012
int g(int a) { return a; }
int j();
void q();
}
namespace { int l=1; }
// the potential scope of l is from its point of declaration
// to the end of the translation unit
namespace N {
int g(char a) { // overloads N::g(int)
return l+a; // l is from unnamed namespace
}
int i; // error: duplicate definition
int j(); // OK: duplicate function declaration
int j() { // OK: definition of N::j()
return g(i); // calls N::g(int)
}
int q(); // error: different return type
}
— end example ]
2 A namespace member can also be referred to after the :: scope resolution operator (5.1) applied to the name
of its namespace or the name of a namespace which nominates the member’s namespace in a using-directive;
see 3.4.3.2.
3 The outermost declarative region of a translation unit is also a namespace, called the global namespace. A
name declared in the global namespace has global namespace scope (also called global scope). The potential
scope of such a name begins at its point of declaration (3.3.2) and ends at the end of the translation unit
that is its declarative region. Names with global namespace scope are said to be global name.
3.3.7 Class scope [basic.scope.class]
1 The following rules describe the scope of names declared in classes.
1) The potential scope of a name declared in a class consists not only of the declarative region following
the name’s point of declaration, but also of all function bodies, brace-or-equal-initializers of non-static
data members, and default arguments in that class (including such things in nested classes).
2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in
the completed scope of S. No diagnostic is required for a violation of this rule.
3) If reordering member declarations in a class yields an alternate valid program under (1) and (2), the
program is ill-formed, no diagnostic is required.
4) A name declared within a member function hides a declaration of the same name whose scope extends
to or past the end of the member function’s class.
5) The potential scope of a declaration that extends to or past the end of a class definition also extends to the regions defined by its member definitions, even if the members are defined lexically
outside the class (this includes static data member definitions, nested class definitions, member function definitions (including the member function body and any portion of the declarator part of such
definitions which follows the declarator-id, including a parameter-declaration-clause and any default
arguments (8.3.6).[ Example:
§ 3.3.7 42

 c ISO/IEC N3242=11-0012
typedef int c;
enum { i = 1 };
class X {
char v[i]; // error: i refers to ::i
// but when reevaluated is X::i
int f() { return sizeof(c); } // OK: X::c
char c;
enum { i = 2 };
};
typedef char* T;
struct Y {
T a; // error: T refers to ::T
// but when reevaluated is Y::T
typedef long T;
T b;
};
typedef int I;
class D {
typedef I I; // error, even though no reordering involved
};
— end example ]
2 The name of a class member shall only be used as follows:
— in the scope of its class (as described above) or a class derived (Clause 10) from its class,
— after the . operator applied to an expression of the type of its class (5.2.5) or a class derived from its
class,
— after the -> operator applied to a pointer to an object of its class (5.2.5) or a class derived from its
class,
— after the :: scope resolution operator (5.1) applied to the name of its class or a class derived from its
class.
3.3.8 Enumeration scope [basic.scope.enum]
1 The name of a scoped enumerator (7.2) has enumeration scope. Its potential scope begins at its point of
declaration and terminates at the end of the enum-specifier.
3.3.9 Template parameter scope [basic.scope.temp]
1 The declarative region of the name of a template parameter of a template template-parameter is the smallest
template-parameter-list in which the name was introduced.
2 The declarative region of the name of a template parameter of a template is the smallest template-declaration
in which the name was introduced. Only template parameter names belong to this declarative region; any
other kind of name introduced by the declaration of a template-declaration is instead introduced into the
same declarative region where it would be introduced as a result of a non-template declaration of the same
name. [ Example:
namespace N {
template<class T> struct A { }; // #1
§ 3.3.9 43

 c ISO/IEC N3242=11-0012
template<class U> void f(U) { } // #2
struct B {
template<class V> friend int g(struct C*); // #3
};
}
The declarative regions of T, U and V are the template-declarations on lines #1, #2 and #3, respectively.
But the names A, f, g and C all belong to the same declarative region — namely, the namespace-body of N.
(g is still considered to belong to this declarative region in spite of its being hidden during qualified and
unqualified name lookup.) — end example ]
3 The potential scope of a template parameter name begins at its point of declaration (3.3.2) and ends at the
end of its declarative region. [Note: This implies that a template-parameter can be used in the declaration
of subsequent template-parameters and their default arguments but cannot be used in preceding templateparameters or their default arguments. For example,
template<class T, T* p, class U = T> class X { /∗ ... ∗/ };
template<class T> void f(T* p = new T);
This also implies that a template-parameter can be used in the specification of base classes. For example,
template<class T> class X : public Array<T> { /∗ ... ∗/ };
template<class T> class Y : public T { /∗ ... ∗/ };
The use of a template parameter as a base class implies that a class used as a template argument must be
defined and not just declared when the class template is instantiated. — end note ]
4 The declarative region of the name of a template parameter is nested within the immediately-enclosing
declarative region. [ Note: As a result, a template-parameter hides any entity with the same name in an
enclosing scope (3.3.10). [ Example:
typedef int N;
template<N X, typename N, template<N Y> class T> struct A;
Here, X is a non-type template parameter of type int and Y is a non-type template parameter of the same
type as the second template parameter of A. — end example ] — end note ]
5 [ Note: Because the name of a template parameter cannot be redeclared within its potential scope (14.6.1), a
template parameter’s scope is often its potential scope. However, it is still possible for a template parameter
name to be hidden; see 14.6.1. — end note ]
3.3.10 Name hiding [basic.scope.hiding]
1 A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived
class (10.2).
2 A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member,
function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data
member, function, or enumerator are declared in the same scope (in any order) with the same name, the
class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is
visible.
3 In a member function definition, the declaration of a name at block scope hides the declaration of a member
of the class with the same name; see 3.3.7. The declaration of a member in a derived class (Clause 10) hides
the declaration of a member of a base class of the same name; see 10.2.
§ 3.3.10 44

 c ISO/IEC N3242=11-0012
4 During the lookup of a name qualified by a namespace name, declarations that would otherwise be made
visible by a using-directive can be hidden by declarations with the same name in the namespace containing
the using-directive; see (3.4.3.2).
5 If a name is in scope and is not hidden it is said to be visible.
3.4 Name lookup [basic.lookup]
1 The name lookup rules apply uniformly to all names (including typedef-names (7.1.3), namespace-names (7.3),
and class-names (9.1)) wherever the grammar allows such names in the context discussed by a particular
rule. Name lookup associates the use of a name with a declaration (3.1) of that name. Name lookup shall
find an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one declaration with a name if it finds the name to be a function name; the declarations are said to form a set
of overloaded functions (13.1). Overload resolution (13.3) takes place after name lookup has succeeded.
The access rules (Clause 11) are considered only once name lookup and function overload resolution (if
applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access
checking have succeeded are the attributes introduced by the name’s declaration used further in expression
processing (Clause 5).
2 A name “looked up in the context of an expression” is looked up as an unqualified name in the scope where
the expression is found.
3 The injected-class-name of a class (Clause 9) is also considered to be a member of that class for the purposes
of name hiding and lookup.
4 [ Note: 3.5 discusses linkage issues. The notions of scope, point of declaration and name hiding are discussed
in 3.3. — end note ]
3.4.1 Unqualified name lookup [basic.lookup.unqual]
1 In all the cases listed in 3.4.1, the scopes are searched for a declaration in the order listed in each of the
respective categories; name lookup ends as soon as a declaration is found for the name. If no declaration is
found, the program is ill-formed.
2 The declarations from the namespace nominated by a using-directive become visible in a namespace enclosing
the using-directive; see 7.3.4. For the purpose of the unqualified name lookup rules described in 3.4.1, the
declarations from the namespace nominated by the using-directive are considered members of that enclosing
namespace.
3 The lookup for an unqualified name used as the postfix-expression of a function call is described in 3.4.2.
[ Note: For purposes of determining (during parsing) whether an expression is a postfix-expression for a function call, the usual name lookup rules apply. The rules in 3.4.2 have no effect on the syntactic interpretation
of an expression. For example,
typedef int f;
namespace N {
struct A {
friend void f(A &);
operator int();
void g(A a) {
int i = f(a); // f is the typedef, not the friend
// function: equivalent to int(a)
}
};
}
§ 3.4.1 45

 c ISO/IEC N3242=11-0012
Because the expression is not a function call, the argument-dependent name lookup (3.4.2) does not apply
and the friend function f is not found. — end note ]
4 A name used in global scope, outside of any function, class or user-declared namespace, shall be declared
before its use in global scope.
5 A name used in a user-declared namespace outside of the definition of any function or class shall be declared
before its use in that namespace or before its use in a namespace enclosing its namespace.
6 A name used in the definition of a function following the function’s declarator-id28 that is a member of
namespace N (where, only for the purpose of exposition, N could represent the global scope) shall be declared
before its use in the block in which it is used or in one of its enclosing blocks (6.3) or, shall be declared
before its use in namespace N or, if N is a nested namespace, shall be declared before its use in one of N’s
enclosing namespaces. [ Example:
namespace A {
namespace N {
void f();
}
}
void A::N::f() {
i = 5;
// The following scopes are searched for a declaration of i:
// 1) outermost block scope of A::N::f, before the use of i
// 2) scope of namespace N
// 3) scope of namespace A
// 4) global scope, before the definition of A::N::f
} —
end example ]
7 A name used in the definition of a class X outside of a member function body or nested class definition29
shall be declared in one of the following ways:
— before its use in class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), before the definition of X in Y, or shall be a member of a base
class of Y (this lookup applies in turn to Y ’s enclosing classes, starting with the innermost enclosing
class),30 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the definition of class
X in namespace N or in one of N ’s enclosing namespaces.
[ Example:
namespace M {
class B { };
}
28) This refers to unqualified names that occur, for instance, in a type or default argument in the parameter-declaration-clause
or used in the function body.
29) This refers to unqualified names following the class name; such a name may be used in the base-clause or may be used in
the class definition.
30) This lookup applies whether the definition of X is nested within Y’s definition or whether X’s definition appears in a
namespace scope enclosing Y ’s definition (9.7).
§ 3.4.1 46

 c ISO/IEC N3242=11-0012
namespace N {
class Y : public M::B {
class X {
int a[i];
};
};
}
// The following scopes are searched for a declaration of i:
// 1) scope of class N::Y::X, before the use of i
// 2) scope of class N::Y, before the definition of N::Y::X
// 3) scope of N::Y’s base class M::B
// 4) scope of namespace N, before the definition of N::Y
// 5) global scope, before the definition of N
— end example ] [ Note: When looking for a prior declaration of a class or function introduced by a friend
declaration, scopes outside of the innermost enclosing namespace scope are not considered; see 7.3.1.2. —
end note ] [ Note: 3.3.7 further describes the restrictions on the use of names in a class definition. 9.7 further
describes the restrictions on the use of names in nested class definitions. 9.8 further describes the restrictions
on the use of names in local class definitions. — end note ]
8 A name used in the definition of a member function (9.3) of class X following the function’s declarator-id31
or in the brace-or-equal-initializer of a non-static data member (9.2) of class X shall be declared in one of
the following ways:
— before its use in the block in which it is used or in an enclosing block (6.3), or
— shall be a member of class X or be a member of a base class of X (10.2), or
— if X is a nested class of class Y (9.7), shall be a member of Y, or shall be a member of a base class of Y
(this lookup applies in turn to Y’s enclosing classes, starting with the innermost enclosing class),32 or
— if X is a local class (9.8) or is a nested class of a local class, before the definition of class X in a block
enclosing the definition of class X, or
— if X is a member of namespace N, or is a nested class of a class that is a member of N, or is a local class
or a nested class within a local class of a function that is a member of N, before the use of the name,
in namespace N or in one of N ’s enclosing namespaces.
[ Example:
class B { };
namespace M {
namespace N {
class X : public B {
void f();
};
}
}
void M::N::X::f() {
i = 16;
}
31) That is, an unqualified name that occurs, for instance, in a type or default argument in the parameter-declaration-clause
or in the function body.
32) This lookup applies whether the member function is defined within the definition of class X or whether the member function
is defined in a namespace scope enclosing X’s definition.
§ 3.4.1 47

 c ISO/IEC N3242=11-0012
// The following scopes are searched for a declaration of i:
// 1) outermost block scope of M::N::X::f, before the use of i
// 2) scope of class M::N::X
// 3) scope of M::N::X’s base class B
// 4) scope of namespace M::N
// 5) scope of namespace M
// 6) global scope, before the definition of M::N::X::f
— end example ] [ Note: 9.3 and 9.4 further describe the restrictions on the use of names in member function
definitions. 9.7 further describes the restrictions on the use of names in the scope of nested classes. 9.8
further describes the restrictions on the use of names in local class definitions. — end note ]
9 Name lookup for a name used in the definition of a friend function (11.3) defined inline in the class granting
friendship shall proceed as described for lookup in member function definitions. If the friend function is
not defined in the class granting friendship, name lookup in the friend function definition shall proceed as
described for lookup in namespace member function definitions.
10 In a friend declaration naming a member function, a name used in the function declarator and not part of a
template-argument in the declarator-id is first looked up in the scope of the member function’s class (10.2). If
it is not found, or if the name is part of a template-argument in the declarator-id, the look up is as described
for unqualified names in the definition of the class granting friendship. [ Example:
struct A {
typedef int AT;
void f1(AT);
void f2(float);
template <class T> void f3();
};
struct B {
typedef char AT;
typedef float BT;
friend void A::f1(AT); // parameter type is A::AT
friend void A::f2(BT); // parameter type is B::BT
friend void A::f3<AT>(); // template argument is B::AT
};
— end example ]
11 During the lookup for a name used as a default argument (8.3.6) in a function parameter-declaration-clause
or used in the expression of a mem-initializer for a constructor (12.6.2), the function parameter names are
visible and hide the names of entities declared in the block, class or namespace scopes containing the function
declaration. [ Note: 8.3.6 further describes the restrictions on the use of names in default arguments. 12.6.2
further describes the restrictions on the use of names in a ctor-initializer. — end note ]
12 During the lookup of a name used in the constant-expression of an enumerator-definition, previously declared
enumerators of the enumeration are visible and hide the names of entities declared in the block, class, or
namespace scopes containing the enum-specifier.
13 A name used in the definition of a static data member of class X (9.4.2) (after the qualified-id of the static
member) is looked up as if the name was used in a member function of X. [ Note: 9.4.2 further describes the
restrictions on the use of names in the definition of a static data member. — end note ]
14 If a variable member of a namespace is defined outside of the scope of its namespace then any name that
appears in the definition of the member (after the declarator-id) is looked up as if the definition of the
member occurred in its namespace. [ Example:
§ 3.4.1 48

 c ISO/IEC N3242=11-0012
namespace N {
int i = 4;
extern int j;
}
int i = 2;
int N::j = i; // N::j == 4
— end example ]
15 A name used in the handler for a function-try-block (Clause 15) is looked up as if the name was used in
the outermost block of the function definition. In particular, the function parameter names shall not be
redeclared in the exception-declaration nor in the outermost block of a handler for the function-try-block.
Names declared in the outermost block of the function definition are not found when looked up in the scope
of a handler for the function-try-block. [ Note: But function parameter names are found. — end note ]
16 [ Note: The rules for name lookup in template definitions are described in 14.6. — end note ]
3.4.2 Argument-dependent name lookup [basic.lookup.argdep]
1 When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered
during the usual unqualified lookup (3.4.1) may be searched, and in those namespaces, namespace-scope
friend function declarations (11.3) not otherwise visible may be found. These modifications to the search
depend on the types of the arguments (and for template template arguments, the namespace of the template
argument). [ Example:
namespace N {
struct S { };
void f(S);
}
void g() {
N::S s;
f(s); // OK: calls N::f
(f)(s); // error: N::f not considered; parentheses
// prevent argument-dependent lookup
}
— end example ]
2 For each argument type T in the function call, there is a set of zero or more associated namespaces and a
set of zero or more associated classes to be considered. The sets of namespaces and classes is determined
entirely by the types of the function arguments (and the namespace of any template template argument).
Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of
namespaces and classes are determined in the following way:
— If T is a fundamental type, its associated sets of namespaces and classes are both empty.
— If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a
member, if any; and its direct and indirect base classes. Its associated namespaces are the namespaces
of which its associated classes are members. Furthermore, if T is a class template specialization,
its associated namespaces and classes also include: the namespaces and classes associated with the
types of the template arguments provided for template type parameters (excluding template template
parameters); the namespaces of which any template template arguments are members; and the classes
§ 3.4.2 49

 c ISO/IEC N3242=11-0012
of which any member templates used as template template arguments are members. [ Note: Non-type
template arguments do not contribute to the set of associated namespaces. — end note ]
— If T is an enumeration type, its associated namespace is the namespace in which it is defined. If it is
class member, its associated class is the member’s class; else it has no associated class.
— If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with
U.
— If T is a function type, its associated namespaces and classes are those associated with the function
parameter types and those associated with the return type.
— If T is a pointer to a member function of a class X, its associated namespaces and classes are those
associated with the function parameter types and return type, together with those associated with X.
— If T is a pointer to a data member of class X, its associated namespaces and classes are those associated
with the member type together with those associated with X.
If an associated namespace is an inline namespace (7.3.1), its enclosing namespace is also included in the set.
If an associated namespace directly contains inline namespaces, those inline namespaces are also included in
the set. In addition, if the argument is the name or address of a set of overloaded functions and/or function
templates, its associated classes and namespaces are the union of those associated with each of the members
of the set, i.e., the classes and namespaces associated with its (non-dependent) parameter types and return
type.
3 Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by
argument dependent lookup (defined as follows). If X contains
— a declaration of a class member, or
— a block-scope function declaration that is not a using-declaration, or
— a declaration that is neither a function or a function template
then Y is empty. Otherwise Y is the set of declarations found in the namespaces associated with the
argument types as described below. The set of declarations found by the lookup of the name is the union of
X and Y . [ Note: The namespaces and classes associated with the argument types can include namespaces
and classes already considered by the ordinary unqualified lookup. — end note ] [ Example:
namespace NS {
class T { };
void f(T);
void g(T, int);
}
NS::T parm;
void g(NS::T, float);
int main() {
f(parm); // OK: calls NS::f
extern void g(NS::T, float);
g(parm, 1); // OK: calls g(NS::T, float)
}
— end example ]
4 When considering an associated namespace, the lookup is the same as the lookup performed when the
associated namespace is used as a qualifier (3.4.3.2) except that:
— Any using-directives in the associated namespace are ignored.
§ 3.4.2 50

 c ISO/IEC N3242=11-0012
— Any namespace-scope friend functions or friend function templates declared in associated classes are
visible within their respective namespaces even if they are not visible during an ordinary lookup (11.3).
— All names except those of (possibly overloaded) functions and function templates are ignored.
3.4.3 Qualified name lookup [basic.lookup.qual]
1 The name of a class or namespace member or enumerator can be referred to after the :: scope resolution
operator (5.1) applied to a nested-name-specifier that denotes its class, namespace, or enumeration. If a ::
scope resolution operator in a nested-name-specifier is not preceded by a decltype-specifier, lookup of the
name preceding that :: considers only namespaces, types, and templates whose specializations are types.
If the name found does not designate a namespace or a class, enumeration, or dependent type, the program
is ill-formed.[ Example:
class A {
public:
static int n;
};
int main() {
int A;
A::n = 42; // OK
A b; // ill-formed: A does not name a type
}
— end example ]
2 [ Note: Multiply qualified names, such as N1::N2::N3::n, can be used to refer to members of nested
classes (9.7) or members of nested namespaces. — end note ]
3 In a declaration in which the declarator-id is a qualified-id, names used before the qualified-id being declared
are looked up in the defining namespace scope; names following the qualified-id are looked up in the scope
of the member’s class or namespace. [ Example:
class X { };
class C {
class X { };
static const int number = 50;
static X arr[number];
};
X C::arr[number]; // ill-formed:
// equivalent to: ::X C::arr[C::number];
// not to: C::X C::arr[C::number];
— end example ]
4 A name prefixed by the unary scope operator :: (5.1) is looked up in global scope, in the translation unit
where it is used. The name shall be declared in global namespace scope or shall be a name whose declaration
is visible in global scope because of a using-directive (3.4.3.2). The use of :: allows a global name to be
referred to even if its identifier has been hidden (3.3.10).
5 A name prefixed by a nested-name-specifier that nominates an enumeration type shall represent an enumerator of that enumeration.
6 If a pseudo-destructor-name (5.2.4) contains a nested-name-specifier, the type-names are looked up as types
in the scope designated by the nested-name-specifier. Similarly, in a qualified-id of the form:
::opt nested-name-specifieropt class-name :: ~ class-name
§ 3.4.3 51

 c ISO/IEC N3242=11-0012
the second class-name is looked up in the same scope as the first. [ Example:
struct C {
typedef int I;
};
typedef int I1, I2;
extern int* p;
extern int* q;
p->C::I::~I(); // I is looked up in the scope of C
q->I1::~I2(); // I2 is looked up in the scope of
// the postfix-expression
struct A {
~A();
};
typedef A AB;
int main() {
AB *p;
p->AB::~AB(); // explicitly calls the destructor for A
}
— end example ] [ Note: 3.4.5 describes how name lookup proceeds after the . and -> operators. — end
note ]
3.4.3.1 Class members [class.qual]
1 If the nested-name-specifier of a qualified-id nominates a class, the name specified after the nested-namespecifier is looked up in the scope of the class (10.2), except for the cases listed below. The name shall
represent one or more members of that class or of one of its base classes (Clause 10). [ Note: A class member
can be referred to using a qualified-id at any point in its potential scope (3.3.7). — end note ] The exceptions
to the name lookup rule above are the following:
— a destructor name is looked up as specified in 3.4.3;
— a conversion-type-id of an conversion-function-id is looked up both in the scope of the class and in the
context in which the entire postfix-expression occurs and shall refer to the same type in both contexts;
— the names in a template-argument of a template-id are looked up in the context in which the entire
postfix-expression occurs.
— the lookup for a name specified in a using-declaration (7.3.3) also finds class or enumeration names
hidden within the same scope (3.3.10).
2 In a lookup in which the constructor is an acceptable lookup result and the nested-name-specifier nominates
a class C:
— if the name specified after the nested-name-specifier, when looked up in C, is the injected-class-name
of C (Clause 9), or
— in a using-declaration (7.3.3) that is a member-declaration, if the name specified after the nested-namespecifier is the same as the identifier or the simple-template-id’s template-name in the last component
of the nested-name-specifier,
the name is instead considered to name the constructor of class C. [ Note: For example, the constructor is
not an acceptable lookup result in an elaborated-type-specifier so the constructor would not be used in place
of the injected-class-name. — end note ] Such a constructor name shall be used only in the declarator-id of
a declaration that names a constructor or in a using-declaration. [ Example:
§ 3.4.3.1 52

 c ISO/IEC N3242=11-0012
struct A { A(); };
struct B: public A { B(); };
A::A() { }
B::B() { }
B::A ba; // object of type A
A::A a; // error, A::A is not a type name
struct A::A a2; // object of type A
— end example ]
3 A class member name hidden by a name in a nested declarative region or by the name of a derived class
member can still be found if qualified by the name of its class followed by the :: operator.
3.4.3.2 Namespace members [namespace.qual]
1 If the nested-name-specifier of a qualified-id nominates a namespace, the name specified after the nestedname-specifier is looked up in the scope of the namespace, except that the names in a template-argument of
a template-id are looked up in the context in which the entire postfix-expression occurs.
2 For a namespace X and name m, the namespace-qualified lookup set S(X, m) is defined as follows: Let
S0(X, m) be the set of all declarations of m in X and the inline namespace set of X (7.3.1). If S0(X, m) is not
empty, S(X, m) is S0(X, m); otherwise, S(X, m) is the union of S(Ni, m) for all namespaces Ni nominated
by using-directives in X and its inline namespace set.
3 Given X::m (where X is a user-declared namespace), or given ::m (where X is the global namespace), if
S(X, m) is the empty set, the program is ill-formed. Otherwise, if S(X, m) has exactly one member, or if
the context of the reference is a using-declaration (7.3.3), S(X, m) is the required set of declarations of m.
Otherwise if the use of m is not one that allows a unique declaration to be chosen from S(X, m), the program
is ill-formed. [ Example:
int x;
namespace Y {
void f(float);
void h(int);
}
namespace Z {
void h(double);
}
namespace A {
using namespace Y;
void f(int);
void g(int);
int i;
}
namespace B {
using namespace Z;
void f(char);
int i;
}
§ 3.4.3.2 53

 c ISO/IEC N3242=11-0012
namespace AB {
using namespace A;
using namespace B;
void g();
}
void h()
{
AB::g(); // g is declared directly in AB,
// therefore S is { AB::g() } and AB::g() is chosen
AB::f(1); // f is not declared directly in AB so the rules are
// applied recursively to A and B;
// namespace Y is not searched and Y::f(float)
// is not considered;
// S is { A::f(int), B::f(char) } and overload
// resolution chooses A::f(int)
AB::f(’c’); // as above but resolution chooses B::f(char)
AB::x++; // x is not declared directly in AB, and
// is not declared in A or B , so the rules are
// applied recursively to Y and Z,
// S is { } so the program is ill-formed
AB::i++; // i is not declared directly in AB so the rules are
// applied recursively to A and B,
// S is { A::i , B::i } so the use is ambiguous
// and the program is ill-formed
AB::h(16.8); // h is not declared directly in AB and
// not declared directly in A or B so the rules are
// applied recursively to Y and Z,
// S is { Y::h(int), Z::h(double) } and overload
// resolution chooses Z::h(double)
}
4 The same declaration found more than once is not an ambiguity (because it is still a unique declaration).
For example:
namespace A {
int a;
}
namespace B {
using namespace A;
}
namespace C {
using namespace A;
}
namespace BC {
using namespace B;
using namespace C;
}
void f()
{
BC::a++; // OK: S is { A::a, A::a }
§ 3.4.3.2 54

 c ISO/IEC N3242=11-0012
}
namespace D {
using A::a;
}
namespace BD {
using namespace B;
using namespace D;
}
void g()
{
BD::a++; // OK: S is { A::a, A::a }
}
5 Because each referenced namespace is searched at most once, the following is well-defined:
namespace B {
int b;
}
namespace A {
using namespace B;
int a;
}
namespace B {
using namespace A;
}
void f()
{
A::a++; // OK: a declared directly in A, S is { A::a}
B::a++; // OK: both A and B searched (once), S is { A::a}
A::b++; // OK: both A and B searched (once), S is { B::b}
B::b++; // OK: b declared directly in B, S is { B::b}
} —
end example ]
6 During the lookup of a qualified namespace member name, if the lookup finds more than one declaration of
the member, and if one declaration introduces a class name or enumeration name and the other declarations
either introduce the same variable, the same enumerator or a set of functions, the non-type name hides
the class or enumeration name if and only if the declarations are from the same namespace; otherwise (the
declarations are from different namespaces), the program is ill-formed. [ Example:
namespace A {
struct x { };
int x;
int y;
}
namespace B {
struct y { };
}
§ 3.4.3.2 55

 c ISO/IEC N3242=11-0012
namespace C {
using namespace A;
using namespace B;
int i = C::x; // OK, A::x (of type int )
int j = C::y; // ambiguous, A::y or B::y
}
— end example ]
7 In a declaration for a namespace member in which the declarator-id is a qualified-id, given that the qualified-id
for the namespace member has the form
nested-name-specifier unqualified-id
the unqualified-id shall name a member of the namespace designated by the nested-name-specifier or of an
element of the inline namespace set (7.3.1) of that namespace. [ Example:
namespace A {
namespace B {
void f1(int);
}
using namespace B;
}
void A::f1(int){ } // ill-formed, f1 is not a member of A
— end example ] However, in such namespace member declarations, the nested-name-specifier may rely on
using-directives to implicitly provide the initial part of the nested-name-specifier. [ Example:
namespace A {
namespace B {
void f1(int);
}
}
namespace C {
namespace D {
void f1(int);
}
}
using namespace A;
using namespace C::D;
void B::f1(int){ } // OK, defines A::B::f1(int)
— end example ]
3.4.4 Elaborated type specifiers [basic.lookup.elab]
1 An elaborated-type-specifier (7.1.6.3) may be used to refer to a previously declared class-name or enum-name
even though the name has been hidden by a non-type declaration (3.3.10).
2 If the elaborated-type-specifier has no nested-name-specifier, and unless the elaborated-type-specifier appears
in a declaration with the following form:
class-key attribute-specifier-seqopt identifier ;
§ 3.4.4 56

 c ISO/IEC N3242=11-0012
the identifier is looked up according to 3.4.1 but ignoring any non-type names that have been declared. If
the elaborated-type-specifier is introduced by the enum keyword and this lookup does not find a previously
declared type-name, the elaborated-type-specifier is ill-formed. If the elaborated-type-specifier is introduced by
the class-key and this lookup does not find a previously declared type-name, or if the elaborated-type-specifier
appears in a declaration with the form:
class-key attribute-specifier-seqopt identifier ;
the elaborated-type-specifier is a declaration that introduces the class-name as described in 3.3.2.
3 If the elaborated-type-specifier has a nested-name-specifier, qualified name lookup is performed, as described
in 3.4.3, but ignoring any non-type names that have been declared. If the name lookup does not find a
previously declared type-name, the elaborated-type-specifier is ill-formed. [ Example:
struct Node {
struct Node* Next; // OK: Refers to Node at global scope
struct Data* Data; // OK: Declares type Data
// at global scope and member Data
};
struct Data {
struct Node* Node; // OK: Refers to Node at global scope
friend struct ::Glob; // error: Glob is not declared
// cannot introduce a qualified type (7.1.6.3)
friend struct Glob; // OK: Refers to (as yet) undeclared Glob
// at global scope.
/∗
... ∗/
};
struct Base {
struct Data; // OK: Declares nested Data
struct ::Data* thatData; // OK: Refers to ::Data
struct Base::Data* thisData; // OK: Refers to nested Data
friend class ::Data; // OK: global Data is a friend
friend class Data; // OK: nested Data is a friend
struct Data { /* ... */ }; // Defines nested Data
};
struct Data; // OK: Redeclares Data at global scope
struct ::Data; // error: cannot introduce a qualified type (7.1.6.3)
struct Base::Data; // error: cannot introduce a qualified type (7.1.6.3)
struct Base::Datum; // error: Datum undefined
struct Base::Data* pBase; // OK: refers to nested Data
— end example ]
3.4.5 Class member access [basic.lookup.classref]
1 In a class member access expression (5.2.5), if the . or -> token is immediately followed by an identifier
followed by a <, the identifier must be looked up to determine whether the < is the beginning of a template
argument list (14.2) or a less-than operator. The identifier is first looked up in the class of the object
expression. If the identifier is not found, it is then looked up in the context of the entire postfix-expression
and shall name a class template. If the lookup in the class of the object expression finds a template, the
name is also looked up in the context of the entire postfix-expression and
— if the name is not found, the name found in the class of the object expression is used, otherwise
§ 3.4.5 57

 c ISO/IEC N3242=11-0012
— if the name is found in the context of the entire postfix-expression and does not name a class template,
the name found in the class of the object expression is used, otherwise
— if the name found is a class template, it shall refer to the same entity as the one found in the class of
the object expression, otherwise the program is ill-formed.
2 If the id-expression in a class member access (5.2.5) is an unqualified-id, and the type of the object expression
is of a class type C, the unqualified-id is looked up in the scope of class C. If the type of the object expression
is of pointer to scalar type, the unqualified-id is looked up in the context of the complete postfix-expression.
3 If the unqualified-id is ~type-name, the type-name is looked up in the context of the entire postfix-expression.
If the type T of the object expression is of a class type C, the type-name is also looked up in the scope of
class C. At least one of the lookups shall find a name that refers to (possibly cv-qualified) T. [ Example:
struct A { };
struct B {
struct A { };
void f(::A* a);
};
void B::f(::A* a) {
a->~A(); // OK: lookup in *a finds the injected-class-name
} —
end example ]
4 If the id-expression in a class member access is a qualified-id of the form
class-name-or-namespace-name::...
the class-name-or-namespace-name following the . or -> operator is looked up both in the context of the
entire postfix-expression and in the scope of the class of the object expression. If the name is found only in
the scope of the class of the object expression, the name shall refer to a class-name. If the name is found
only in the context of the entire postfix-expression, the name shall refer to a class-name or namespace-name.
If the name is found in both contexts, the class-name-or-namespace-name shall refer to the same entity.
5 If the qualified-id has the form
::class-name-or-namespace-name::...
the class-name-or-namespace-name is looked up in global scope as a class-name or namespace-name.
6 If the nested-name-specifier contains a simple-template-id (14.2), the names in its template-arguments are
looked up in the context in which the entire postfix-expression occurs.
7 If the id-expression is a conversion-function-id, its conversion-type-id shall denote the same type in both the
context in which the entire postfix-expression occurs and in the context of the class of the object expression
(or the class pointed to by the pointer expression).
3.4.6 Using-directives and namespace aliases [basic.lookup.udir]
1 In a using-directive or namespace-alias-definition, during the lookup for a namespace-name or for a name in
a nested-name-specifier only namespace names are considered.
3.5 Program and linkage [basic.link]
1 A program consists of one or more translation units (Clause 2) linked together. A translation unit consists
§ 3.5 58

 c ISO/IEC N3242=11-0012
of a sequence of declarations.
translation-unit:
declaration-seqopt
2 A name is said to have linkage when it might denote the same object, reference, function, type, template,
namespace or value as a name introduced by a declaration in another scope:
— When a name has external linkage , the entity it denotes can be referred to by names from scopes of
other translation units or from other scopes of the same translation unit.
— When a name has internal linkage , the entity it denotes can be referred to by names from other scopes
in the same translation unit.
— When a name has no linkage , the entity it denotes cannot be referred to by names from other scopes.
3 A name having namespace scope (3.3.6) has internal linkage if it is the name of
— a variable, function or function template that is explicitly declared static; or,
— a variable that is explicitly declared const or constexpr and neither explicitly declared extern nor
previously declared to have external linkage; or
— a data member of an anonymous union.
4 An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has
internal linkage. All other namespaces have external linkage. A name having namespace scope that has not
been given internal linkage above has the same linkage as the enclosing namespace if it is the name of
— a variable; or
— a function; or
— a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has
the typedef name for linkage purposes (7.1.3); or
— a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the
enumeration has the typedef name for linkage purposes (7.1.3); or
— an enumerator belonging to an enumeration with linkage; or
— a template.
5 In addition, a member function, static data member, a named class or enumeration of class scope, or an
unnamed class or enumeration defined in a class-scope typedef declaration such that the class or enumeration
has the typedef name for linkage purposes (7.1.3), has external linkage if the name of the class has external
linkage.
6 The name of a function declared in block scope and the name of a variable declared by a block scope extern
declaration have linkage. If there is a visible declaration of an entity with linkage having the same name and
type, ignoring entities declared outside the innermost enclosing namespace scope, the block scope declaration
declares that same entity and receives the linkage of the previous declaration. If there is more than one such
matching entity, the program is ill-formed. Otherwise, if no matching entity is found, the block scope entity
receives external linkage.[ Example:
static void f();
static int i = 0; // #1
void g() {
extern void f(); // internal linkage
int i; // #2 i has no linkage
{
§ 3.5 59

 c ISO/IEC N3242=11-0012
extern void f(); // internal linkage
extern int i; // #3 external linkage
}
}
There are three objects named i in this program. The object with internal linkage introduced by the
declaration in global scope (line #1 ), the object with automatic storage duration and no linkage introduced
by the declaration on line #2, and the object with static storage duration and external linkage introduced
by the declaration on line #3. — end example ]
7 When a block scope declaration of an entity with linkage is not found to refer to some other declaration,
then that entity is a member of the innermost enclosing namespace. However such a declaration does not
introduce the member name in its namespace scope. [ Example:
namespace X {
void p() {
q(); // error: q not yet declared
extern void q(); // q is a member of namespace X
}
void middle() {
q(); // error: q not yet declared
}
void q() { /* ... */ } // definition of X::q
}
void q() { /* ... */ } // some other, unrelated q
— end example ]
8 Names not covered by these rules have no linkage. Moreover, except as noted, a name declared at block
scope (3.3.3) has no linkage. A type is said to have linkage if and only if:
— it is a class or enumeration type that is named (or has a name for linkage purposes (7.1.3)) and the
name has linkage; or
— it is an unnamed class or enumeration member of a class with linkage; or
— it is a specialization of a class template (14)33; or
— it is a fundamental type (3.9.1); or
— it is a compound type (3.9.2) other than a class or enumeration, compounded exclusively from types
that have linkage; or
— it is a cv-qualified (3.9.3) version of a type that has linkage.
A type without linkage shall not be used as the type of a variable or function with external linkage unless
— the entity has C language linkage (7.5), or
— the entity is declared within an unnamed namespace (7.3.1), or
— the entity is not odr-used (3.2) or is defined in the same translation unit.
33) A class template always has external linkage, and the requirements of 14.3.1 and 14.3.2 ensure that the template arguments
will also have appropriate linkage.
§ 3.5 60

 c ISO/IEC N3242=11-0012
[ Note: In other words, a type without linkage contains a class or enumeration that cannot be named outside
its translation unit. An entity with external linkage declared using such a type could not correspond to any
other entity in another translation unit of the program and thus must be defined in the translation unit if
it is odr-used. Also note that classes with linkage may contain members whose types do not have linkage,
and that typedef names are ignored in the determination of whether a type has linkage. — end note ]
[ Example:
template <class T> struct B {
void g(T) { }
void h(T);
friend void i(B, T) { }
};
void f() {
struct A { int x; }; // no linkage
A a = { 1 };
B<A> ba; // declares B<A>::g(A) and B<A>::h(A)
ba.g(a); // OK
ba.h(a); // error: B<A>::h(A) not defined in the translation unit
i(ba, a); // OK
}
— end example ]
9 Two names that are the same (Clause 3) and that are declared in different scopes shall denote the same
variable, function, type, enumerator, template or namespace if
— both names have external linkage or else both names have internal linkage and are declared in the
same translation unit; and
— both names refer to members of the same namespace or to members, not by inheritance, of the same
class; and
— when both names denote functions, the parameter-type-lists of the functions (8.3.5) are identical; and
— when both names denote function templates, the signatures (14.5.6.1) are the same.
10 After all adjustments of types (during which typedefs (7.1.3) are replaced by their definitions), the types
specified by all declarations referring to a given variable or function shall be identical, except that declarations for an array object can specify array types that differ by the presence or absence of a major array
bound (8.3.4). A violation of this rule on type identity does not require a diagnostic.
11 [ Note: Linkage to non-C++ declarations can be achieved using a linkage-specification (7.5). — end note ]
3.6 Start and termination [basic.start]
3.6.1 Main function [basic.start.main]
1 A program shall contain a global function called main, which is the designated start of the program. It
is implementation-defined whether a program in a freestanding environment is required to define a main
function. [ Note: In a freestanding environment, start-up and termination is implementation-defined; startup contains the execution of constructors for objects of namespace scope with static storage duration;
termination contains the execution of destructors for objects with static storage duration. — end note ]
§ 3.6.1 61

 c ISO/IEC N3242=11-0012
2 An implementation shall not predefine the main function. This function shall not be overloaded. It shall
have a return type of type int, but otherwise its type is implementation-defined. All implementations shall
allow both of the following definitions of main:
int main() { /* ... */ }
and
int main(int argc, char* argv[]) { /* ... */ }
In the latter form argc shall be the number of arguments passed to the program from the environment in which the program is run. If argc is nonzero these arguments shall be supplied in argv[0]
through argv[argc-1] as pointers to the initial characters of null-terminated multibyte strings (ntmbs
s) (17.5.2.1.4.2) and argv[0] shall be the pointer to the initial character of a ntmbs that represents the
name used to invoke the program or "". The value of argc shall be non-negative. The value of argv[argc]
shall be 0. [ Note: It is recommended that any further (optional) parameters be added after argv. — end
note ]
3 The function main shall not be used within a program. The linkage (3.5) of main is implementation-defined.
A program that defines main as deleted or that declares main to be inline, static, or constexpr is illformed. The name main is not otherwise reserved. [ Example: member functions, classes, and enumerations
can be called main, as can entities in other namespaces. — end example ]
4 Terminating the program without leaving the current block (e.g., by calling the function std::exit(int) (18.5))
does not destroy any objects with automatic storage duration (12.4). If std::exit is called to end a program during the destruction of an object with static or thread storage duration, the program has undefined
behavior.
5 A return statement in main has the effect of leaving the main function (destroying any objects with automatic
storage duration) and calling std::exit with the return value as the argument. If control reaches the end
of main without encountering a return statement, the effect is that of executing
return 0;
3.6.2 Initialization of non-local variables [basic.start.init]
1 There are two broad classes of named non-local variables: those with static storage duration (3.7.1) and
those with thread storage duration (3.7.2). Non-local variables with static storage duration are initialized
as a consequence of program initiation. Non-local variables with thread storage duration are initialized as a
consequence of thread execution. Within each of these phases of initiation, initialization occurs as follows.
2 Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5)
before any other initialization takes place.
Constant initialization is performed:
— if each full-expression (including implicit conversions) that appears in the initializer of a reference with
static or thread storage duration is a constant expression (5.19) and the reference is bound to an lvalue
designating an object with static storage duration or to a temporary (see 12.2);
— if an object with static or thread storage duration is initialized by a constructor call, if the constructor is
a constexpr constructor, if all constructor arguments are constant expressions (including conversions),
and if, after function invocation substitution (7.1.5), every constructor call and full-expression in the
mem-initializers is a constant expression;
— if an object with static or thread storage duration is not initialized by a constructor call and if every
full-expression that appears in its initializer is a constant expression.
§ 3.6.2 62

 c ISO/IEC N3242=11-0012
Together, zero-initialization and constant initialization are called static initialization; all other initialization is
dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.
Dynamic initialization of a non-local variable with static storage duration is either ordered or unordered.
Definitions of explicitly specialized class template static data members have ordered initialization. Other
class template static data members (i.e., implicitly or explicitly instantiated specializations) have unordered
initialization. Other non-local variables with static storage duration have ordered initialization. Variables
with ordered initialization defined within a single translation unit shall be initialized in the order of their
definitions in the translation unit. If a program starts a thread (30.3), the subsequent initialization of a
variable is unsequenced with respect to the initialization of a variable defined in a different translation unit.
Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of
a variable defined in a different translation unit. If a program starts a thread, the subsequent unordered
initialization of a variable is unsequenced with respect to every other dynamic initialization. Otherwise,
the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic
initialization. [ Note: This definition permits initialization of a sequence of ordered variables concurrently
with another sequence. — end note ] [ Note: The initialization of local static variables is described in 6.7.
— end note ]
3 An implementation is permitted to perform the initialization of a non-local variable with static storage
duration as a static initialization even if such initialization is not required to be done statically, provided
that
— the dynamic version of the initialization does not change the value of any other object of namespace
scope prior to its initialization, and
— the static version of the initialization produces the same value in the initialized variable as would be
produced by the dynamic initialization if all variables not required to be initialized statically were
initialized dynamically.
— [ Note: As a consequence, if the initialization of an object obj1 refers to an object obj2 of namespace
scope potentially requiring dynamic initialization and defined later in the same translation unit, it is
unspecified whether the value of obj2 used will be the value of the fully initialized obj2 (because obj2
was statically initialized) or will be the value of obj2 merely zero-initialized. For example,
inline double fd() { return 1.0; }
extern double d1;
double d2 = d1; // unspecified:
// may be statically initialized to 0.0 or
// dynamically initialized to 1.0
double d1 = fd(); // may be initialized statically to 1.0
— end note ]
4 It is implementation-defined whether the dynamic initialization of a non-local variable with static storage
duration is done before the first statement of main. If the initialization is deferred to some point in time
after the first statement of main, it shall occur before the first odr-use (3.2) of any function or variable
defined in the same translation unit as the variable to be initialized.34 [ Example:
// - File 1 -
#include "a.h"
#include "b.h"
B b;
A::A(){
b.Use();
34) A non-local variable with static storage duration having initialization with side-effects must be initialized even if it is not
odr-used (3.2, 3.7.1).
§ 3.6.2 63

 c ISO/IEC N3242=11-0012
}
// - File 2 -
#include "a.h"
A a;
// - File 3 -
#include "a.h"
#include "b.h"
extern A a;
extern B b;
int main() {
a.Use();
b.Use();
}
It is implementation-defined whether either a or b is initialized before main is entered or whether the
initializations are delayed until a is first odr-used in main. In particular, if a is initialized before main is
entered, it is not guaranteed that b will be initialized before it is odr-used by the initialization of a, that is,
before A::A is called. If, however, a is initialized at some point after the first statement of main, b will be
initialized prior to its use in A::A. — end example ]
5 It is implementation-defined whether the dynamic initialization of a non-local variable with static or thread
storage duration is done before the first statement of the initial function of the thread. If the initialization
is deferred to some point in time after the first statement of the initial function of the thread, it shall occur
before the first odr-use (3.2) of any variable with thread storage duration defined in the same translation
unit as the variable to be initialized.
6 If the initialization of a non-local variable with static or thread storage duration exits via an exception,
std::terminate is called (15.5.1).
3.6.3 Termination [basic.start.term]
1 Destructors (12.4) for initialized objects (that is, objects whose lifetime (3.8) has begun) with static storage
duration are called as a result of returning from main and as a result of calling std::exit (18.5). Destructors
for initialized objects with thread storage duration within a given thread are called as a result of returning
from the initial function of that thread and as a result of that thread calling std::exit. The completions
of the destructors for all initialized objects with thread storage duration within that thread are sequenced
before the initiation of the destructors of any object with static storage duration. If the completion of the
constructor or dynamic initialization of an object with thread storage duration is sequenced before that of
another, the completion of the destructor of the second is sequenced before the initiation of the destructor
of the first. If the completion of the constructor or dynamic initialization of an object with static storage
duration is sequenced before that of another, the completion of the destructor of the second is sequenced
before the initiation of the destructor of the first. [ Note: This definition permits concurrent destruction.
— end note ] If an object is initialized statically, the object is destroyed in the same order as if the object was
dynamically initialized. For an object of array or class type, all subobjects of that object are destroyed before
any block-scope object with static storage duration initialized during the construction of the subobjects is
destroyed. If the destruction of an object with static or thread storage duration exits via an exception,
std::terminate is called (15.5.1).
2 If a function contains a block-scope object of static or thread storage duration that has been destroyed and
the function is called during the destruction of an object with static or thread storage duration, the program
§ 3.6.3 64

 c ISO/IEC N3242=11-0012
has undefined behavior if the flow of control passes through the definition of the previously destroyed blockscope object. Likewise, the behavior is undefined if the block-scope object is used indirectly (i.e., through a
pointer) after its destruction.
3 If the completion of the initialization of an object with static storage duration is sequenced before a call
to std::atexit (see <cstdlib>, 18.5), the call to the function passed to std::atexit is sequenced before
the call to the destructor for the object. If a call to std::atexit is sequenced before the completion of the
initialization of an object with static storage duration, the call to the destructor for the object is sequenced
before the call to the function passed to std::atexit. If a call to std::atexit is sequenced before another
call to std::atexit, the call to the function passed to the second std::atexit call is sequenced before the
call to the function passed to the first std::atexit call.
4 If there is a use of a standard library object or function not permitted within signal handlers (18.10) that
does not happen before (1.10) completion of destruction of objects with static storage duration and execution
of std::atexit registered functions (18.5), the program has undefined behavior. [ Note: If there is a use
of an object with static storage duration that does not happen before the object’s destruction, the program
has undefined behavior. Terminating every thread before a call to std::exit or the exit from main is
sufficient, but not necessary, to satisfy these requirements. These requirements permit thread managers as
static-storage-duration objects. — end note ]
5 Calling the function std::abort() declared in <cstdlib> terminates the program without executing any
destructors and without calling the functions passed to std::atexit() or std::at_quick_exit().
3.7 Storage duration [basic.stc]
1 Storage duration is the property of an object that defines the minimum potential lifetime of the storage
containing the object. The storage duration is determined by the construct used to create the object and is
one of the following:
— static storage duration
— thread storage duration
— automatic storage duration
— dynamic storage duration
2 Static, thread, and automatic storage durations are associated with objects introduced by declarations (3.1)
and implicitly created by the implementation (12.2). The dynamic storage duration is associated with objects
created with operator new (5.3.4).
3 The storage duration categories apply to references as well. The lifetime of a reference is its storage duration.
3.7.1 Static storage duration [basic.stc.static]
1 All variables which do not have dynamic storage duration, do not have thread storage duration, and are
not local have static storage duration. The storage for these entities shall last for the duration of the
program (3.6.2, 3.6.3).
2 If a variable with static storage duration has initialization or a destructor with side effects, it shall not be
eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated
as specified in 12.8.
3 The keyword static can be used to declare a local variable with static storage duration. [ Note: 6.7 describes
the initialization of local static variables; 3.6.3 describes the destruction of local static variables. — end
note ]
§ 3.7.1 65

 c ISO/IEC N3242=11-0012
4 The keyword static applied to a class data member in a class definition gives the data member static
storage duration.
3.7.2 Thread storage duration [basic.stc.thread]
1 All variables declared with the thread_local keyword have thread storage duration. The storage for these
entities shall last for the duration of the thread in which they are created. There is a distinct object or
reference per thread, and use of the declared name refers to the entity associated with the current thread.
2 A variable with thread storage duration shall be initialized before its first odr-use (3.2) and, if constructed,
shall be destroyed on thread exit.
3.7.3 Automatic storage duration [basic.stc.auto]
1 Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration. The storage for these entities lasts until the block in which they are created
exits.
2 [ Note: These variables are initialized and destroyed as described in 6.7. — end note ]
3 If a variable with automatic storage duration has initialization or a destructor with side effects, it shall not
be destroyed before the end of its block, nor shall it be eliminated as an optimization even if it appears to
be unused, except that a class object or its copy/move may be eliminated as specified in 12.8.
3.7.4 Dynamic storage duration [basic.stc.dynamic]
1 Objects can be created dynamically during program execution (1.9), using new-expressions (5.3.4), and
destroyed using delete-expressions (5.3.5). A C++ implementation provides access to, and management
of, dynamic storage via the global allocation functions operator new and operator new[] and the global
deallocation functions operator delete and operator delete[].
2 The library provides default definitions for the global allocation and deallocation functions. Some global
allocation and deallocation functions are replaceable (18.6.1). A C++ program shall provide at most one
definition of a replaceable allocation or deallocation function. Any such function definition replaces the
default version provided in the library (17.6.4.6). The following allocation and deallocation functions (18.6)
are implicitly declared in global scope in each translation unit of a program.
void* operator new(std::size_t);
void* operator new[](std::size_t);
void operator delete(void*);
void operator delete[](void*);
These implicit declarations introduce only the function names operator new, operator new[], operator delete, and operator delete[]. [ Note: The implicit declarations do not introduce the names std,
std::size_t, or any other names that the library uses to declare these names. Thus, a new-expression,
delete-expression or function call that refers to one of these functions without including the header <new>
is well-formed. However, referring to std or std::size_t is ill-formed unless the name has been declared
by including the appropriate header. — end note ] Allocation and/or deallocation functions can also be
declared and defined for any class (12.5).
3 Any allocation and/or deallocation functions defined in a C++ program, including the default versions in
the library, shall conform to the semantics specified in 3.7.4.1 and 3.7.4.2.
3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]
1 An allocation function shall be a class member function or a global function; a program is ill-formed if an
allocation function is declared in a namespace scope other than global scope or declared static in global
§ 3.7.4.1 66

 c ISO/IEC N3242=11-0012
scope. The return type shall be void*. The first parameter shall have type std::size_t (18.2). The first
parameter shall not have an associated default argument (8.3.6). The value of the first parameter shall be
interpreted as the requested size of the allocation. An allocation function can be a function template. Such
a template shall declare its return type and first parameter as specified above (that is, template parameter
types shall not be used in the return type and first parameter type). Template allocation functions shall
have two or more parameters.
2 The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall
return the address of the start of a block of storage whose length in bytes shall be at least as large as
the requested size. There are no constraints on the contents of the allocated storage on return from the
allocation function. The order, contiguity, and initial value of storage allocated by successive calls to an
allocation function are unspecified. The pointer returned shall be suitably aligned so that it can be converted
to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used
to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to
a corresponding deallocation function). Even if the size of the space requested is zero, the request can fail.
If the request succeeds, the value returned shall be a non-null pointer value (4.10) p0 different from any
previously returned value p1, unless that value p1 was subsequently passed to an operator delete. The
effect of dereferencing a pointer returned as a request for zero size is undefined.35
3 An allocation function that fails to allocate storage can invoke the currently installed new-handler function (18.6.2.3), if any. [ Note: A program-supplied allocation function can obtain the address of the currently
installed new_handler using the std::sget_new_handler function (18.6.2.4). — end note ] If an allocation
function declared with a non-throwing exception-specification (15.4) fails to allocate storage, it shall return
a null pointer. Any other allocation function that fails to allocate storage shall indicate failure only by
throwing an exception of a type that would match a handler (15.3) of type std::bad_alloc (18.6.2.1).
4 A global allocation function is only called as the result of a new expression (5.3.4), or called directly using the
function call syntax (5.2.2), or called indirectly through calls to the functions in the C++ standard library.
[ Note: In particular, a global allocation function is not called to allocate storage for objects with static
storage duration (3.7.1), for objects or references with thread storage duration (3.7.2), for objects of type
std::type_info (5.2.8), or for the copy of an object thrown by a throw expression (15.1). — end note ]
3.7.4.2 Deallocation functions [basic.stc.dynamic.deallocation]
1 Deallocation functions shall be class member functions or global functions; a program is ill-formed if deallocation functions are declared in a namespace scope other than global scope or declared static in global
scope.
2 Each deallocation function shall return void and its first parameter shall be void*. A deallocation function
can have more than one parameter. If a class T has a member deallocation function named operator delete
with exactly one parameter, then that function is a usual (non-placement) deallocation function. If class T
does not declare such an operator delete but does declare a member deallocation function named operator
delete with exactly two parameters, the second of which has type std::size_t (18.2), then this function
is a usual deallocation function. Similarly, if a class T has a member deallocation function named operator
delete[] with exactly one parameter, then that function is a usual (non-placement) deallocation function.
If class T does not declare such an operator delete[] but does declare a member deallocation function
named operator delete[] with exactly two parameters, the second of which has type std::size_t, then
this function is a usual deallocation function. A deallocation function can be an instance of a function
template. Neither the first parameter nor the return type shall depend on a template parameter. [ Note:
That is, a deallocation function template shall have a first parameter of type void* and a return type of
35) The intent is to have operator new() implementable by calling std::malloc() or std::calloc(), so the rules are substantially the same. C++ differs from C in requiring a zero request to return a non-null pointer.
§ 3.7.4.2 67

 c ISO/IEC N3242=11-0012
void (as specified above). — end note ] A deallocation function template shall have two or more function
parameters. A template instance is never a usual deallocation function, regardless of its signature.
3 If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the
first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation
function is one supplied in the standard library, the call has no effect. Otherwise, the behavior is undefined
if the value supplied to operator delete(void*) in the standard library is not one of the values returned
by a previous invocation of either operator new(std::size_t) or operator new(std::size_t, const
std::nothrow_t&) in the standard library, and the behavior is undefined if the value supplied to operator
delete[](void*) in the standard library is not one of the values returned by a previous invocation of
either operator new[](std::size_t) or operator new[](std::size_t, const std::nothrow_t&) in the
standard library.
4 If the argument given to a deallocation function in the standard library is a pointer that is not the null pointer
value (4.10), the deallocation function shall deallocate the storage referenced by the pointer, rendering invalid
all pointers referring to any part of the deallocated storage. The effect of using an invalid pointer value
(including passing it to a deallocation function) is undefined.36
3.7.4.3 Safely-derived pointers [basic.stc.dynamic.safety]
1 A traceable pointer object is
— an object of pointer-to-object type, or
— an object of an integral type that is at least as large as std::intptr_t, or
— a sequence of elements in an array of character type, where the size and alignment of the sequence
match that of some pointer-to-object type.
2 A pointer value is a safely-derived pointer to a dynamic object only if it has pointer-to-object type and it is
one of the following:
— the value returned by a call to the C++ standard library implementation of ::operator new(std::size_-
t);37
— the result of taking the address of an object (or one of its subobjects) designated by an lvalue resulting
from dereferencing a safely-derived pointer value;
— the result of well-defined pointer arithmetic (5.7) using a safely-derived pointer value;
— the result of a well-defined pointer conversion (4.10, 5.4) of a safely-derived pointer value;
— the result of a reinterpret_cast of a safely-derived pointer value;
— the result of a reinterpret_cast of an integer representation of a safely-derived pointer value;
— the value of an object whose value was copied from a traceable pointer object, where at the time of
the copy the source object contained a copy of a safely-derived pointer value.
3 An integer value is an integer representation of a safely-derived pointer only if its type is at least as large as
std::intptr_t and it is one of the following:
— the result of a reinterpret_cast of a safely-derived pointer value;
— the result of a valid conversion of an integer representation of a safely-derived pointer value;
36) On some implementations, it causes a system-generated runtime fault.
37) This section does not impose restrictions on dereferencing pointers to memory not allocated by ::operator new. This
maintains the ability of many C++ implementations to use binary libraries and components written in other languages. In
particular, this applies to C binaries, because dereferencing pointers to memory allocated by malloc is not restricted.
§ 3.7.4.3 68

 c ISO/IEC N3242=11-0012
— the value of an object whose value was copied from a traceable pointer object, where at the time of
the copy the source object contained an integer representation of a safely-derived pointer value;
— the result of an additive or bitwise operation, one of whose operands is an integer representation of a
safely-derived pointer value P, if that result converted by reinterpret_cast<void*> would compare
equal to a safely-derived pointer computable from reinterpret_cast<void*>(P).
4 An implementation may have relaxed pointer safety, in which case the validity of a pointer value does not
depend on whether it is a safely-derived pointer value. Alternatively, an implementation may have strict
pointer safety, in which case, if a pointer value that is not a safely-derived pointer value is dereferenced
or deallocated, and the referenced complete object is of dynamic storage duration and has not previously
been declared reachable (20.6.4), the behavior is undefined. [ Note: This is true even if the unsafely-derived
pointer value might compare equal to some safely-derived pointer value. — end note ] It is implementation
defined whether an implementation has relaxed or strict pointer safety.
3.7.5 Duration of subobjects [basic.stc.inherit]
1 The storage duration of member subobjects, base class subobjects and array elements is that of their complete
object (1.8).
3.8 Object lifetime [basic.life]
1 The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization
if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial
default constructor. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. —
end note ] The lifetime of an object of type T begins when:
— storage with the proper alignment and size for type T is obtained, and
— if the object has non-trivial initialization, its initialization is complete.
The lifetime of an object of type T ends when:
— if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or
— the storage which the object occupies is reused or released.
2 [ Note: The lifetime of an array object starts as soon as storage with proper size and alignment is obtained,
and its lifetime ends when the storage which the array occupies is reused or released. 12.6.2 describes the
lifetime of base and member subobjects. — end note ]
3 The properties ascribed to objects throughout this International Standard apply for a given object only
during its lifetime. [ Note: In particular, before the lifetime of an object starts and after its lifetime ends
there are significant restrictions on the use of the object, as described below, in 12.6.2 and in 12.7. Also,
the behavior of an object under construction and destruction might not be the same as the behavior of an
object whose lifetime has started and not ended. 12.6.2 and 12.7 describe the behavior of objects during the
construction and destruction phases. — end note ]
4 A program may end the lifetime of any object by reusing the storage which the object occupies or by
explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object
of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly
before the storage which the object occupies is reused or released; however, if there is no explicit call to
the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be
implicitly called and any program that depends on the side effects produced by the destructor has undefined
behavior.
§ 3.8 69

 c ISO/IEC N3242=11-0012
5 Before the lifetime of an object has started but after the storage which the object will occupy has been
allocated38 or, after the lifetime of an object has ended and before the storage which the object occupied is
reused or released, any pointer that refers to the storage location where the object will be or was located
may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise,
such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type void*,
is well-defined. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited
ways, as described below. The program has undefined behavior if:
— the object will be or was of a class type with a non-trivial destructor and the pointer is used as the
operand of a delete-expression,
— the pointer is used to access a non-static data member or call a non-static member function of the
object, or
— the pointer is implicitly converted (4.10) to a pointer to a base class type, or
— the pointer is used as the operand of a static_cast (5.2.9) (except when the conversion is to void*,
or to void* and subsequently to char*, or unsigned char*), or
— the pointer is used as the operand of a dynamic_cast (5.2.7). [ Example:
#include <cstdlib>
struct B {
virtual void f();
void mutate();
virtual ~B();
};
struct D1 : B { void f(); };
struct D2 : B { void f(); };
void B::mutate() {
new (this) D2; // reuses storage — ends the lifetime of *this
f(); // undefined behavior
... = this; // OK, this points to valid memory
}
void g() {
void* p = std::malloc(sizeof(D1) + sizeof(D2));
B* pb = new (p) D1;
pb->mutate();
&pb; // OK: pb points to valid memory
void* q = pb; // OK: pb points to valid memory
pb->f(); // undefined behavior, lifetime of *pb has ended
} —
end example ]
6 Similarly, before the lifetime of an object has started but after the storage which the object will occupy
has been allocated or, after the lifetime of an object has ended and before the storage which the object
occupied is reused or released, any glvalue that refers to the original object may be used but only in limited
ways. For an object under construction or destruction, see 12.7. Otherwise, such a glvalue refers to allocated
storage (3.7.4.2), and using the properties of the glvalue that do not depend on its value is well-defined. The
program has undefined behavior if:
38) For example, before the construction of a global object of non-POD class type (12.7).
§ 3.8 70

 c ISO/IEC N3242=11-0012
— an lvalue-to-rvalue conversion (4.1) is applied to such a glvalue,
— the glvalue is used to access a non-static data member or call a non-static member function of the
object, or
— the glvalue is implicitly converted (4.10) to a reference to a base class type, or
— the glvalue is used as the operand of a static_cast (5.2.9) except when the conversion is ultimately
to cv char& or cv unsigned char&, or
— the glvalue is used as the operand of a dynamic_cast (5.2.7) or as the operand of typeid.
7 If, after the lifetime of an object has ended and before the storage which the object occupied is reused or
released, a new object is created at the storage location which the original object occupied, a pointer that
pointed to the original object, a reference that referred to the original object, or the name of the original
object will automatically refer to the new object and, once the lifetime of the new object has started, can
be used to manipulate the new object, if:
— the storage for the new object exactly overlays the storage location which the original object occupied,
and
— the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and
— the type of the original object is not const-qualified, and, if a class type, does not contain any non-static
data member whose type is const-qualified or a reference type, and
— the original object was a most derived object (1.8) of type T and the new object is a most derived
object of type T (that is, they are not base class subobjects). [ Example:
struct C {
int i;
void f();
const C& operator=( const C& );
};
const C& C::operator=( const C& other) {
if ( this != &other ) {
this->~C(); // lifetime of *this ends
new (this) C(other); // new object of type C created
f(); // well-defined
}
return *this;
}
C c1;
C c2;
c1 = c2; // well-defined
c1.f(); // well-defined; c1 refers to a new object of type C
— end example ]
8 If a program ends the lifetime of an object of type T with static (3.7.1), thread (3.7.2), or automatic (3.7.3)
storage duration and if T has a non-trivial destructor,39 the program must ensure that an object of the
original type occupies that same storage location when the implicit destructor call takes place; otherwise the
behavior of the program is undefined. This is true even if the block is exited with an exception. [ Example:
39) That is, an object for which a destructor will be called implicitly—upon exit from the block for an object with automatic
storage duration, upon exit from the thread for an object with thread storage duration, or upon exit from the program for an
object with static storage duration.
§ 3.8 71

 c ISO/IEC N3242=11-0012
class T { };
struct B {
~B();
};
void h() {
B b;
new (&b) T;
} // undefined behavior at block exit
— end example ]
9 Creating a new object at the storage location that a const object with static, thread, or automatic storage
duration occupies or, at the storage location that such a const object used to occupy before its lifetime
ended results in undefined behavior. [ Example:
struct B {
B();
~B();
};
const B b;
void h() {
b.~B();
new (const_cast<B*>(&b)) const B; // undefined behavior
}
— end example ]
10 In this section, “before” and “after” refer to the “happens before” relation (1.10). [ Note: Therefore, undefined
behavior results if an object that is being constructed in one thread is referenced from another thread without
adequate synchronization. — end note ]
3.9 Types [basic.types]
1 [ Note: 3.9 and the subclauses thereof impose requirements on implementations regarding the representation
of types. There are two kinds of types: fundamental types and compound types. Types describe objects
(1.8), references (8.3.2), or functions (8.3.5). — end note ]
2 For any object (other than a base-class subobject) of trivially copyable type T, whether or not the object
holds a valid value of type T, the underlying bytes (1.7) making up the object can be copied into an array
of char or unsigned char.40 If the content of the array of char or unsigned char is copied back into the
object, the object shall subsequently hold its original value. [ Example:
#define N sizeof(T)
char buf[N];
T obj; // obj initialized to its original value
std::memcpy(buf, &obj, N); // between these two calls to std::memcpy,
// obj might be modified
std::memcpy(&obj, buf, N); // at this point, each subobject of obj of scalar type
// holds its original value
40) By using, for example, the library functions (17.6.1.2) std::memcpy or std::memmove.
§ 3.9 72

 c ISO/IEC N3242=11-0012
— end example ]
3 For any trivially copyable type T, if two pointers to T point to distinct T objects obj1 and obj2, where
neither obj1 nor obj2 is a base-class subobject, if the underlying bytes (1.7) making up obj1 are copied
into obj2,41 obj2 shall subsequently hold the same value as obj1. [ Example:
T* t1p;
T* t2p;
// provided that t2p points to an initialized object ...
std::memcpy(t1p, t2p, sizeof(T));
// at this point, every subobject of trivially copyable type in *t1p contains
// the same value as the corresponding subobject in *t2p
— end example ]
4 The object representation of an object of type T is the sequence of N unsigned char objects taken up by
the object of type T, where N equals sizeof(T). The value representation of an object is the set of bits that
hold the value of type T. For trivially copyable types, the value representation is a set of bits in the object
representation that determines a value, which is one discrete element of an implementation-defined set of
values.42
5 A class that has been declared but not defined, or an array of unknown size or of incomplete element type, is
an incompletely-defined object type.43 Incompletely-defined object types and the void types are incomplete
types (3.9.1). Objects shall not be defined to have an incomplete type.
6 A class type (such as “class X”) might be incomplete at one point in a translation unit and complete later
on; the type “class X” is the same type at both points. The declared type of an array object might be
an array of incomplete class type and therefore incomplete; if the class type is completed later on in the
translation unit, the array type becomes complete; the array type at those two points is the same type. The
declared type of an array object might be an array of unknown size and therefore be incomplete at one point
in a translation unit and complete later on; the array types at those two points (“array of unknown bound
of T” and “array of N T”) are different types. The type of a pointer to array of unknown size, or of a type
defined by a typedef declaration to be an array of unknown size, cannot be completed. [ Example:
class X; // X is an incomplete type
extern X* xp; // xp is a pointer to an incomplete type
extern int arr[]; // the type of arr is incomplete
typedef int UNKA[]; // UNKA is an incomplete type
UNKA* arrp; // arrp is a pointer to an incomplete type
UNKA** arrpp;
void foo() {
xp++; // ill-formed: X is incomplete
arrp++; // ill-formed: incomplete type
arrpp++; // OK: sizeof UNKA* is known
}
struct X { int i; }; // now X is a complete type
int arr[10]; // now the type of arr is complete
X x;
void bar() {
xp = &x; // OK; type is “pointer to X”
41) By using, for example, the library functions (17.6.1.2) std::memcpy or std::memmove.
42) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.
43) The size and layout of an instance of an incompletely-defined object type is unknown.
§ 3.9 73

 c ISO/IEC N3242=11-0012
arrp = &arr; // ill-formed: different types
xp++; // OK: X is complete
arrp++; // ill-formed: UNKA can’t be completed
} —
end example ]
7 [ Note: The rules for declarations and expressions describe in which contexts incomplete types are prohibited.
— end note ]
8 An object type is a (possibly cv-qualified) type that is not a function type, not a reference type, and not a
void type.
9 Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types (3.9.2), std::nullptr_-
t, and cv-qualified versions of these types (3.9.3) are collectively called scalar types. Scalar types, POD
classes (Clause 9), arrays of such types and cv-qualified versions of these types (3.9.3) are collectively called
POD types. Scalar types, trivially copyable class types (Clause 9), arrays of such types, and cv-qualified
versions of these types (3.9.3) are collectively called trivially copyable types. Scalar types, trivial class types
(Clause 9), arrays of such types and cv-qualified versions of these types (3.9.3) are collectively called trivial
types. Scalar types, standard-layout class types (Clause 9), arrays of such types and cv-qualified versions of
these types (3.9.3) are collectively called standard-layout types.
10 A type is a literal type if it is:
— a scalar type; or
— a class type (Clause 9) with
— a trivial copy constructor,
— no non-trivial move constructor,
— a trivial destructor,
— a trivial default constructor or at least one constexpr constructor other than the copy or move
constructor, and
— all non-static data members and base classes of literal types; or
— an array of literal type.
11 If two types T1 and T2 are the same type, then T1 and T2 are layout-compatible types. [ Note: Layoutcompatible enumerations are described in 7.2. Layout-compatible standard-layout structs and standardlayout unions are described in 9.2. — end note ]
3.9.1 Fundamental types [basic.fundamental]
1 Objects declared as characters (char) shall be large enough to store any member of the implementation’s basic character set. If a character from this set is stored in a character object, the integral value of that character
object is equal to the value of the single character literal form of that character. It is implementation-defined
whether a char object can hold negative values. Characters can be explicitly declared unsigned or signed.
Plain char, signed char, and unsigned char are three distinct types. A char, a signed char, and an
unsigned char occupy the same amount of storage and have the same alignment requirements (3.11); that
is, they have the same object representation. For character types, all bits of the object representation participate in the value representation. For unsigned character types, all possible bit patterns of the value
§ 3.9.1 74

 c ISO/IEC N3242=11-0012
representation represent numbers. These requirements do not hold for other types. In any particular implementation, a plain char object can take on either the same values as a signed char or an unsigned char;
which one is implementation-defined.
2 There are five standard signed integer types : “signed char”, “short int”, “int”, “long int”, and “long
long int”. In this list, each type provides at least as much storage as those preceding it in the list.
There may also be implementation-defined extended signed integer types. The standard and extended signed
integer types are collectively called signed integer types. Plain ints have the natural size suggested by the
architecture of the execution environment44; the other signed integer types are provided to meet special
needs.
3 For each of the standard signed integer types, there exists a corresponding (but different) standard unsigned integer type: “unsigned char”, “unsigned short int”, “unsigned int”, “unsigned long int”,
and “unsigned long long int”, each of which occupies the same amount of storage and has the same
alignment requirements (3.11) as the corresponding signed integer type45; that is, each signed integer type
has the same object representation as its corresponding unsigned integer type. Likewise, for each of the
extended signed integer types there exists a corresponding extended unsigned integer type with the same
amount of storage and alignment requirements. The standard and extended unsigned integer types are
collectively called unsigned integer types. The range of non-negative values of a signed integer type is a
subrange of the corresponding unsigned integer type, and the value representation of each corresponding
signed/unsigned type shall be the same. The standard signed integer types and standard unsigned integer
types are collectively called the standard integer types, and the extended signed integer types and extended
unsigned integer types are collectively called the extended integer types.
4 Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2n where n is the number
of bits in the value representation of that particular size of integer.46
5 Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest
extended character set specified among the supported locales (22.3.1). Type wchar_t shall have the same
size, signedness, and alignment requirements (3.11) as one of the other integral types, called its underlying
type. Types char16_t and char32_t denote distinct types with the same size, signedness, and alignment as
uint_least16_t and uint_least32_t, respectively, in <stdint.h>, called the underlying types.
6 Values of type bool are either true or false.47 [ Note: There are no signed, unsigned, short, or long
bool types or values. — end note ] Values of type bool participate in integral promotions (4.5).
7 Types bool, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively
called integral types.48 A synonym for integral type is integer type. The representations of integral types
shall define values by use of a pure binary numeration system.49 [ Example: this International Standard
permits 2’s complement, 1’s complement and signed magnitude representations for integral types. — end
example ]
8 There are three floating point types: float, double, and long double. The type double provides at least
as much precision as float, and the type long double provides at least as much precision as double.
44) that is, large enough to contain any value in the range of INT_MIN and INT_MAX, as defined in the header <climits>.
45) See 7.1.6.2 regarding the correspondence between types and the sequences of type-specifiers that designate them.
46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting
unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the
resulting unsigned integer type.
47) Using a bool value in ways described by this International Standard as “undefined,” such as by examining the value of an
uninitialized automatic object, might cause it to behave as if it is neither true nor false.
48) Therefore, enumerations (7.2) are not integral; however, enumerations can be promoted to integral types as specified in 4.5.
49) A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive
bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest
position. (Adapted from the American National Dictionary for Information Processing Systems.)
§ 3.9.1 75

 c ISO/IEC N3242=11-0012
The set of values of the type float is a subset of the set of values of the type double; the set of values
of the type double is a subset of the set of values of the type long double. The value representation of
floating-point types is implementation-defined. Integral and floating types are collectively called arithmetic
types. Specializations of the standard template std::numeric_limits (18.3) shall specify the maximum
and minimum values of each arithmetic type for an implementation.
9 The void type has an empty set of values. The void type is an incomplete type that cannot be completed. It
is used as the return type for functions that do not return a value. Any expression can be explicitly converted
to type cv void (5.4). An expression of type void shall be used only as an expression statement (6.2), as an
operand of a comma expression (5.18), as a second or third operand of ?: (5.16), as the operand of typeid,
or as the expression in a return statement (6.6.3) for a function with the return type void.
10 A value of type std::nullptr_t is a null pointer constant (4.10). Such values participate in the pointer and
the pointer to member conversions (4.10, 4.11). sizeof(std::nullptr_t) shall be equal to sizeof(void*).
11 [Note: Even if the implementation defines two or more basic types to have the same value representation,
they are nevertheless different types. —end note ]
3.9.2 Compound types [basic.compound]
1 Compound types can be constructed in the following ways:
— arrays of objects of a given type, 8.3.4;
— functions, which have parameters of given types and return void or references or objects of a given
type, 8.3.5;
— pointers to void or objects or functions (including static members of classes) of a given type, 8.3.1;
— references to objects or functions of a given type, 8.3.2. There are two types of references:
— lvalue reference
— rvalue reference
— classes containing a sequence of objects of various types (Clause 9), a set of types, enumerations and
functions for manipulating these objects (9.3), and a set of restrictions on the access to these entities
(Clause 11);
— unions, which are classes capable of containing objects of different types at different times, 9.5;
— enumerations, which comprise a set of named constant values. Each distinct enumeration constitutes
a different enumerated type, 7.2;
— pointers to non-static 50 class members, which identify members of a given type within objects of a
given class, 8.3.3.
2 These methods of constructing types can be applied recursively; restrictions are mentioned in 8.3.1, 8.3.4,
8.3.5, and 8.3.2.
3 A pointer to objects of type T is referred to as a “pointer to T.” [Example: a pointer to an object of type
int is referred to as “pointer to int ” and a pointer to an object of class X is called a “pointer to X.” —end
example ] Except for pointers to static members, text referring to “pointers” does not apply to pointers to
members. Pointers to incomplete types are allowed although there are restrictions on what can be done with
them (3.11). A valid value of an object pointer type represents either the address of a byte in memory (1.7)
or a null pointer (4.10). If an object of type T is located at an address A, a pointer of type cv T* whose value
is the address A is said to point to that object, regardless of how the value was obtained. [Note: For instance,
50) Static class members are objects or functions, and pointers to them are ordinary pointers to objects or functions.
§ 3.9.2 76

 c ISO/IEC N3242=11-0012
the address one past the end of an array (5.7) would be considered to point to an unrelated object of the
array’s element type that might be located at that address. There are further restrictions on pointers to
objects with dynamic storage duration; see 3.7.4.3. — end note ] The value representation of pointer types
is implementation-defined. Pointers to cv-qualified and cv-unqualified versions (3.9.3) of layout-compatible
types shall have the same value representation and alignment requirements (3.11). [ Note: Pointers to
over-aligned types (3.11) have no special representation, but their range of valid values is restricted by the
extended alignment requirement. This International Standard specifies only two ways of obtaining such a
pointer: taking the address of a valid object with an over-aligned type, and using one of the runtime pointer
alignment functions. An implementation may provide other means of obtaining a valid pointer value for an
over-aligned type. — end note ]
4 Objects of cv-qualified (3.9.3) or cv-unqualified type void* (pointer to void), can be used to point to objects
of unknown type. A void* shall be able to hold any object pointer. A cv-qualified or cv-unqualified (3.9.3)
void* shall have the same representation and alignment requirements as a cv-qualified or cv-unqualified
char*.
3.9.3 CV-qualifiers [basic.type.qualifier]
1 A type mentioned in 3.9.1 and 3.9.2 is a cv-unqualified type. Each type which is a cv-unqualified complete
or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type: a
const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. The term object
type (1.8) includes the cv-qualifiers specified when the object is created. The presence of a const specifier
in a decl-specifier-seq declares an object of const-qualified object type; such object is called a const object.
The presence of a volatile specifier in a decl-specifier-seq declares an object of volatile-qualified object type;
such object is called a volatile object. The presence of both cv-qualifiers in a decl-specifier-seq declares an
object of const-volatile-qualified object type; such object is called a const volatile object. The cv-qualified or
cv-unqualified versions of a type are distinct types; however, they shall have the same representation and
alignment requirements (3.9).51
2 A compound type (3.9.2) is not cv-qualified by the cv-qualifiers (if any) of the types from which it is compounded. Any cv-qualifiers applied to an array type affect the array element type, not the array type (8.3.4).
3 Each non-static, non-mutable, non-reference data member of a const-qualified class object is const-qualified, each non-static, non-reference data member of a volatile-qualified class object is volatile-qualified and
similarly for members of a const-volatile class. See 8.3.5 and 9.3.2 regarding function types that have
cv-qualifiers.
4 There is a partial ordering on cv-qualifiers, so that a type can be said to be more cv-qualified than another.
Table 9 shows the relations that constitute this ordering.
Table 9 — Relations on const and volatile
no cv-qualifier < const
no cv-qualifier < volatile
no cv-qualifier < const volatile
const < const volatile
volatile < const volatile
5 In this International Standard, the notation cv (or cv1, cv2, etc.), used in the description of types, represents
an arbitrary set of cv-qualifiers, i.e., one of {const}, {volatile}, {const, volatile}, or the empty set.
Cv-qualifiers applied to an array type attach to the underlying element type, so the notation “cv T,” where
51) The same representation and alignment requirements are meant to imply interchangeability as arguments to functions,
return values from functions, and non-static data members of unions.
§ 3.9.3 77

 c ISO/IEC N3242=11-0012
T is an array type, refers to an array whose elements are so-qualified. Such array types can be said to be
more (or less) cv-qualified than other types based on the cv-qualification of the underlying element types.
3.10 Lvalues and rvalues [basic.lval]
1 Expressions are categorized according to the taxonomy in Figure 1.
expression
glvalue rvalue
lvalue xvalue prvalue
Figure 1 — Expression category taxonomy
— An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment
expression) designates a function or an object. [ Example: If E is an expression of pointer type, then
*E is an lvalue expression referring to the object or function to which E points. As another example,
the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]
— An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its
resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving
rvalue references (8.3.2). [ Example: The result of calling a function whose return type is an rvalue
reference is an xvalue. — end example ]
— A glvalue (“generalized” lvalue) is an lvalue or an xvalue.
— An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment
expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated
with an object.
— A prvalue (“pure” rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function
whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is
also a prvalue. — end example ]
Every expression belongs to exactly one of the fundamental classifications in this taxonomy: lvalue, xvalue,
or prvalue. This property of an expression is called its value category. [ Note: The discussion of each built-in
operator in Clause 5 indicates the category of the value it yields and the value categories of the operands it
expects. For example, the built-in assignment operators expect that the left operand is an lvalue and that
the right operand is a prvalue and yield an lvalue as the result. User-defined operators are functions, and
the categories of values they expect and yield are determined by their parameter and return types. — end
note ]
2 Whenever a glvalue appears in a context where a prvalue is expected, the glvalue is converted to a prvalue;
see 4.1, 4.2, and 4.3. [ Note: An attempt to bind an rvalue reference to an lvalue is not such a context;
see 8.5.3. — end note ]
3 The discussion of reference initialization in 8.5.3 and of temporaries in 12.2 indicates the behavior of lvalues
and rvalues in other significant contexts.
§ 3.10 78

 c ISO/IEC N3242=11-0012
4 Class prvalues can have cv-qualified types; non-class prvalues always have cv-unqualified types. Prvalues shall
always have complete types or the void type; in addition to these types, glvalues can also have incomplete
types.
5 An lvalue for an object is necessary in order to modify the object except that an rvalue of class type can
also be used to modify its referent under certain circumstances. [ Example: a member function called for an
object (9.3) can modify the object. — end example ]
6 Functions cannot be modified, but pointers to functions can be modifiable.
7 A pointer to an incomplete type can be modifiable. At some point in the program when the pointed to type
is complete, the object at which the pointer points can also be modified.
8 The referent of a const-qualified expression shall not be modified (through that expression), except that if
it is of class type and has a mutable component, that component can be modified (7.1.6.1).
9 If an expression can be used to modify the object to which it refers, the expression is called modifiable. A
program that attempts to modify an object through a nonmodifiable lvalue or rvalue expression is ill-formed.
10 If a program attempts to access the stored value of an object through a glvalue of other than one of the
following types the behavior is undefined:52
— the dynamic type of the object,
— a cv-qualified version of the dynamic type of the object,
— a type similar (as defined in 4.4) to the dynamic type of the object,
— a type that is the signed or unsigned type corresponding to the dynamic type of the object,
— a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type
of the object,
— an aggregate or union type that includes one of the aforementioned types among its elements or nonstatic data members (including, recursively, an element or non-static data member of a subaggregate
or contained union),
— a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,
— a char or unsigned char type.
3.11 Alignment [basic.align]
1 Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an
object of that type may be allocated. An alignment is an implementation-defined integer value representing
the number of bytes between successive addresses at which a given object can be allocated. An object type
imposes an alignment requirement on every object of that type; stricter alignment can be requested using
the alignment specifier (7.6.2).
2 A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to alignof(std::max_align_t) (18.2).
3 An extended alignment is represented by an alignment greater than alignof(std::max_align_t). It is
implementation-defined whether any extended alignments are supported and the contexts in which they are
supported (7.6.2). A type having an extended alignment requirement is an over-aligned type. [ Note: Every
over-aligned type is or contains a class type with a non-static data member to which an extended alignment
has been applied. — end note ]
52) The intent of this list is to specify those circumstances in which an object may or may not be aliased.
§ 3.11 79

 c ISO/IEC N3242=11-0012
4 Alignments are represented as values of the type std::size_t. Valid alignments include only those values
returned by an alignof expression for the fundamental types plus an additional implementation-defined set
of values, which may be empty. Every alignment value shall be a non-negative integral power of two.
5 Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger
alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment
requirement.
6 The alignment requirement of a complete type can be queried using an alignof expression (5.3.6). Furthermore, the types char, signed char, and unsigned char shall have the weakest alignment requirement. [ Note: This enables the character types to be used as the underlying type for an aligned memory
area (7.6.2). — end note ]
7 Comparing alignments is meaningful and provides the obvious results:
— Two alignments are equal when their numeric values are equal.
— Two alignments are different when their numeric values are not equal.
— When an alignment is larger than another it represents a stricter alignment.
8 [ Note: The runtime pointer alignment function (20.6.5) can be used to obtain an aligned pointer within a
buffer; the aligned-storage templates in the library (20.9.7.6) can be used to obtain aligned storage. — end
note ]
9 If a request for a specific extended alignment in a specific context is not supported by an implementation,
the program is ill-formed. Additionally, a request for runtime allocation of dynamic storage for which the
requested alignment cannot be honored shall be treated as an allocation failure.
§ 3.11 80

 c ISO/IEC N3242=11-0012
4 Standard conversions [conv]
1 Standard conversions are implicit conversions defined for built-in types. Clause 4 enumerates the full set
of such conversions. A standard conversion sequence is a sequence of standard conversions in the following
order:
— Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion,
and function-to-pointer conversion.
— Zero or one conversion from the following set: integral promotions, floating point promotion, integral
conversions, floating point conversions, floating-integral conversions, pointer conversions, pointer to
member conversions, and boolean conversions.
— Zero or one qualification conversion.
[ Note: A standard conversion sequence can be empty, i.e., it can consist of no conversions. — end note ]
A standard conversion sequence will be applied to an expression if necessary to convert it to a required
destination type.
2 [ Note: expressions with a given type will be implicitly converted to other types in several contexts:
— When used as operands of operators. The operator’s requirements for its operands dictate the destination type (Clause 5).
— When used in the condition of an if statement or iteration statement (6.4, 6.5). The destination type
is bool.
— When used in the expression of a switch statement. The destination type is integral (6.4).
— When used as the source expression for an initialization (which includes use as an argument in a
function call and use as the expression in a return statement). The type of the entity being initialized
is (generally) the destination type. See 8.5, 8.5.3.
— end note ]
3 An expression e can be implicitly converted to a type T if and only if the declaration T t=e; is well-formed,
for some invented temporary variable t (8.5). Certain language constructs require that an expression be
converted to a Boolean value. An expression e appearing in such a context is said to be contextually
converted to bool and is well-formed if and only if the declaration bool t(e); is well-formed, for some
invented temporary variable t (8.5). The effect of either implicit conversion is the same as performing the
declaration and initialization and then using the temporary variable as the result of the conversion. The
result is an lvalue if T is an lvalue reference type or an rvalue reference to function type (8.3.2), an xvalue
if T is an rvalue reference to object type, and a prvalue otherwise. The expression e is used as a glvalue if
and only if the initialization uses it as a glvalue.
4 [ Note: For user-defined types, user-defined conversions are considered as well; see 12.3. In general, an
implicit conversion sequence (13.3.3.1) consists of a standard conversion sequence followed by a user-defined
conversion followed by another standard conversion sequence. — end note ]
5 [ Note: There are some contexts where certain conversions are suppressed. For example, the lvalue-torvalue conversion is not done on the operand of the unary & operator. Specific exceptions are given in the
descriptions of those operators and contexts. — end note ]
81

 c ISO/IEC N3242=11-0012
4.1 Lvalue-to-rvalue conversion [conv.lval]
1 A glvalue (3.10) of a non-function, non-array type T can be converted to a prvalue.53 If T is an incomplete
type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not
an object of type T and is not an object of a type derived from T, or if the object is uninitialized, a program
that necessitates this conversion has undefined behavior. If T is a non-class type, the type of the prvalue is
the cv-unqualified version of T. Otherwise, the type of the prvalue is T.54
2 When an lvalue-to-rvalue conversion occurs in an unevaluated operand or a subexpression thereof (Clause 5)
the value contained in the referenced object is not accessed. Otherwise, if the glvalue has a class type,
the conversion copy-initializes a temporary of type T from the glvalue and the result of the conversion is a
prvalue for the temporary. Otherwise, if the glvalue has (possibly cv-qualified) type std::nullptr_t, the
prvalue result is a null pointer constant (4.10). Otherwise, the value contained in the object indicated by
the glvalue is the prvalue result.
3 [ Note: See also 3.10. — end note ]
4.2 Array-to-pointer conversion [conv.array]
1 An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be converted to a prvalue
of type “pointer to T”. The result is a pointer to the first element of the array.
4.3 Function-to-pointer conversion [conv.func]
1 An lvalue of function type T can be converted to a prvalue of type “pointer to T.” The result is a pointer to
the function.55
2 [ Note: See 13.4 for additional rules for the case where the function is overloaded. — end note ]
4.4 Qualification conversions [conv.qual]
1 A prvalue of type “pointer to cv1 T” can be converted to a prvalue of type “pointer to cv2 T” if “cv2 T” is
more cv-qualified than “cv1 T”.
2 A prvalue of type “pointer to member of X of type cv1 T” can be converted to a prvalue of type “pointer to
member of X of type cv2 T” if “cv2 T” is more cv-qualified than “cv1 T”.
3 [ Note: Function types (including those used in pointer to member function types) are never cv-qualified (8.3.5).
— end note ]
4 A conversion can add cv-qualifiers at levels other than the first in multi-level pointers, subject to the following
rules:56
Two pointer types T1 and T2 are similar if there exists a type T and integer n > 0 such that:
T1 is cv 1,0 pointer to cv 1,1 pointer to ·· · cv 1,n−1 pointer to cv 1,n T
and
T2 is cv 2,0 pointer to cv 2,1 pointer to ·· · cv 2,n−1 pointer to cv 2,n T
53) For historical reasons, this conversion is called the “lvalue-to-rvalue” conversion, even though that name does not accurately
reflect the taxonomy of expressions described in 3.10.
54) In C++ class prvalues can have cv-qualified types (because they are objects). This differs from ISO C, in which non-lvalues
never have cv-qualified types.
55) This conversion never applies to non-static member functions because an lvalue that refers to a non-static member function
cannot be obtained.
56) These rules ensure that const-safety is preserved by the conversion.
§ 4.4 82

 c ISO/IEC N3242=11-0012
where each cv
i,j is const, volatile, const volatile, or nothing. The n-tuple of cv-qualifiers after the
first in a pointer type, e.g., cv 1,1, cv 1,2, ·· · , cv 1,n in the pointer type T1, is called the cv-qualification
signature of the pointer type. An expression of type T1 can be converted to type T2 if and only if the
following conditions are satisfied:
— the pointer types are similar.
— for every j > 0, if const is in cv 1,j then const is in cv 2,j, and similarly for volatile.
— if the cv 1,j and cv 2,j are different, then const is in every cv 2,k for 0 < k < j.
[ Note: if a program could assign a pointer of type T** to a pointer of type const T** (that is, if line #1
below were allowed), a program could inadvertently modify a const object (as it is done on line #2). For
example,
int main() {
const char c = ’c’;
char* pc;
const char** pcc = &pc; // #1: not allowed
*pcc = &c;
*pc = ’C’; // #2: modifies a const object
}
— end note ]
5 A multi-level pointer to member type, or a multi-level mixed pointer and pointer to member type has the
form:
cv 0P0 to cv 1P1 to ·· · cv n−1Pn−1 to cv n T
where Pi is either a pointer or pointer to member and where T is not a pointer type or pointer to member
type.
6 Two multi-level pointer to member types or two multi-level mixed pointer and pointer to member types T1
and T2 are similar if there exists a type T and integer n > 0 such that:
T1 is cv 1,0P0 to cv 1,1P1 to ·· · cv 1,n−1Pn−1 to cv 1,n T
and
T2 is cv 2,0P0 to cv 2,1P1 to ·· · cv 2,n−1Pn−1 to cv 2,n T
7 For similar multi-level pointer to member types and similar multi-level mixed pointer and pointer to member
types, the rules for adding cv-qualifiers are the same as those used for similar pointer types.
4.5 Integral promotions [conv.prom]
1 A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion
rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all
the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned
int.
2 A prvalue of type char16_t, char32_t, or wchar_t (3.9.1) can be converted to a prvalue of the first of
the following types that can represent all the values of its underlying type: int, unsigned int, long int,
unsigned long int, long long int, or unsigned long long int. If none of the types in that list can
represent all the values of its underlying type, a prvalue of type char16_t, char32_t, or wchar_t can be
converted to a prvalue of its underlying type.
§ 4.5 83

 c ISO/IEC N3242=11-0012
3 A prvalue of an unscoped enumeration type whose underlying type is not fixed (7.2) can be converted to a
prvalue of the first of the following types that can represent all the values of the enumeration (i.e., the values
in the range bmin to bmax as described in 7.2): int, unsigned int, long int, unsigned long int, long
long int, or unsigned long long int. If none of the types in that list can represent all the values of
the enumeration, a prvalue of an unscoped enumeration type can be converted to a prvalue of the extended
integer type with lowest integer conversion rank (4.13) greater than the rank of long long in which all the
values of the enumeration can be represented. If there are two such extended types, the signed one is chosen.
4 A prvalue of an unscoped enumeration type whose underlying type is fixed (7.2) can be converted to a
prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a
prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue
of the promoted underlying type.
5 A prvalue for an integral bit-field (9.6) can be converted to a prvalue of type int if int can represent all
the values of the bit-field; otherwise, it can be converted to unsigned int if unsigned int can represent
all the values of the bit-field. If the bit-field is larger yet, no integral promotion applies to it. If the bit-field
has an enumerated type, it is treated as any other value of that type for promotion purposes.
6 A prvalue of type bool can be converted to a prvalue of type int, with false becoming zero and true
becoming one.
7 These conversions are called integral promotions.
4.6 Floating point promotion [conv.fpprom]
1 A prvalue of type float can be converted to a prvalue of type double. The value is unchanged.
2 This conversion is called floating point promotion.
4.7 Integral conversions [conv.integral]
1 A prvalue of an integer type can be converted to a prvalue of another integer type. A prvalue of an unscoped
enumeration type can be converted to a prvalue of an integer type.
2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source
integer (modulo 2n where n is the number of bits used to represent the unsigned type). [ Note: In a two’s
complement representation, this conversion is conceptual and there is no change in the bit pattern (if there
is no truncation). — end note ]
3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and
bit-field width); otherwise, the value is implementation-defined.
4 If the destination type is bool, see 4.12. If the source type is bool, the value false is converted to zero and
the value true is converted to one.
5 The conversions allowed as integral promotions are excluded from the set of integral conversions.
4.8 Floating point conversions [conv.double]
1 A prvalue of floating point type can be converted to a prvalue of another floating point type. If the
source value can be exactly represented in the destination type, the result of the conversion is that exact
representation. If the source value is between two adjacent destination values, the result of the conversion
is an implementation-defined choice of either of those values. Otherwise, the behavior is undefined.
§ 4.8 84

 c ISO/IEC N3242=11-0012
2 The conversions allowed as floating point promotions are excluded from the set of floating point conversions.
4.9 Floating-integral conversions [conv.fpint]
1 A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be
represented in the destination type. [ Note: If the destination type is bool, see 4.12. — end note ]
2 A prvalue of an integer type or of an unscoped enumeration type can be converted to a prvalue of a floating
point type. The result is exact if possible. If the value being converted is in the range of values that can
be represented but the value cannot be represented exactly, it is an implementation-defined choice of either
the next lower or higher representable value. [ Note: Loss of precision occurs if the integral value cannot
be represented exactly as a value of the floating type. — end note ] If the value being converted is outside
the range of values that can be represented, the behavior is undefined. If the source type is bool, the value
false is converted to zero and the value true is converted to one.
4.10 Pointer conversions [conv.ptr]
1 A null pointer constant is an integral constant expression (5.19) prvalue of integer type that evaluates to zero
or a prvalue of type std::nullptr_t. A null pointer constant can be converted to a pointer type; the result
is the null pointer value of that type and is distinguishable from every other value of pointer to object or
pointer to function type. Such a conversion is called a null pointer conversion. Two null pointer values of the
same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is
a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion (4.4).
A null pointer constant of integral type can be converted to a prvalue of type std::nullptr_t. [ Note: The
resulting prvalue is not a null pointer value. — end note ]
2 A prvalue of type “pointer to cv T,” where T is an object type, can be converted to a prvalue of type “pointer
to cv void”. The result of converting a “pointer to cv T” to a “pointer to cv void” points to the start of
the storage location where the object of type T resides, as if the object is a most derived object (1.8) of type
T (that is, not a base class subobject). The null pointer value is converted to the null pointer value of the
destination type.
3 A prvalue of type “pointer to cv D”, where D is a class type, can be converted to a prvalue of type “pointer
to cv B”, where B is a base class (Clause 10) of D. If B is an inaccessible (Clause 11) or ambiguous (10.2)
base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion is a
pointer to the base class subobject of the derived class object. The null pointer value is converted to the
null pointer value of the destination type.
4.11 Pointer to member conversions [conv.mem]
1 A null pointer constant (4.10) can be converted to a pointer to member type; the result is the null member
pointer value of that type and is distinguishable from any pointer to member not created from a null pointer
constant. Such a conversion is called a null member pointer conversion. Two null member pointer values
of the same type shall compare equal. The conversion of a null pointer constant to a pointer to member of
cv-qualified type is a single conversion, and not the sequence of a pointer to member conversion followed by
a qualification conversion (4.4).
2 A prvalue of type “pointer to member of B of type cv T”, where B is a class type, can be converted to a
prvalue of type “pointer to member of D of type cv T”, where D is a derived class (Clause 10) of B. If B is
an inaccessible (Clause 11), ambiguous (10.2), or virtual (10.1) base class of D, or a base class of a virtual
base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers
to the same member as the pointer to member before the conversion took place, but it refers to the base
class member as if it were a member of the derived class. The result refers to the member in D’s instance of
§ 4.11 85

 c ISO/IEC N3242=11-0012
B. Since the result has type “pointer to member of D of type cv T”, it can be dereferenced with a D object.
The result is the same as if the pointer to member of B were dereferenced with the B subobject of D. The
null member pointer value is converted to the null member pointer value of the destination type.57
4.12 Boolean conversions [conv.bool]
1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a
prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false;
any other value is converted to true. A prvalue of type std::nullptr_t can be converted to a prvalue of
type bool; the resulting value is false.
4.13 Integer conversion rank [conv.rank]
1 Every integer type has an integer conversion rank defined as follows:
— No two signed integer types other than char and signed char (if char is signed) shall have the same
rank, even if they have the same representation.
— The rank of a signed integer type shall be greater than the rank of any signed integer type with a
smaller size.
— The rank of long long int shall be greater than the rank of long int, which shall be greater than
the rank of int, which shall be greater than the rank of short int, which shall be greater than the
rank of signed char.
— The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.
— The rank of any standard integer type shall be greater than the rank of any extended integer type
with the same size.
— The rank of char shall equal the rank of signed char and unsigned char.
— The rank of bool shall be less than the rank of all other standard integer types.
— The ranks of char16_t, char32_t, and wchar_t shall equal the ranks of their underlying types (3.9.1).
— The rank of any extended signed integer type relative to another extended signed integer type with
the same size is implementation-defined, but still subject to the other rules for determining the integer
conversion rank.
— For all integer types T1, T2, and T3, if T1 has greater rank than T2 and T2 has greater rank than T3,
then T1 shall have greater rank than T3.
[ Note: The integer conversion rank is used in the definition of the integral promotions (4.5) and the usual
arithmetic conversions (Clause 5). — end note ]
57) The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears
inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (4.10, Clause 10). This
inversion is necessary to ensure type safety. Note that a pointer to member is not a pointer to object or a pointer to function
and the rules for conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot
be converted to a void*.
§ 4.13 86

 c ISO/IEC N3242=11-0012
5 Expressions [expr]
1 [ Note: Clause 5 defines the syntax, order of evaluation, and meaning of expressions.58 An expression is a
sequence of operators and operands that specifies a computation. An expression can result in a value and
can cause side effects. — end note ]
2 [ Note: Operators can be overloaded, that is, given meaning when applied to expressions of class type (Clause 9)
or enumeration type (7.2). Uses of overloaded operators are transformed into function calls as described
in 13.5. Overloaded operators obey the rules for syntax specified in Clause 5, but the requirements of
operand type, value category, and evaluation order are replaced by the rules for function call. Relations
between operators, such as ++a meaning a+=1, are not guaranteed for overloaded operators (13.5), and are
not guaranteed for operands of type bool. — end note ]
3 Clause 5 defines the effects of operators when applied to types for which they have not been overloaded.
Operator overloading shall not modify the rules for the built-in operators, that is, for operators applied to
types for which they are defined by this Standard. However, these built-in operators participate in overload
resolution, and as part of that process user-defined conversions will be considered where necessary to convert
the operands to types appropriate for the built-in operator. If a built-in operator is selected, such conversions
will be applied to the operands before the operation is considered further according to the rules in Clause 5;
see 13.3.1.2, 13.6.
4 If during the evaluation of an expression, the result is not mathematically defined or not in the range of
representable values for its type, the behavior is undefined. [ Note: most existing implementations of C++
ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all
floating point exceptions vary among machines, and is usually adjustable by a library function. — end note ]
5 If an expression initially has the type “reference to T” (8.3.2, 8.5.3), the type is adjusted to T prior to
any further analysis. The expression designates the object or function denoted by the reference, and the
expression is an lvalue or an xvalue, depending on the expression.
6 [ Note: An expression is an xvalue if it is:
— the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference
to object type,
— a cast to an rvalue reference to object type,
— a class member access expression designating a non-static data member of non-reference type in which
the object expression is an xvalue, or
— a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is
a pointer to data member.
In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue
references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether
named or not. — end note ]
[ Example:
struct A {
int m;
58) The precedence of operators is not directly specified, but it can be derived from the syntax.
87

 c ISO/IEC N3242=11-0012
};
A&& operator+(A, A);
A&& f();
A a;
A&& ar = static_cast<A&&>(a);
The expressions f(), f().m, static_cast<A&&>(a), and a + a are xvalues. The expression ar is an lvalue.
— end example ]
7 An expression designating an object is called an object-expression.
8 In some contexts, unevaluated operands appear (5.2.8, 5.3.3, 5.3.7, 7.1.6.2). An unevaluated operand is not
evaluated. [ Note: In an unevaluated operand, a non-static class member may be named (5.1) and naming
of objects or functions does not, by itself, require that a definition be provided (3.2). — end note ]
9 Whenever a glvalue expression appears as an operand of an operator that expects a prvalue for that operand,
the lvalue-to-rvalue (4.1), array-to-pointer (4.2), or function-to-pointer (4.3) standard conversions are applied
to convert the expression to a prvalue. [ Note: because cv-qualifiers are removed from the type of an
expression of non-class type when the expression is converted to a prvalue, an lvalue expression of type
const int can, for example, be used where a prvalue expression of type int is required. — end note ]
10 Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield
result types in a similar way. The purpose is to yield a common type, which is also the type of the result.
This pattern is called the usual arithmetic conversions, which are defined as follows:
— If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other
operand does not have the same type, the expression is ill-formed.
— If either operand is of type long double, the other shall be converted to long double.
— Otherwise, if either operand is double, the other shall be converted to double.
— Otherwise, if either operand is float, the other shall be converted to float.
— Otherwise, the integral promotions (4.5) shall be performed on both operands.59 Then the following
rules shall be applied to the promoted operands:
— If both operands have the same type, no further conversion is needed.
— Otherwise, if both operands have signed integer types or both have unsigned integer types, the
operand with the type of lesser integer conversion rank shall be converted to the type of the
operand with greater rank.
— Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the
rank of the type of the other operand, the operand with signed integer type shall be converted to
the type of the operand with unsigned integer type.
— Otherwise, if the type of the operand with signed integer type can represent all of the values of
the type of the operand with unsigned integer type, the operand with unsigned integer type shall
be converted to the type of the operand with signed integer type.
— Otherwise, both operands shall be converted to the unsigned integer type corresponding to the
type of the operand with signed integer type.
59) As a consequence, operands of type bool, char16_t, char32_t, wchar_t, or an enumerated type are converted to some
integral type.
88

 c ISO/IEC N3242=11-0012
11 The values of the floating operands and the results of floating expressions may be represented in greater
precision and range than that required by the type; the types are not changed thereby.60
5.1 Primary expressions [expr.prim]
5.1.1 General [expr.prim.general]
primary-expression:
literal
this
( expression )
id-expression
lambda-expression
id-expression:
unqualified-id
qualified-id
unqualified-id:
identifier
operator-function-id
conversion-function-id
literal-operator-id
~ class-name
~ decltype-specifier
template-id
1 A literal is a primary expression. Its type depends on its form (2.14). A string literal is an lvalue; all other
literals are prvalues.
2 The keyword this names a pointer to the object for which a non-static member function (9.3.2) is invoked
or a non-static data member’s initializer (9.2) is evaluated. The keyword this shall be used only inside the
body of a non-static member function (9.3) of the nearest enclosing class or in a brace-or-equal-initializer
for a non-static data member (9.2). The type of the expression is a pointer to the class of the function or
non-static data member, possibly with cv-qualifiers on the class type. The expression is a prvalue.
[ Example:
class Outer {
int a[sizeof(*this)]; // error: not inside a member function
unsigned int sz = sizeof(*this); // OK: in brace-or-equal-initializer
void f() {
int b[sizeof(*this)]; // OK
struct Inner {
int c[sizeof(*this)]; // error: not inside a member function of Inner
};
}
};
— end example ]
3 The operator :: followed by an identifier, a qualified-id, an operator-function-id, or a literal-operator-id is a
primary-expression. Its type is specified by the declaration of the identifier, qualified-id, operator-functionid, or literal-operator-id. The result is the entity denoted by the identifier, qualified-id, operator-function-id,
60) The cast and assignment operators must still perform their specific conversions as described in 5.4, 5.2.9 and 5.17.
§ 5.1.1 89

 c ISO/IEC N3242=11-0012
or literal-operator-id. The result is an lvalue if the entity is a function or variable and a prvalue otherwise.
The identifier, qualified-id, operator-function-id, or literal-operator-id shall have global namespace scope or
be visible in global scope because of a using-directive (7.3.4). [ Note: the use of :: allows an entity declared
in the global namespace to be referred to even if its name has been hidden (3.4.3). — end note ]
4 A parenthesized expression is a primary expression whose type and value are identical to those of the
enclosed expression. The presence of parentheses does not affect whether the expression is an lvalue. The
parenthesized expression can be used in exactly the same contexts as those where the enclosed expression
can be used, and with the same meaning, except as otherwise indicated.
5 An id-expression is a restricted form of a primary-expression. [ Note: an id-expression can appear after .
and -> operators (5.2.5). — end note ]
6 An identifier is an id-expression provided it has been suitably declared (Clause 7). [ Note: for operatorfunction-ids, see 13.5; for conversion-function-ids, see 12.3.2; for literal-operator-ids, see 13.5.8; for templateids, see 14.2. A class-name or decltype-specifier prefixed by ~ denotes a destructor; see 12.4. Within the
definition of a non-static member function, an identifier that names a non-static member is transformed to a
class member access expression (9.3.1). — end note ] The type of the expression is the type of the identifier.
The result is the entity denoted by the identifier. The result is an lvalue if the entity is a function, variable,
or data member and a prvalue otherwise.
qualified-id:
::opt nested-name-specifier templateopt unqualified-id
:: identifier
:: operator-function-id
:: literal-operator-id
:: template-id
nested-name-specifier:
type-name ::
namespace-name ::
decltype-specifier ::
nested-name-specifier identifier ::
nested-name-specifier templateopt simple-template-id ::
A nested-name-specifier that denotes a class, optionally followed by the keyword template (14.2), and then
followed by the name of a member of either that class (9.2) or one of its base classes (Clause 10), is a
qualified-id; 3.4.3.1 describes name lookup for class members that appear in qualified-ids. The result is the
member. The type of the result is the type of the member. The result is an lvalue if the member is a static
member function or a data member and a prvalue otherwise. [ Note: a class member can be referred to using
a qualified-id at any point in its potential scope (3.3.7). — end note ] Where class-name :: class-name is
used, and the two class-names refer to the same class, this notation names the constructor (12.1). Where
class-name ::~ class-name is used, the two class-names shall refer to the same class; this notation names
the destructor (12.4). The form ~ decltype-specifier also denotes the destructor, but it shall not be used as
the unqualified-id in a qualified-id. [ Note: a typedef-name that names a class is a class-name (9.1). — end
note ]
7 A nested-name-specifier that names a namespace (7.3), followed by the name of a member of that namespace
(or the name of a member of a namespace made visible by a using-directive) is a qualified-id; 3.4.3.2 describes
name lookup for namespace members that appear in qualified-ids. The result is the member. The type of
the result is the type of the member. The result is an lvalue if the member is a function or a variable and a
prvalue otherwise.
8 A nested-name-specifier that denotes an enumeration (7.2), followed by the name of an enumerator of that
enumeration, is a qualified-id that refers to the enumerator. The result is the enumerator. The type of the
result is the type of the enumeration. The result is a prvalue.
§ 5.1.1 90

 c ISO/IEC N3242=11-0012
9 In a qualified-id, if the id-expression is a conversion-function-id, its conversion-type-id shall denote the same
type in both the context in which the entire qualified-id occurs and in the context of the class denoted by
the nested-name-specifier.
10 An id-expression that denotes a non-static data member or non-static member function of a class can only
be used:
— as part of a class member access (5.2.5) in which the object-expression refers to the member’s class or
a class derived from that class, or
— to form a pointer to member (5.3.1), or
— in the body of a non-static member function of that class or of a class derived from that class (9.3.1),
or
— in a mem-initializer for a constructor for that class or for a class derived from that class (12.6.2), or
— in a brace-or-equal-initializer for a non-static data member of that class or of a class derived from that
class (12.6.2), or
— if that id-expression denotes a non-static data member and it appears in an unevaluated operand.
[ Example:
struct S {
int m;
};
int i = sizeof(S::m); // OK
int j = sizeof(S::m + 42); // OK
— end example ]
5.1.2 Lambda expressions [expr.prim.lambda]
1 Lambda expressions provide a concise way to create simple function objects. [ Example:
#include <algorithm>
#include <cmath>
void abssort(float *x, unsigned N) {
std::sort(x, x + N,
[](float a, float b) {
return std::abs(a) < std::abs(b);
});
}
— end example ]
lambda-expression:
lambda-introducer lambda-declarator
opt compound-statement
lambda-introducer:
[ lambda-captureopt]
lambda-capture:
capture-default
capture-list
capture-default , capture-list
capture-default:
&=
§ 5.1.2 91

 c ISO/IEC N3242=11-0012
capture-list:
capture ...opt
capture-list , capture ...opt
capture:
identifier
& identifier
this
lambda-declarator:
( parameter-declaration-clause ) mutableopt
exception-specificationopt attribute-specifier-seqopt trailing-return-typeopt
2 The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the
closure object. A lambda-expression shall not appear in an unevaluated operand (Clause 5). [ Note: A
closure object behaves like a function object (20.8). — end note ]
3 The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion class type — called the closure type — whose properties are described below. This class type is not
an aggregate (8.5.1). The closure type is declared in the smallest block scope, class scope, or namespace
scope that contains the corresponding lambda-expression. [ Note: This determines the set of namespaces
and classes associated with the closure type (3.4.2). The parameter types of a lambda-declarator do not
affect these associated namespaces and classes. — end note ] An implementation may define the closure
type differently from what is described below provided this does not alter the observable behavior of the
program other than by changing:
— the size and/or alignment of the closure type,
— whether the closure type is trivially copyable (Clause 9),
— whether the closure type is a standard-layout class (Clause 9), or
— whether the closure type is a POD class (Clause 9).
An implementation shall not add members of rvalue reference type to the closure type.
4 If a lambda-expression does not include a lambda-declarator, it is as if the lambda-declarator were (). If
a lambda-expression does not include a trailing-return-type, it is as if the trailing-return-type denotes the
following type:
— if the compound-statement is of the form
{ attribute-specifier-seqoptreturn expression ; }
the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3);
— otherwise, void.
[ Example:
auto x1 = [](int i){ return i; }; // OK: return type is int
auto x2 = []{ return { 1, 2 }; }; // error: the return type is void (a
// braced-init-list is not an expression)
— end example ]
5 The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters and return type are described by the lambda-expression’s parameter-declaration-clause and trailingreturn-type respectively. This function call operator is declared const (9.3.1) if and only if the lambdaexpression’s parameter-declaration-clause is not followed by mutable. It is neither virtual nor declared
§ 5.1.2 92

 c ISO/IEC N3242=11-0012
volatile. Default arguments (8.3.6) shall not be specified in the parameter-declaration-clause of a lambdadeclarator. Any exception-specification specified on a lambda-expression applies to the corresponding function
call operator. An attribute-specifier-seq in a lambda-declarator appertains to the type of the corresponding
function call operator. [ Note: Names referenced in the lambda-declarator are looked up in the context in
which the lambda-expression appears. — end note ]
6 The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const
conversion function to pointer to function having the same parameter and return types as the closure type’s
function call operator. The value returned by this conversion function shall be the address of a function
that, when invoked, has the same effect as invoking the closure type’s function call operator.
7 The lambda-expression’s compound-statement yields the function-body (8.4) of the function call operator,
but for purposes of name lookup (3.4), determining the type and value of this (9.3.2) and transforming idexpressions referring to non-static class members into class member access expressions using (*this) (9.3.1),
the compound-statement is considered in the context of the lambda-expression. [ Example:
struct S1 {
int x, y;
int operator()(int);
void f() {
[=]()->int {
return operator()(this->x + y); // equivalent to S1::operator()(this->x + (*this).y)
// this has type S1*
};
}
};
— end example ]
8 If a lambda-capture includes a capture-default that is &, the identifiers in the lambda-capture shall not be
preceded by &. If a lambda-capture includes a capture-default that is =, the lambda-capture shall not contain
this and each identifier it contains shall be preceded by &. An identifier or this shall not appear more than
once in a lambda-capture. [ Example:
struct S2 { void f(int i); };
void S2::f(int i) {
[&, i]{ }; // OK
[&, &i]{ }; // error: i preceded by & when & is the default
[=, this]{ }; // error: this when = is the default
[i, i]{ }; // error: i repeated
} —
end example ]
9 A lambda-expression whose smallest enclosing scope is a block scope (3.3.3) is a local lambda expression; any
other lambda-expression shall not have a capture-list in its lambda-introducer. The reaching scope of a local
lambda expression is the set of enclosing scopes up to and including the innermost enclosing function and
its parameters. [ Note: This reaching scope includes any intervening lambda-expressions. — end note ]
10 The identifiers in a capture-list are looked up using the usual rules for unqualified name lookup (3.4.1); each
such lookup shall find a variable with automatic storage duration declared in the reaching scope of the local
lambda expression. An entity (i.e. a variable or this) is said to be explicitly captured if it appears in the
lambda-expression’s capture-list.
11 If a lambda-expression has an associated capture-default and its compound-statement odr-uses (3.2) this
or a variable with automatic storage duration and the odr-used entity is not explicitly captured, then the
§ 5.1.2 93

 c ISO/IEC N3242=11-0012
odr-used entity is said to be implicitly captured; such entities shall be declared within the reaching scope of
the lambda expression. [ Note: The implicit capture of an entity by a nested lambda-expression can cause
its implicit capture by the containing lambda-expression (see below). Implicit odr-uses of this can result in
implicit capture. — end note ]
12 An entity is captured if it is captured explicitly or implicitly. An entity captured by a lambda-expression
is odr-used (3.2) in the scope containing the lambda-expression. If this is captured by a local lambda
expression, its nearest enclosing function shall be a non-static member function. If a lambda-expression
odr-uses (3.2) this or a variable with automatic storage duration from its reaching scope, that entity shall
be captured by the lambda-expression. If a lambda-expression captures an entity and that entity is not
defined or captured in the immediately enclosing lambda expression or function, the program is ill-formed.
[ Example:
void f1(int i) {
int const N = 20;
auto m1 = [=]{
int const M = 30;
auto m2 = [i]{
int x[N][M]; // OK: N and M are not odr-used
x[0][0] = i; // OK: i is explicitly captured by m2
// and implicitly captured by m1
};
};
struct s1 {
int f;
void work(int n) {
int m = n*n;
int j = 40;
auto m3 = [this,m] {
auto m4 = [&,j] { // error: j not captured by m3
int x = n; // error: n implicitly captured by m4
// but not captured by m3
x += m; // OK: m implicitly captured by m4
// and explicitly captured by m3
x += i; // error: i is outside of the reaching scope
x += f; // OK: this captured implicitly by m4
// and explicitly by m3
};
};
}
};
} —
end example ]
13 A lambda-expression appearing in a default argument shall not implicitly or explicitly capture any entity.
[ Example:
void f2() {
int i = 1;
void g1(int = ([i]{ return i; })()); // ill-formed
void g2(int = ([i]{ return 0; })()); // ill-formed
void g3(int = ([=]{ return i; })()); // ill-formed
void g4(int = ([=]{ return 0; })()); // OK
void g5(int = ([]{ return sizeof i; })()); // OK
}
§ 5.1.2 94

 c ISO/IEC N3242=11-0012
— end example ]
14 An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly
captured with a capture that does not include an &. For each entity captured by copy, an unnamed nonstatic data member is declared in the closure type. The declaration order of these members is unspecified.
The type of such a data member is the type of the corresponding captured entity if the entity is not a
reference to an object, or the referenced type otherwise. [ Note: If the captured entity is a reference to a
function, the corresponding data member is also a reference to a function. — end note ]
15 An entity is captured by reference if it is implicitly or explicitly captured but not captured by copy. It is
unspecified whether additional unnamed non-static data members are declared in the closure type for entities
captured by reference.
16 If a lambda-expression m2 captures an entity and that entity is captured by an immediately enclosing lambdaexpression m1, then m2’s capture is transformed as follows:
— if m1 captures the entity by copy, m2 captures the corresponding non-static data member of m1’s closure
type;
— if m1 captures the entity by reference, m2 captures the same entity captured by m1.
[ Example: the nested lambda expressions and invocations below will output 123234.
int a = 1, b = 1, c = 1;
auto m1 = [a, &b, &c]() mutable {
auto m2 = [a, b, &c]() mutable {
std::cout << a << b << c;
a = 4; b = 4; c = 4;
};
a = 3; b = 3; c = 3;
m2();
};
a = 2; b = 2; c = 2;
m1();
std::cout << a << b << c;
— end example ]
17 Every id-expression that is an odr-use (3.2) of an entity captured by copy is transformed into an access to
the corresponding unnamed data member of the closure type. If this is captured, each odr-use of this is
transformed into an access to the corresponding unnamed data member of the closure type, cast (5.4) to the
type of this. [ Note: The cast ensures that the transformed expression is a prvalue. — end note ]
18 Every occurrence of decltype((x)) where x is a possibly parenthesized id-expression that names an entity
of automatic storage duration is treated as if x were transformed into an access to a corresponding data
member of the closure type that would have been declared if x were an odr-use of the denoted entity.
[ Example:
void f3() {
float x, &r = x;
[=] { // x and r are not captured (appearance in a decltype operand is not an odr-use)
decltype(x) y1; // y1 has type float
decltype((x)) y2 = y1; // y2 has type float const& because this lambda
// is not mutable and x is an lvalue
decltype(r) r1 = y1; // r1 has type float& (transformation not considered)
decltype((r)) r2 = y2; // r2 has type float const&
};
}
§ 5.1.2 95

 c ISO/IEC N3242=11-0012
— end example ]
19 The closure type associated with a lambda-expression has a deleted (8.4.3) default constructor and a deleted
copy assignment operator. It has an implicitly-declared copy constructor (12.8) and may have an implicitlydeclared move constructor (12.8). [ Note: The copy/move constructor is implicitly defined in the same way
as any other implicitly declared copy/move constructor would be implicitly defined. — end note ]
20 The closure type associated with a lambda-expression has an implicitly-declared destructor (12.4).
21 When the lambda-expression is evaluated, the entities that are captured by copy are used to direct-initialize
each corresponding non-static data member of the resulting closure object. (For array members, the array
elements are direct-initialized in increasing subscript order.) These initializations are performed in the
(unspecified) order in which the non-static data members are declared. [ Note: This ensures that the
destructions will occur in the reverse order of the constructions. — end note ]
22 [ Note: If an entity is implicitly or explicitly captured by reference, invoking the function call operator of
the corresponding lambda-expression after the lifetime of the entity has ended is likely to result in undefined
behavior. — end note ]
23 A capture followed by an ellipsis is a pack expansion (14.5.3). [ Example:
template<class... Args>
void f(Args... args) {
auto lm = [&, args...] { return g(args...); };
lm();
}
— end example ]
5.2 Postfix expressions [expr.post]
1 Postfix expressions group left-to-right.
postfix-expression:
primary-expression
postfix-expression [ expression ]
postfix-expression [ braced-init-list ]
postfix-expression ( expression-listopt)
simple-type-specifier ( expression-listopt)
typename-specifier ( expression-listopt)
simple-type-specifier braced-init-list
typename-specifier braced-init-list
postfix-expression . templateopt id-expression
postfix-expression -> templateopt id-expression
postfix-expression . pseudo-destructor-name
postfix-expression -> pseudo-destructor-name
postfix-expression ++
postfix-expression --
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
const_cast < type-id > ( expression )
typeid ( expression )
typeid ( type-id )
expression-list:
initializer-list
§ 5.2 96

 c ISO/IEC N3242=11-0012
pseudo-destructor-name:
::opt nested-name-specifieropt type-name :: ~ type-name
::opt nested-name-specifier template simple-template-id :: ~ type-name
::opt nested-name-specifieropt~ type-name
~ decltype-specifier
2 [ Note: The > token following the type-id in a dynamic_cast, static_cast, reinterpret_cast, or const_-
cast may be the product of replacing a >> token by two consecutive > tokens (14.2). — end note ]
5.2.1 Subscripting [expr.sub]
1 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type “pointer to T” and the other shall have unscoped enumeration or integral type.
The result is an lvalue of type “T.” The type “T” shall be a completely-defined object type.61 The expression
E1[E2] is identical (by definition) to *((E1)+(E2)) [ Note: see 5.3 and 5.7 for details of * and + and 8.3.4
for details of arrays. — end note ]
2 A braced-init-list may appear as a subscript for a user-defined operator[]. In that case, the initializer list
is treated as the initializer for the subscript argument of the operator[]. An initializer list shall not be
used with the built-in subscript operator.
[ Example:
struct X {
Z operator[](std::initializer_list<int>);
};
X x;
x[{1,2,3}] = 7; // OK: meaning x.operator[]({1,2,3})
int a[10];
a[{1,2,3}] = 7; // error: built-in subscript operator
— end example ]
5.2.2 Function call [expr.call]
1 There are two kinds of function call: ordinary function call and member function62 (9.3) call. A function
call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of
expressions which constitute the arguments to the function. For an ordinary function call, the postfix
expression shall be either an lvalue that refers to a function (in which case the function-to-pointer standard
conversion (4.3) is suppressed on the postfix expression), or it shall have pointer to function type. Calling
a function through an expression whose function type has a language linkage that is different from the
language linkage of the function type of the called function’s definition is undefined (7.5). For a member
function call, the postfix expression shall be an implicit (9.3.1, 9.4) or explicit class member access (5.2.5)
whose id-expression is a function member name, or a pointer-to-member expression (5.5) selecting a function
member; the call is as a member of the object pointed to or referred to by the object expression (5.2.5, 5.5).
In the case of an implicit class member access, the implied object is the one pointed to by this. [ Note: a
member function call of the form f() is interpreted as (*this).f() (see 9.3.1). — end note ] If a function
or member function name is used, the name can be overloaded (Clause 13), in which case the appropriate
function shall be selected according to the rules in 13.3. If the selected function is non-virtual, or if the
id-expression in the class member access expression is a qualified-id, that function is called. Otherwise, its
final overrider (10.3) in the dynamic type of the object expression is called. [ Note: the dynamic type is
the type of the object pointed or referred to by the current value of the object expression. 12.7 describes
61) This is true even if the subscript operator is used in the following common idiom: &x[0].
62) A static member function (9.4) is an ordinary function.
§ 5.2.2 97

 c ISO/IEC N3242=11-0012
the behavior of virtual function calls when the object-expression refers to an object under construction or
destruction. — end note ]
2 [ Note: If a function or member function name is used, and name lookup (3.4) does not find a declaration of
that name, the program is ill-formed. No function is implicitly declared by such a call. — end note ]
3 If the postfix-expression designates a destructor (12.4), the type of the function call expression is void;
otherwise, the type of the function call expression is the return type of the statically chosen function (i.e.,
ignoring the virtual keyword), even if the type of the function actually called is different. This type shall
be a complete object type, a reference type or the type void.
4 When a function is called, each parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding
argument. [ Note: Such initializations are indeterminately sequenced with respect to each other (1.9) —
end note ] If the function is a non-static member function, the this parameter of the function (9.3.2) shall
be initialized with a pointer to the object of the call, converted as if by an explicit type conversion (5.4).
[ Note: There is no access or ambiguity checking on this conversion; the access checking and disambiguation
are done as part of the (possibly implicit) class member access operator. See 10.2, 11.2, and 5.2.5. —
end note ] When a function is called, the parameters that have object type shall have completely-defined
object type. [ Note: this still allows a parameter to be a pointer or reference to an incomplete class type.
However, it prevents a passed-by-value parameter to have an incomplete class type. — end note ] During
the initialization of a parameter, an implementation may avoid the construction of extra temporaries by
combining the conversions on the associated argument and/or the construction of temporaries with the
initialization of the parameter (see 12.2). The lifetime of a parameter ends when the function in which it
is defined returns. The initialization and destruction of each parameter occurs within the context of the
calling function. [ Example: the access of the constructor, conversion functions or destructor is checked at
the point of call in the calling function. If a constructor or destructor for a function parameter throws an
exception, the search for a handler starts in the scope of the calling function; in particular, if the function
called has a function-try-block (Clause 15) with a handler that could handle the exception, this handler is
not considered. — end example ] The value of a function call is the value returned by the called function
except in a virtual function call if the return type of the final overrider is different from the return type of
the statically chosen function, the value returned from the final overrider is converted to the return type of
the statically chosen function.
5 [ Note: a function can change the values of its non-const parameters, but these changes cannot affect the
values of the arguments except where a parameter is of a reference type (8.3.2); if the reference is to a
const-qualified type, const_cast is required to be used to cast away the constness in order to modify
the argument’s value. Where a parameter is of const reference type a temporary object is introduced if
needed (7.1.6, 2.14, 2.14.5, 8.3.4, 12.2). In addition, it is possible to modify the values of nonconstant objects
through pointer parameters. — end note ]
6 A function can be declared to accept fewer arguments (by declaring default arguments (8.3.6)) or more
arguments (by using the ellipsis, ..., or a function parameter pack (8.3.5)) than the number of parameters
in the function definition (8.4). [ Note: this implies that, except where the ellipsis (...) or a function
parameter pack is used, a parameter is available for each argument. — end note ]
7 When there is no parameter for a given argument, the argument is passed in such a way that the receiving
function can obtain the value of the argument by invoking va_arg (18.10). [ Note: This paragraph does not
apply to arguments passed to a function parameter pack. Function parameter packs are expanded during
template instantiation (14.5.3), thus each such argument has a corresponding parameter when a function
template specialization is actually called. — end note ] The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and
function-to-pointer (4.3) standard conversions are performed on the argument expression. An argument that
has (possibly cv-qualified) type std::nullptr_t is converted to type void* (4.10). After these conversions,
if the argument does not have arithmetic, enumeration, pointer, pointer to member, or class type, the
program is ill-formed. Passing a potentially-evaluated argument of class type (Clause 9) having a non-
§ 5.2.2 98

 c ISO/IEC N3242=11-0012
trivial copy constructor, a non-trivial move contructor, or a non-trivial destructor, with no corresponding
parameter, is conditionally-supported with implementation-defined semantics. If the argument has integral
or enumeration type that is subject to the integral promotions (4.5), or a floating point type that is subject
to the floating point promotion (4.6), the value of the argument is converted to the promoted type before
the call. These promotions are referred to as the default argument promotions.
8 [ Note: The evaluations of the postfix expression and of the argument expressions are all unsequenced
relative to one another. All side effects of argument expression evaluations are sequenced before the function
is entered (see 1.9). — end note ]
9 Recursive calls are permitted, except to the function named main (3.6.1).
10 A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function
type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.
5.2.3 Explicit type conversion (functional notation) [expr.type.conv]
1 A simple-type-specifier (7.1.6.2) or typename-specifier (14.6) followed by a parenthesized expression-list
constructs a value of the specified type given the expression list. If the expression list is a single expression,
the type conversion expression is equivalent (in definedness, and if defined in meaning) to the corresponding
cast expression (5.4). If the type specified is a class type, the class type shall be complete. If the expression
list specifies more than a single value, the type shall be a class with a suitably declared constructor (8.5, 12.1),
and the expression T(x1, x2, ...) is equivalent in effect to the declaration T t(x1, x2, ...); for some
invented temporary variable t, with the result being the value of t as a prvalue.
2 The expression T(), where T is a simple-type-specifier or typename-specifier for a non-array complete object type or the (possibly cv-qualified) void type, creates a prvalue of the specified type,which is valueinitialized (8.5; no initialization is done for the void() case). [ Note: if T is a non-class type that is
cv-qualified, the cv-qualifiers are ignored when determining the type of the resulting prvalue (3.10). — end
note ]
3 Similarly, a simple-type-specifier or typename-specifier followed by a braced-init-list creates a temporary
object of the specified type direct-list-initialized (8.5.4) with the specified braced-init-list, and its value is
that temporary object as a prvalue.
5.2.4 Pseudo destructor call [expr.pseudo]
1 The use of a pseudo-destructor-name after a dot . or arrow -> operator represents the destructor for the
non-class type denoted by type-name or decltype-specifier. The result shall only be used as the operand for
the function call operator (), and the result of such a call has type void. The only effect is the evaluation
of the postfix-expression before the dot or arrow.
2 The left-hand side of the dot operator shall be of scalar type. The left-hand side of the arrow operator shall
be of pointer to scalar type. This scalar type is the object type. The cv-unqualified versions of the object
type and of the type designated by the pseudo-destructor-name shall be the same type. Furthermore, the
two type-names in a pseudo-destructor-name of the form
::opt nested-name-specifieropt type-name :: ~ type-name
shall designate the same scalar type.
5.2.5 Class member access [expr.ref]
1 A postfix expression followed by a dot . or an arrow ->, optionally followed by the keyword template (14.2),
and then followed by an id-expression, is a postfix expression. The postfix expression before the dot or arrow
§ 5.2.5 99

 c ISO/IEC N3242=11-0012
is evaluated;63 the result of that evaluation, together with the id-expression, determines the result of the
entire postfix expression.
2 For the first option (dot) the type of the first expression (the object expression) shall be “class object” (of a
complete type). For the second option (arrow) the type of the first expression (the pointer expression) shall
be “pointer to class object” (of a complete type). In these cases, the id-expression shall name a member
of the class or of one of its base classes. [ Note: because the name of a class is inserted in its class scope
(Clause 9), the name of a class is also considered a nested member of that class. — end note ] [ Note: 3.4.5
describes how names are looked up after the . and -> operators. — end note ]
3 If E1 has the type “pointer to class X,” then the expression E1->E2 is converted to the equivalent form
(*(E1)).E2; the remainder of 5.2.5 will address only the first option (dot)64. Abbreviating object-expression.idexpression as E1.E2, then the type and value category of this expression are determined as follows. In the
remainder of 5.2.5, cq represents either const or the absence of const and vq represents either volatile or
the absence of volatile. cv represents an arbitrary set of cv-qualifiers, as defined in 3.9.3.
4 If E2 is declared to have type “reference to T,” then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise,
one of the following rules applies.
— If E2 is a static data member and the type of E2 is T, then E1.E2 is an lvalue; the expression designates
the named member of the class. The type of E1.E2 is T.
— If E2 is a non-static data member and the type of E1 is “cq1 vq1 X”, and the type of E2 is “cq2 vq2
T”, the expression designates the named member of the object designated by the first expression. If
E1 is an lvalue, then E1.E2 is an lvalue; if E1 is an xvalue, then E1.E2 is an xvalue; otherwise, it is a
prvalue. Let the notation vq12 stand for the “union” of vq1 and vq2; that is, if vq1 or vq2 is volatile,
then vq12 is volatile. Similarly, let the notation cq12 stand for the “union” of cq1 and cq2; that is,
if cq1 or cq2 is const, then cq12 is const. If E2 is declared to be a mutable member, then the type
of E1.E2 is “vq12 T”. If E2 is not declared to be a mutable member, then the type of E1.E2 is “cq12
vq12 T”.
— If E2 is a (possibly overloaded) member function, function overload resolution (13.3) is used to determine whether E1.E2 refers to a static or a non-static member function.
— If it refers to a static member function and the type of E2 is “function of parameter-type-list
returning T”, then E1.E2 is an lvalue; the expression designates the static member function. The
type of E1.E2 is the same type as that of E2, namely “function of parameter-type-list returning
T”.
— Otherwise, if E1.E2 refers to a non-static member function and the type of E2 is “function of
parameter-type-list cv ref-qualifieropt returning T”, then E1.E2 is a prvalue. The expression
designates a non-static member function. The expression can be used only as the left-hand
operand of a member function call (9.3). [ Note: Any redundant set of parentheses surrounding
the expression is ignored (5.1). — end note ] The type of E1.E2 is “function of parameter-type-list
cv returning T”.
— If E2 is a nested type, the expression E1.E2 is ill-formed.
— If E2 is a member enumerator and the type of E2 is T, the expression E1.E2 is a prvalue. The type of
E1.E2 is T.
5 If E2 is a non-static data member or a non-static member function, the program is ill-formed if the class of
which E2 is directly a member is an ambiguous base (10.2) of the naming class (11.2) of E2. [ Note: The
63) If the class member access expression is evaluated, the subexpression evaluation happens even if the result is unnecessary
to determine the value of the entire postfix expression, for example if the id-expression denotes a static member.
64) Note that if E1 has the type “pointer to class X,” then (*(E1)) is an lvalue.
§ 5.2.5 100

 c ISO/IEC N3242=11-0012
program is also ill-formed if the naming class is an ambiguous base of the class type of the object expression;
see 11.2. — end note ]
5.2.6 Increment and decrement [expr.post.incr]
1 The value of a postfix ++ expression is the value of its operand. [ Note: the value obtained is a copy of
the original value — end note ] The operand shall be a modifiable lvalue. The type of the operand shall be
an arithmetic type or a pointer to a complete object type. The value of the operand object is modified by
adding 1 to it, unless the object is of type bool, in which case it is set to true. [ Note: this use is deprecated,
see Annex D. — end note ] The value computation of the ++ expression is sequenced before the modification
of the operand object. With respect to an indeterminately-sequenced function call, the operation of postfix
++ is a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue
conversion and the side effect associated with any single postfix ++ operator. — end note ] The result is a
prvalue. The type of the result is the cv-unqualified version of the type of the operand. See also 5.7 and 5.17.
2 The operand of postfix -- is decremented analogously to the postfix ++ operator, except that the operand
shall not be of type bool. [ Note: For prefix increment and decrement, see 5.3.2. — end note ]
5.2.7 Dynamic cast [expr.dynamic.cast]
1 The result of the expression dynamic_cast<T>(v) is the result of converting the expression v to type T. T
shall be a pointer or reference to a complete class type, or “pointer to cv void.” The dynamic_cast operator
shall not cast away constness (5.2.11).
2 If T is a pointer type, v shall be a prvalue of a pointer to complete class type, and the result is a prvalue
of type T. If T is an lvalue reference type, v shall be an lvalue of a complete class type, and the result is
an lvalue of the type referred to by T. If T is an rvalue reference type, v shall be an expression having a
complete class type, and the result is an xvalue of the type referred to by T.
3 If the type of v is the same as T, or it is the same as T except that the class object type in T is more
cv-qualified than the class object type in v, the result is v (converted if necessary).
4 If the value of v is a null pointer value in the pointer case, the result is the null pointer value of type T.
5 If T is “pointer to cv1 B” and v has type “pointer to cv2 D” such that B is a base class of D, the result is a
pointer to the unique B subobject of the D object pointed to by v. Similarly, if T is “reference to cv1 B” and
v has type cv2 D such that B is a base class of D, the result is the unique B subobject of the D object referred
to by v. 65 The result is an lvalue if T is an lvalue reference, or an xvalue if T is an rvalue reference. In both
the pointer and reference cases, the program is ill-formed if cv2 has greater cv-qualification than cv1 or if B
is an inaccessible or ambiguous base class of D. [ Example:
struct B { };
struct D : B { };
void foo(D* dp) {
B* bp = dynamic_cast<B*>(dp); // equivalent to B* bp = dp;
} —
end example ]
6 Otherwise, v shall be a pointer to or an lvalue of a polymorphic type (10.3).
7 If T is “pointer to cv void,” then the result is a pointer to the most derived object pointed to by v. Otherwise,
a run-time check is applied to see if the object pointed or referred to by v can be converted to the type
pointed or referred to by T.
65) The most derived object (1.8) pointed or referred to by v can contain other B objects as base classes, but these are ignored.
§ 5.2.7 101

 c ISO/IEC N3242=11-0012
8 If C is the class type to which T points or refers, the run-time check logically executes as follows:
— If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class
subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred)
to by v the result points (refers) to that C object.
— Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the
type of the most derived object has a base class, of type C, that is unambiguous and public, the result
points (refers) to the C subobject of the most derived object.
— Otherwise, the run-time check fails.
9 The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast
to reference type throws std::bad_cast (18.7.2).
[ Example:
class A { virtual void f(); };
class B { virtual void g(); };
class D : public virtual A, private B { };
void g() {
D d;
B* bp = (B*)&d; // cast needed to break protection
A* ap = &d; // public derivation, no cast needed
D& dr = dynamic_cast<D&>(*bp); // fails
ap = dynamic_cast<A*>(bp); // fails
bp = dynamic_cast<B*>(ap); // fails
ap = dynamic_cast<A*>(&d); // succeeds
bp = dynamic_cast<B*>(&d); // ill-formed (not a run-time check)
}
class E : public D, public B { };
class F : public E, public D { };
void h() {
F f;
A* ap = &f; // succeeds: finds unique A
D* dp = dynamic_cast<D*>(ap); // fails: yields 0
// f has two D subobjects
E* ep = (E*)ap; // ill-formed: cast from virtual base
E* ep1 = dynamic_cast<E*>(ap); // succeeds
}
— end example ] [ Note: 12.7 describes the behavior of a dynamic_cast applied to an object under construction or destruction. — end note ]
5.2.8 Type identification [expr.typeid]
1 The result of a typeid expression is an lvalue of static type const std::type_info (18.7.1) and dynamic type
const std::type_info or const name where name is an implementation-defined class publicly derived from
std :: type_info which preserves the behavior described in 18.7.1.66 The lifetime of the object referred to by
the lvalue extends to the end of the program. Whether or not the destructor is called for the std::type_info
object at the end of the program is unspecified.
2 When typeid is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers
to a std::type_info object representing the type of the most derived object (1.8) (that is, the dynamic
66) The recommended name for such a class is extended_type_info.
§ 5.2.8 102

 c ISO/IEC N3242=11-0012
type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary * operator to a
pointer67 and the pointer is a null pointer value (4.10), the typeid expression throws the std::bad_typeid
exception (18.7.3).
3 When typeid is applied to an expression other than a glvalue of a polymorphic class type, the result refers
to a std::type_info object representing the static type of the expression. Lvalue-to-rvalue (4.1), array-topointer (4.2), and function-to-pointer (4.3) conversions are not applied to the expression. If the type of the
expression is a class type, the class shall be completely-defined. The expression is an unevaluated operand
(Clause 5).
4 When typeid is applied to a type-id, the result refers to a std::type_info object representing the type of
the type-id. If the type of the type-id is a reference to a possibly cv-qualified type, the result of the typeid
expression refers to a std::type_info object representing the cv-unqualified referenced type. If the type of
the type-id is a class type or a reference to a class type, the class shall be completely-defined.
5 The top-level cv-qualifiers of the glvalue expression or the type-id that is the operand of typeid are always
ignored. [ Example:
class D { /* ... */ };
D d1;
const D d2;
typeid(d1) == typeid(d2); // yields true
typeid(D) == typeid(const D); // yields true
typeid(D) == typeid(d2); // yields true
typeid(D) == typeid(const D&); // yields true
— end example ]
6 If the header <typeinfo> (18.7.1) is not included prior to a use of typeid, the program is ill-formed.
7 [ Note: 12.7 describes the behavior of typeid applied to an object under construction or destruction. — end
note ]
5.2.9 Static cast [expr.static.cast]
1 The result of the expression static_cast<T>(v) is the result of converting the expression v to type T. If T
is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if T is an rvalue
reference to object type, the result is an xvalue; otherwise, the result is a prvalue. The static_cast operator
shall not cast away constness (5.2.11).
2 An lvalue of type “cv1 B,” where B is a class type, can be cast to type “reference to cv2 D,” where D is a class
derived (Clause 10) from B, if a valid standard conversion from “pointer to D” to “pointer to B” exists (4.10),
cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B is neither a virtual base class
of D nor a base class of a virtual base class of D. The result has type “cv2 D.” An xvalue of type “cv1 B” may
be cast to type “rvalue reference to cv2 D” with the same constraints as for an lvalue of type “cv1 B.” If the
object of type “cv1 B” is actually a subobject of an object of type D, the result refers to the enclosing object
of type D. Otherwise, the result of the cast is undefined. [ Example:
struct B { };
struct D : public B { };
D d;
B &br = d;
static_cast<D&>(br); // produces lvalue to the original d object
67) If p is an expression of pointer type, then *p, (*p), *(p), ((*p)), *((p)), and so on all meet this requirement.
§ 5.2.9 103

 c ISO/IEC N3242=11-0012
— end example ]
3 A glvalue of type “cv1 T1” can be cast to type “rvalue reference to cv2 T2” if “cv2 T2” is reference-compatible
with “cv1 T1” (8.5.3). The result refers to the object or the specified base class subobject thereof. If T2 is
an inaccessible (Clause 11) or ambiguous (10.2) base class of T1, a program that necessitates such a cast is
ill-formed.
4 Otherwise, an expression e can be explicitly converted to a type T using a static_cast of the form static_-
cast<T>(e) if the declaration T t(e); is well-formed, for some invented temporary variable t (8.5). The
effect of such an explicit conversion is the same as performing the declaration and initialization and then
using the temporary variable as the result of the conversion. The expression e is used as a glvalue if and
only if the initialization uses it as a glvalue.
5 Otherwise, the static_cast shall perform one of the conversions listed below. No other conversion shall be
performed explicitly using a static_cast.
6 Any expression can be explicitly converted to type cv void. The expression value is discarded. [ Note:
however, if the value is in a temporary object (12.2), the destructor for that object is not executed until
the usual time, and the value of the object is preserved for the purpose of executing the destructor. — end
note ] The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions
are not applied to the expression.
7 The inverse of any standard conversion sequence (Clause 4) not containing an lvalue-to-rvalue (4.1), arrayto-pointer (4.2), function-to-pointer (4.3), null pointer (4.10), null member pointer (4.11), or boolean (4.12)
conversion, can be performed explicitly using static_cast. A program is ill-formed if it uses static_cast
to perform the inverse of an ill-formed standard conversion sequence. [ Example:
struct B { };
struct D : private B { };
void f() {
static_cast<D*>((B*)0); // Error: B is a private base of D.
static_cast<int B::*>((int D::*)0); // Error: B is a private base of D.
}
— end example ]
8 The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions are applied to
the operand. Such a static_cast is subject to the restriction that the explicit conversion does not cast
away constness (5.2.11), and the following additional rules for specific cases:
9 A value of a scoped enumeration type (7.2) can be explicitly converted to an integral type. The value is
unchanged if the original value can be represented by the specified type. Otherwise, the resulting value is
unspecified. A value of a scoped enumeration type can also be explicitly converted to a floating-point type;
the result is the same as that of converting from the original value to the floating-point type.
10 A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is
unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting
enumeration value is unspecified.
11 A prvalue of type “pointer to cv1 B,” where B is a class type, can be converted to a prvalue of type “pointer
to cv2 D,” where D is a class derived (Clause 10) from B, if a valid standard conversion from “pointer to D” to
“pointer to B” exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B
is neither a virtual base class of D nor a base class of a virtual base class of D. The null pointer value (4.10)
is converted to the null pointer value of the destination type. If the prvalue of type “pointer to cv1 B” points
to a B that is actually a subobject of an object of type D, the resulting pointer points to the enclosing object
of type D. Otherwise, the result of the cast is undefined.
§ 5.2.9 104

 c ISO/IEC N3242=11-0012
12 A prvalue of type “pointer to member of D of type cv1 T” can be converted to a prvalue of type “pointer to
member of B” of type cv2 T, where B is a base class (Clause 10) of D, if a valid standard conversion from
“pointer to member of B of type T” to “pointer to member of D of type T” exists (4.11), and cv2 is the same
cv-qualification as, or greater cv-qualification than, cv1.68 The null member pointer value (4.11) is converted
to the null member pointer value of the destination type. If class B contains the original member, or is a base
or derived class of the class containing the original member, the resulting pointer to member points to the
original member. Otherwise, the result of the cast is undefined. [ Note: although class B need not contain
the original member, the dynamic type of the object on which the pointer to member is dereferenced must
contain the original member; see 5.5. — end note ]
13 A prvalue of type “pointer to cv1 void” can be converted to a prvalue of type “pointer to cv2 T,” where
T is an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1. The null
pointer value is converted to the null pointer value of the destination type. A value of type pointer to object
converted to “pointer to cv void” and back, possibly with different cv-qualification, shall have its original
value. [ Example:
T* p1 = new T;
const T* p2 = static_cast<const T*>(static_cast<void*>(p1));
bool b = p1 == p2; // b will have the value true.
— end example ]
5.2.10 Reinterpret cast [expr.reinterpret.cast]
1 The result of the expression reinterpret_cast<T>(v) is the result of converting the expression v to type
T. If T is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if T is an
rvalue reference to object type, the result is an xvalue; otherwise, the result is a prvalue and the lvalue-torvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the
expression v. Conversions that can be performed explicitly using reinterpret_cast are listed below. No
other conversion can be performed explicitly using reinterpret_cast.
2 The reinterpret_cast operator shall not cast away constness (5.2.11). An expression of integral, enumeration, pointer, or pointer-to-member type can be explicitly converted to its own type; such a cast yields the
value of its operand.
3 [ Note: The mapping performed by reinterpret_cast might, or might not, produce a representation different from the original value. — end note ]
4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is
implementation-defined. [ Note: It is intended to be unsurprising to those who know the addressing structure
of the underlying machine. — end note ] A value of type std::nullptr_t can be converted to an integral
type; the conversion has the same meaning and validity as a conversion of (void*)0 to the integral type.
[ Note: A reinterpret_cast cannot be used to convert a value of any type to the type std::nullptr_t.
— end note ]
5 A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted
to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type
will have its original value; mappings between pointers and integers are otherwise implementation-defined.
[ Note: Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer
value. — end note ]
6 A pointer to a function can be explicitly converted to a pointer to a function of a different type. The effect
of calling a function through a pointer to a function type (8.3.5) that is not the same as the type used in
68) Function types (including those used in pointer to member function types) are never cv-qualified; see 8.3.5.
§ 5.2.10 105

 c ISO/IEC N3242=11-0012
the definition of the function is undefined. Except that converting a prvalue of type “pointer to T1” to the
type “pointer to T2” (where T1 and T2 are function types) and back to its original type yields the original
pointer value, the result of such a pointer conversion is unspecified. [ Note: see also 4.10 for more details of
pointer conversions. — end note ]
7 A pointer to an object can be explicitly converted to a pointer to a different object type.69 When a
prvalue v of type “pointer to T1” is converted to the type “pointer to cv T2”, the result is static_cast<cv
T2*>(static_cast<cv void*>(v)) if both T1 and T2 are standard-layout types (3.9) and the alignment
requirements of T2 are no stricter than those of T1. Converting a prvalue of type “pointer to T1” to the
type “pointer to T2” (where T1 and T2 are object types and where the alignment requirements of T2 are no
stricter than those of T1) and back to its original type yields the original pointer value. The result of any
other such pointer conversion is unspecified.
8 Converting a pointer to a function into a pointer to an object type or vice versa is conditionally-supported.
The meaning of such a conversion is implementation-defined, except that if an implementation supports
conversions in both directions, converting a prvalue of one type to the other type and back, possibly with
different cv-qualification, shall yield the original pointer value.
9 The null pointer value (4.10) is converted to the null pointer value of the destination type. [ Note: A null
pointer constant of type std::nullptr_t cannot be converted to a pointer type, and a null pointer constant
of integral type is not necessarily converted to a null pointer value. — end note ]
10 A prvalue of type “pointer to member of X of type T1” can be explicitly converted to a prvalue of a different
type “pointer to member of Y of type T2” if T1 and T2 are both function types or both object types.70 The
null member pointer value (4.11) is converted to the null member pointer value of the destination type. The
result of this conversion is unspecified, except in the following cases:
— converting a prvalue of type “pointer to member function” to a different pointer to member function
type and back to its original type yields the original pointer to member value.
— converting a prvalue of type “pointer to data member of X of type T1” to the type “pointer to data
member of Y of type T2” (where the alignment requirements of T2 are no stricter than those of T1)
and back to its original type yields the original pointer to member value.
11 An lvalue expression of type T1 can be cast to the type “reference to T2” if an expression of type “pointer to
T1” can be explicitly converted to the type “pointer to T2” using a reinterpret_cast. That is, a reference
cast reinterpret_cast<T&>(x) has the same effect as the conversion *reinterpret_cast<T*>(&x) with
the built-in & and * operators (and similarly for reinterpret_cast<T&&>(x)). The result refers to the same
object as the source lvalue, but with a different type. The result is an lvalue for an lvalue reference type or
an rvalue reference to function type and an xvalue for an rvalue reference to object type. No temporary is
created, no copy is made, and constructors (12.1) or conversion functions (12.3) are not called.71
5.2.11 Const cast [expr.const.cast]
1 The result of the expression const_cast<T>(v) is of type T. If T is an lvalue reference to object type, the
result is an lvalue; if T is an rvalue reference to object type, the result is an xvalue; otherwise, the result
is a prvalue and the lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard
conversions are performed on the expression v. Conversions that can be performed explicitly using const_-
cast are listed below. No other conversion shall be performed explicitly using const_cast.
69) The types may have different cv-qualifiers, subject to the overall restriction that a reinterpret_cast cannot cast away
constness.
70) T1 and T2 may have different cv-qualifiers, subject to the overall restriction that a reinterpret_cast cannot cast away
constness.
71) This is sometimes referred to as a type pun.
§ 5.2.11 106

 c ISO/IEC N3242=11-0012
2 [ Note: Subject to the restrictions in this section, an expression may be cast to its own type using a const_-
cast operator. — end note ]
3 For two pointer types T1 and T2 where
T1 is cv 1,0 pointer to cv 1,1 pointer to ·· · cv 1,n−1 pointer to cv 1,n T
and
T2 is cv 2,0 pointer to cv 2,1 pointer to ·· · cv 2,n−1 pointer to cv 2,n T
where T is any object type or the void type and where cv 1,k and cv 2,k may be different cv-qualifications, a
prvalue of type T1 may be explicitly converted to the type T2 using a const_cast. The result of a pointer
const_cast refers to the original object.
4 For two object types T1 and T2, if a pointer to T1 can be explicitly converted to the type “pointer to T2”
using a const_cast, then the following conversions can also be made:
— an lvalue of type T1 can be explicitly converted to an lvalue of type T2 using the cast const_cast<T2&>;
— a glvalue of type T1 can be explicitly converted to an xvalue of type T2 using the cast const_-
cast<T2&&>; and
— if T1 is a class type, a prvalue of type T1 can be explicitly converted to an xvalue of type T2 using the
cast const_cast<T2&&>.
The result of a reference const_cast refers to the original object.
5 For a const_cast involving pointers to data members, multi-level pointers to data members and multi-level
mixed pointers and pointers to data members (4.4), the rules for const_cast are the same as those used for
pointers; the “member” aspect of a pointer to member is ignored when determining where the cv-qualifiers
are added or removed by the const_cast. The result of a pointer to data member const_cast refers to the
same member as the original (uncast) pointer to data member.
6 A null pointer value (4.10) is converted to the null pointer value of the destination type. The null member
pointer value (4.11) is converted to the null member pointer value of the destination type.
7 [ Note: Depending on the type of the object, a write operation through the pointer, lvalue or pointer
to data member resulting from a const_cast that casts away a const-qualifier72 may produce undefined
behavior (7.1.6.1). — end note ]
8 The following rules define the process known as casting away constness. In these rules Tn and Xn represent
types. For two pointer types:
X1 is T1cv 1,1 * ·· · cv 1,N * where T1 is not a pointer type
X2 is T2cv 2,1 * ·· · cv 2,M * where T2 is not a pointer type
K is min(N, M)
casting from X1 to X2 casts away constness if, for a non-pointer type T there does not exist an implicit
conversion (Clause 4) from:
Tcv 1,(N−K+1) * cv 1,(N−K+2) * ·· · cv 1,N *
to
Tcv 2,(M−K+1) * cv 2,(M−K+2) * ·· · cv 2,M *
72) const_cast is not limited to conversions that cast away a const-qualifier.
§ 5.2.11 107

 c ISO/IEC N3242=11-0012
9 Casting from an lvalue of type T1 to an lvalue of type T2 using an lvalue reference cast or casting from an
expression of type T1 to an xvalue of type T2 using an rvalue reference cast casts away constness if a cast
from a prvalue of type “pointer to T1” to the type “pointer to T2” casts away constness.
10 Casting from a prvalue of type “pointer to data member of X of type T1” to the type “pointer to data member
of Y of type T2” casts away constness if a cast from a prvalue of type “pointer to T1” to the type “pointer
to T2” casts away constness.
11 For multi-level pointer to members and multi-level mixed pointers and pointer to members (4.4), the “member” aspect of a pointer to member level is ignored when determining if a const cv-qualifier has been cast
away.
12 [ Note: some conversions which involve only changes in cv-qualification cannot be done using const_cast.
For instance, conversions between pointers to functions are not covered because such conversions lead to
values whose use causes undefined behavior. For the same reasons, conversions between pointers to member
functions, and in particular, the conversion from a pointer to a const member function to a pointer to a
non-const member function, are not covered. — end note ]
5.3 Unary expressions [expr.unary]
1 Expressions with unary operators group right-to-left.
unary-expression:
postfix-expression
++ cast-expression
-- cast-expression
unary-operator cast-expression
sizeof unary-expression
sizeof ( type-id )
sizeof ... ( identifier )
alignof ( type-id )
noexcept-expression
new-expression
delete-expression
unary-operator: one of
* & + - ! ~
5.3.1 Unary operators [expr.unary.op]
1 The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an
object type, or a pointer to a function type and the result is an lvalue referring to the object or function
to which the expression points. If the type of the expression is “pointer to T,” the type of the result is “T.”
[ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained
can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a
prvalue, see 4.1. — end note ]
2 The result of each of the following unary operators is a prvalue.
3 The result of the unary & operator is a pointer to its operand. The operand shall be an lvalue or a qualifiedid. If the operand is a qualified-id naming a non-static member m of some class C with type T, the result has
type “pointer to member of class C of type T” and is a prvalue designating C::m. Otherwise, if the type of
the expression is T, the result has type “pointer to T” and is a prvalue that is the address of the designated
object (1.7) or a pointer to the designated function. [ Note: In particular, the address of an object of type
“cv T” is “pointer to cv T”, with the same cv-qualification. — end note ] [ Example:
§ 5.3.1 108

 c ISO/IEC N3242=11-0012
struct A { int i; };
struct B : A { };
... &B::i ... // has type int A::*
— end example ] [ Note: a pointer to member formed from a mutable non-static data member (7.1.1) does
not reflect the mutable specifier associated with the non-static data member. — end note ]
4 A pointer to member is only formed when an explicit & is used and its operand is a qualified-id not enclosed
in parentheses. [ Note: that is, the expression &(qualified-id), where the qualified-id is enclosed in
parentheses, does not form an expression of type “pointer to member.” Neither does qualified-id, because
there is no implicit conversion from a qualified-id for a non-static member function to the type “pointer to
member function” as there is from an lvalue of function type to the type “pointer to function” (4.3). Nor is
&unqualified-id a pointer to member, even within the scope of the unqualified-id’s class. — end note ]
5 The address of an object of incomplete type can be taken, but if the complete type of that object is a class
type that declares operator&() as a member function, then the behavior is undefined (and no diagnostic is
required). The operand of & shall not be a bit-field.
6 The address of an overloaded function (Clause 13) can be taken only in a context that uniquely determines
which version of the overloaded function is referred to (see 13.4). [ Note: since the context might determine
whether the operand is a static or non-static member function, the context can also affect whether the
expression has type “pointer to function” or “pointer to member function.” — end note ]
7 The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the
result is the value of the argument. Integral promotion is performed on integral or enumeration operands.
The type of the result is the type of the promoted operand.
8 The operand of the unary - operator shall have arithmetic or unscoped enumeration type and the result
is the negation of its operand. Integral promotion is performed on integral or enumeration operands. The
negative of an unsigned quantity is computed by subtracting its value from 2n, where n is the number of
bits in the promoted operand. The type of the result is the type of the promoted operand.
9 The operand of the logical negation operator ! is contextually converted to bool (Clause 4); its value is
true if the converted operand is false and false otherwise. The type of the result is bool.
10 The operand of ˜ shall have integral or unscoped enumeration type; the result is the one’s complement of
its operand. Integral promotions are performed. The type of the result is the type of the promoted operand.
There is an ambiguity in the unary-expression ˜X(), where X is a class-name or decltype-specifier. The
ambiguity is resolved in favor of treating ˜ as a unary complement rather than treating ˜X as referring to a
destructor.
5.3.2 Increment and decrement [expr.pre.incr]
1 The operand of prefix ++ is modified by adding 1, or set to true if it is bool (this use is deprecated). The
operand shall be a modifiable lvalue. The type of the operand shall be an arithmetic type or a pointer to
a completely-defined object type. The result is the updated operand; it is an lvalue, and it is a bit-field if
the operand is a bit-field. If x is not of type bool, the expression ++x is equivalent to x+=1 [ Note: See the
discussions of addition (5.7) and assignment operators (5.17) for information on conversions. — end note ]
2 The operand of prefix -- is modified by subtracting 1. The operand shall not be of type bool. The
requirements on the operand of prefix -- and the properties of its result are otherwise the same as those of
prefix ++. [ Note: For postfix increment and decrement, see 5.2.6. — end note ]
5.3.3 Sizeof [expr.sizeof]
1 The sizeof operator yields the number of bytes in the object representation of its operand. The operand is
§ 5.3.3 109

 c ISO/IEC N3242=11-0012
either an expression, which is an unevaluated operand (Clause 5), or a parenthesized type-id. The sizeof
operator shall not be applied to an expression that has function or incomplete type, to an enumeration
type whose underlying type is not fixed before all its enumerators have been declared, to the parenthesized
name of such types, or to an lvalue that designates a bit-field. sizeof(char), sizeof(signed char) and
sizeof(unsigned char) are 1. The result of sizeof applied to any other fundamental type (3.9.1) is
implementation-defined. [ Note: in particular, sizeof(bool), sizeof(char16_t), sizeof(char32_t), and
sizeof(wchar_t) are implementation-defined.73 — end note ] [ Note: See 1.7 for the definition of byte
and 3.9 for the definition of object representation. — end note ]
2 When applied to a reference or a reference type, the result is the size of the referenced type. When applied
to a class, the result is the number of bytes in an object of that class including any padding required for
placing objects of that type in an array. The size of a most derived class shall be greater than zero (1.8).
The result of applying sizeof to a base class subobject is the size of the base class type.74 When applied
to an array, the result is the total number of bytes in the array. This implies that the size of an array of n
elements is n times the size of an element.
3 The sizeof operator can be applied to a pointer to a function, but shall not be applied directly to a function.
4 The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are not
applied to the operand of sizeof.
5 The identifier in a sizeof... expression shall name a parameter pack. The sizeof... operator yields the
number of arguments provided for the parameter pack identifier. The parameter pack is expanded (14.5.3)
by the sizeof... operator. [ Example:
template<class... Types>
struct count {
static const std::size_t value = sizeof...(Types);
};
— end example ]
6 The result of sizeof and sizeof... is a constant of type std::size_t. [ Note: std::size_t is defined in
the standard header <cstddef> (18.2). — end note ]
5.3.4 New [expr.new]
1 The new-expression attempts to create an object of the type-id (8.1) or new-type-id to which it is applied.
The type of that object is the allocated type. This type shall be a complete object type, but not an
abstract class type or array thereof (1.8, 3.9, 10.4). It is implementation-defined whether over-aligned types
are supported (3.11). [Note: because references are not objects, references cannot be created by newexpressions. — end note ] [ Note: the type-id may be a cv-qualified type, in which case the object created
by the new-expression has a cv-qualified type. — end note ]
new-expression:
::optnew new-placementopt new-type-id new-initializeropt
::optnew new-placementopt( type-id ) new-initializeropt
new-placement:
( expression-list )
new-type-id:
type-specifier-seq new-declaratoropt
73) sizeof(bool) is not required to be 1.
74) The actual size of a base class subobject may be less than the result of applying sizeof to the subobject, due to virtual
base classes and less strict padding requirements on base class subobjects.
§ 5.3.4 110

 c ISO/IEC N3242=11-0012
new-declarator:
ptr-operator new-declaratoropt
noptr-new-declarator
noptr-new-declarator:
[ expression ] attribute-specifier-seqopt
noptr-new-declarator [ constant-expression ] attribute-specifier-seqopt
new-initializer:
( expression-listopt)
braced-init-list
Entities created by a new-expression have dynamic storage duration (3.7.4). [ Note: the lifetime of such an
entity is not necessarily restricted to the scope in which it is created. — end note ] If the entity is a nonarray object, the new-expression returns a pointer to the object created. If it is an array, the new-expression
returns a pointer to the initial element of the array.
2 If the auto type-specifier appears in the type-specifier-seq of a new-type-id or type-id of a new-expression, the
new-expression shall contain a new-initializer of the form
( assignment-expression )
The allocated type is deduced from the new-initializer as follows: Let e be the assignment-expression in the
new-initializer and T be the new-type-id or type-id of the new-expression, then the allocated type is the type
deduced for the variable x in the invented declaration (7.1.6.4):
T x(e);
[ Example:
new auto(1); // allocated type is int
auto x = new auto(’a’); // allocated type is char, x is of type char*
— end example ]
3 The new-type-id in a new-expression is the longest possible sequence of new-declarators. [ Note: this prevents
ambiguities between the declarator operators &, &&, *, and [] and their expression counterparts. — end
note ] [ Example:
new int * i; // syntax error: parsed as (new int*) i, not as (new int)*i
The * is the pointer declarator and not the multiplication operator. — end example ]
4 [ Note: parentheses in a new-type-id of a new-expression can have surprising effects. [ Example:
new int(*[10])(); // error
is ill-formed because the binding is
(new int) (*[10])(); // error
Instead, the explicitly parenthesized version of the new operator can be used to create objects of compound
types (3.9.2):
new (int (*[10])());
allocates an array of 10 pointers to functions (taking no argument and returning int. — end example ]
— end note ]
5 When the allocated object is an array (that is, the noptr-new-declarator syntax is used or the new-type-id or
type-id denotes an array type), the new-expression yields a pointer to the initial element (if any) of the array.
§ 5.3.4 111

 c ISO/IEC N3242=11-0012
[ Note: both new int and new int[10] have type int* and the type of new int[i][10] is int (*)[10]
— end note ] The attribute-specifier-seq in a noptr-new-declarator appertains to the associated array type.
6 Every constant-expression in a noptr-new-declarator shall be an integral constant expression (5.19) and
evaluate to a strictly positive value. The expression in a noptr-new-declarator shall be of integral type,
unscoped enumeration type, or a class type for which a single non-explicit conversion function to integral or
unscoped enumeration type exists (12.3). If the expression is of class type, the expression is converted by
calling that conversion function, and the result of the conversion is used in place of the original expression.
[ Example: given the definition int n = 42, new float[n][5] is well-formed (because n is the expression of
a noptr-new-declarator), but new float[5][n] is ill-formed (because n is not a constant expression). — end
example ]
7 When the value of the expression in a noptr-new-declarator is zero, the allocation function is called to
allocate an array with no elements. If the value of that expression is less than zero or such that the
size of the allocated object would exceed the implementation-defined limit, no storage is obtained and the
new-expression terminates by throwing an exception of a type that would match a handler (15.3) of type
std::bad_array_new_length (18.6.2.2).
8 A new-expression obtains storage for the object by calling an allocation function (3.7.4.1). If the newexpression terminates by throwing an exception, it may release storage by calling a deallocation function (3.7.4.2). If the allocated type is a non-array type, the allocation function’s name is operator new and
the deallocation function’s name is operator delete. If the allocated type is an array type, the allocation
function’s name is operator new[] and the deallocation function’s name is operator delete[]. [ Note: an
implementation shall provide default definitions for the global allocation functions (3.7.4, 18.6.1.1, 18.6.1.2).
A C++ program can provide alternative definitions of these functions (17.6.4.6) and/or class-specific versions (12.5). — end note ]
9 If the new-expression begins with a unary :: operator, the allocation function’s name is looked up in the
global scope. Otherwise, if the allocated type is a class type T or array thereof, the allocation function’s
name is looked up in the scope of T. If this lookup fails to find the name, or if the allocated type is not a
class type, the allocation function’s name is looked up in the global scope.
10 A new-expression passes the amount of space requested to the allocation function as the first argument of
type std::size_t. That argument shall be no less than the size of the object being created; it may be
greater than the size of the object being created only if the object is an array. For arrays of char and
unsigned char, the difference between the result of the new-expression and the address returned by the
allocation function shall be an integral multiple of the strictest fundamental alignment requirement (3.11) of
any object type whose size is no greater than the size of the array being created. [ Note: Because allocation
functions are assumed to return pointers to storage that is appropriately aligned for objects of any type with
fundamental alignment, this constraint on array allocation overhead permits the common idiom of allocating
character arrays into which objects of other types will later be placed. — end note ]
11 The new-placement syntax is used to supply additional arguments to an allocation function. If used, overload
resolution is performed on a function call created by assembling an argument list consisting of the amount of
space requested (the first argument) and the expressions in the new-placement part of the new-expression (the
second and succeeding arguments). The first of these arguments has type std::size_t and the remaining
arguments have the corresponding types of the expressions in the new-placement.
12 [ Example:
— new T results in a call of operator new(sizeof(T)),
— new(2,f) T results in a call of operator new(sizeof(T),2,f),
— new T[5] results in a call of operator new[](sizeof(T)*5+x), and
§ 5.3.4 112

 c ISO/IEC N3242=11-0012
— new(2,f) T[5] results in a call of operator new[](sizeof(T)*5+y,2,f).
Here, x and y are non-negative unspecified values representing array allocation overhead; the result of the
new-expression will be offset by this amount from the value returned by operator new[]. This overhead
may be applied in all array new-expressions, including those referencing the library function operator
new[](std::size_t, void*) and other placement allocation functions. The amount of overhead may vary
from one invocation of new to another. — end example ]
13 [ Note: unless an allocation function is declared with a non-throwing exception-specification (15.4), it indicates failure to allocate storage by throwing a std::bad_alloc exception (Clause 15, 18.6.2.1); it returns a
non-null pointer otherwise. If the allocation function is declared with a non-throwing exception-specification,
it returns null to indicate failure to allocate storage and a non-null pointer otherwise. — end note ] If the
allocation function returns null, initialization shall not be done, the deallocation function shall not be called,
and the value of the new-expression shall be null.
14 [ Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage
in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned
and of the requested size. The address of the created object will not necessarily be the same as that of the
block if the object is an array. — end note ]
15 A new-expression that creates an object of type T initializes that object as follows:
— If the new-initializer is omitted, the object is default-initialized (8.5); if no initialization is performed,
the object has indeterminate value.
— Otherwise, the new-initializer is interpreted according to the initialization rules of 8.5 for directinitialization.
16 The invocation of the allocation function is indeterminately sequenced with respect to the evaluations of
expressions in the new-initializer. Initialization of the allocated object is sequenced before the value computation of the new-expression. It is unspecified whether expressions in the new-initializer are evaluated if
the allocation function returns the null pointer or exits using an exception.
17 If the new-expression creates an object or an array of objects of class type, access and ambiguity control
are done for the allocation function, the deallocation function (12.5), and the constructor (12.1). If the
new expression creates an array of objects of class type, access and ambiguity control are done for the
destructor (12.4).
18 If any part of the object initialization described above75 terminates by throwing an exception and a suitable
deallocation function can be found, the deallocation function is called to free the memory in which the object
was being constructed, after which the exception continues to propagate in the context of the new-expression.
If no unambiguous matching deallocation function can be found, propagating the exception does not cause
the object’s memory to be freed. [ Note: This is appropriate when the called allocation function does not
allocate memory; otherwise, it is likely to result in a memory leak. — end note ]
19 If the new-expression begins with a unary :: operator, the deallocation function’s name is looked up in the
global scope. Otherwise, if the allocated type is a class type T or an array thereof, the deallocation function’s
name is looked up in the scope of T. If this lookup fails to find the name, or if the allocated type is not a
class type or array thereof, the deallocation function’s name is looked up in the global scope.
20 A declaration of a placement deallocation function matches the declaration of a placement allocation function
if it has the same number of parameters and, after parameter transformations (8.3.5), all parameter types
except the first are identical. Any non-placement deallocation function matches a non-placement allocation
function. If the lookup finds a single matching deallocation function, that function will be called; otherwise,
75) This may include evaluating a new-initializer and/or calling a constructor.
§ 5.3.4 113

 c ISO/IEC N3242=11-0012
no deallocation function will be called. If the lookup finds the two-parameter form of a usual deallocation
function (3.7.4.2) and that function, considered as a placement deallocation function, would have been
selected as a match for the allocation function, the program is ill-formed. [ Example:
struct S {
// Placement allocation function:
static void* operator new(std::size_t, std::size_t);
// Usual (non-placement) deallocation function:
static void operator delete(void*, std::size_t);
};
S* p = new (0) S; // ill-formed: non-placement deallocation function matches
// placement allocation function
— end example ]
21 If a new-expression calls a deallocation function, it passes the value returned from the allocation function
call as the first argument of type void*. If a placement deallocation function is called, it is passed the same
additional arguments as were passed to the placement allocation function, that is, the same arguments as
those specified with the new-placement syntax. If the implementation is allowed to make a copy of any
argument as part of the call to the allocation function, it is allowed to make a copy (of the same original
value) as part of the call to the deallocation function or to reuse the copy made as part of the call to the
allocation function. If the copy is elided in one place, it need not be elided in the other.
5.3.5 Delete [expr.delete]
1 The delete-expression operator destroys a most derived object (1.8) or array created by a new-expression.
delete-expression:
::optdelete cast-expression
::optdelete [ ] cast-expression
The first alternative is for non-array objects, and the second is for arrays. Whenever the delete keyword is immediately followed by empty square brackets, it shall be interpreted as the second alternative.76
The operand shall have a pointer to object type, or a class type having a single non-explicit conversion
function (12.3.2) to a pointer to object type. The result has type void.77
2 If the operand has a class type, the operand is converted to a pointer type by calling the above-mentioned
conversion function, and the converted operand is used in place of the original operand for the remainder of
this section. In the first alternative (delete object), the value of the operand of delete may be a null pointer
value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8)
representing a base class of such an object (Clause 10). If not, the behavior is undefined. In the second
alternative (delete array), the value of the operand of delete may be a null pointer value or a pointer
value that resulted from a previous array new-expression.78 If not, the behavior is undefined. [ Note: this
means that the syntax of the delete-expression must match the type of the object allocated by new, not
the syntax of the new-expression. — end note ] [ Note: a pointer to a const type can be the operand of a
delete-expression; it is not necessary to cast away the constness (5.2.11) of the pointer expression before it
is used as the operand of the delete-expression. — end note ]
76) A lambda expression with a lambda-introducer that consists of empty square brackets can follow the delete keyword if
the lambda expression is enclosed in parentheses.
77) This implies that an object cannot be deleted using a pointer of type void* because void is not an object type.
78) For non-zero-length arrays, this is the same as a pointer to the first element of the array created by that new-expression.
Zero-length arrays do not have a first element.
§ 5.3.5 114

 c ISO/IEC N3242=11-0012
3 In the first alternative (delete object), if the static type of the object to be deleted is different from its
dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the
static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete
array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.
4 The cast-expression in a delete-expression shall be evaluated exactly once.
5 If the object being deleted has incomplete class type at the point of deletion and the complete class has a
non-trivial destructor or a deallocation function, the behavior is undefined.
6 If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will
invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an
array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion
of their constructor; see 12.6.2).
7 If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will
call a deallocation function (3.7.4.2). Otherwise, it is unspecified whether the deallocation function will be
called. [ Note: The deallocation function is called regardless of whether the destructor for the object or some
element of the array throws an exception. — end note ]
8 [ Note: An implementation provides default definitions of the global deallocation functions operator delete()
for non-arrays (18.6.1.1) and operator delete[]() for arrays (18.6.1.2). A C++ program can provide alternative definitions of these functions (17.6.4.6), and/or class-specific versions (12.5). — end note ]
9 When the keyword delete in a delete-expression is preceded by the unary :: operator, the global deallocation function is used to deallocate the storage.
10 Access and ambiguity control are done for both the deallocation function and the destructor (12.4, 12.5).
5.3.6 Alignof [expr.alignof]
1 An alignof expression yields the alignment requirement of its operand type. The operand shall be a type-id
representing a complete object type or an array thereof or a reference to a complete object type.
2 The result is an integral constant of type std::size_t.
3 When alignof is applied to a reference type, the result shall be the alignment of the referenced type. When
alignof is applied to an array type, the result shall be the alignment of the element type.
5.3.7 noexcept operator [expr.unary.noexcept]
1 The noexcept operator determines whether the evaluation of its operand, which is an unevaluated operand
(Clause 5), can throw an exception (15.1).
noexcept-expression:
noexcept ( expression )
2 The result of the noexcept operator is a constant of type bool and is an rvalue.
3 The result of the noexcept operator is false if in a potentially-evaluated context the expression would
contain
— a potentially evaluated call79 to a function, member function, function pointer, or member function
pointer that does not have a non-throwing exception-specification (15.4), unless the call is a constant
expression (5.19),
— a potentially evaluated throw-expression (15.1),
79) This includes implicit calls such as the call to an allocation function in a new-expression.
§ 5.3.7 115

 c ISO/IEC N3242=11-0012
— a potentially evaluated dynamic_cast expression dynamic_cast<T>(v), where T is a reference type,
that requires a run-time check (5.2.7), or
— a potentially evaluated typeid expression (5.2.8) applied to a glvalue expression whose type is a
polymorphic class type (10.3).
Otherwise, the result is true.
5.4 Explicit type conversion (cast notation) [expr.cast]
1 The result of the expression (T) cast-expression is of type T. The result is an lvalue if T is an lvalue reference
type or an rvalue reference to function type and an xvalue if T is an rvalue reference to object type; otherwise
the result is a prvalue. [ Note: if T is a non-class type that is cv-qualified, the cv-qualifiers are ignored when
determining the type of the resulting prvalue; see 3.10. — end note ]
2 An explicit type conversion can be expressed using functional notation (5.2.3), a type conversion operator
(dynamic_cast, static_cast, reinterpret_cast, const_cast), or the cast notation.
cast-expression:
unary-expression
( type-id ) cast-expression
3 Any type conversion not mentioned below and not explicitly defined by the user (12.3) is ill-formed.
4 The conversions performed by
— a const_cast (5.2.11),
— a static_cast (5.2.9),
— a static_cast followed by a const_cast,
— a reinterpret_cast (5.2.10), or
— a reinterpret_cast followed by a const_cast,
can be performed using the cast notation of explicit type conversion. The same semantic restrictions and behaviors apply, with the exception that in performing a static_cast in the following situations the conversion
is valid even if the base class is inaccessible:
— a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly
converted to a pointer or reference to an unambiguous base class type, respectively;
— a pointer to member of derived class type may be explicitly converted to a pointer to member of an
unambiguous non-virtual base class type;
— a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous
non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type
may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type,
respectively.
If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears
first in the list is used, even if a cast resulting from that interpretation is ill-formed. If a conversion can be
interpreted in more than one way as a static_cast followed by a const_cast, the conversion is ill-formed.
[ Example:
struct A { };
struct I1 : A { };
struct I2 : A { };
struct D : I1, I2 { };
§ 5.4 116

 c ISO/IEC N3242=11-0012
A *foo( D *p ) {
return (A*)( p ); // ill-formed static_cast interpretation
}
— end example ]
5 The operand of a cast using the cast notation can be a prvalue of type “pointer to incomplete class type”.
The destination type of a cast using the cast notation can be “pointer to incomplete class type”. If both the
operand and destination types are class types and one or both are incomplete, it is unspecified whether the
static_cast or the reinterpret_cast interpretation is used, even if there is an inheritance relationship
between the two classes. [ Note: For example, if the classes were defined later in the translation unit, a
multi-pass compiler would be permitted to interpret a cast between pointers to the classes as if the class
types were complete at the point of the cast. — end note ]
5.5 Pointer-to-member operators [expr.mptr.oper]
1 The pointer-to-member operators ->* and .* group left-to-right.
pm-expression:
cast-expression
pm-expression .* cast-expression
pm-expression ->* cast-expression
2 The binary operator .* binds its second operand, which shall be of type “pointer to member of T” (where
T is a completely-defined class type) to its first operand, which shall be of class T or of a class of which T is
an unambiguous and accessible base class. The result is an object or a function of the type specified by the
second operand.
3 The binary operator ->* binds its second operand, which shall be of type “pointer to member of T” (where
T is a completely-defined class type) to its first operand, which shall be of type “pointer to T” or “pointer to
a class of which T is an unambiguous and accessible base class.” The result is an object or a function of the
type specified by the second operand.
4 The first operand is called the object expression. If the dynamic type of the object expression does not
contain the member to which the pointer refers, the behavior is undefined.
5 The restrictions on cv-qualification, and the manner in which the cv-qualifiers of the operands are combined
to produce the cv-qualifiers of the result, are the same as the rules for E1.E2 given in 5.2.5. [ Note: it is not
possible to use a pointer to member that refers to a mutable member to modify a const class object. For
example,
struct S {
S() : i(0) { }
mutable int i;
};
void f()
{
const S cs;
int S::* pm = &S::i; // pm refers to mutable member S::i
cs.*pm = 88; // ill-formed: cs is a const object
}
— end note ]
6 If the result of .* or ->* is a function, then that result can be used only as the operand for the function call
operator (). [ Example:
§ 5.5 117

 c ISO/IEC N3242=11-0012
(ptr_to_obj->*ptr_to_mfct)(10);
calls the member function denoted by ptr_to_mfct for the object pointed to by ptr_to_obj. — end
example ] In a .* expression whose object expression is an rvalue, the program is ill-formed if the second
operand is a pointer to member function with ref-qualifier &. In a ->* expression or in a .* expression
whose object expression is an lvalue, the program is ill-formed if the second operand is a pointer to member
function with ref-qualifier &&. The result of a .* expression whose second operand is a pointer to a data
member is of the same value category (3.10) as its first operand. The result of a .* expression whose second
operand is a pointer to a member function is a prvalue. The result of an ->* expression is an lvalue if its
second operand is a pointer to data member and a prvalue otherwise. If the second operand is the null
pointer to member value (4.11), the behavior is undefined.
5.6 Multiplicative operators [expr.mul]
1 The multiplicative operators *, /, and % group left-to-right.
multiplicative-expression:
pm-expression
multiplicative-expression * pm-expression
multiplicative-expression / pm-expression
multiplicative-expression % pm-expression
2 The operands of * and / shall have arithmetic or unscoped enumeration type; the operands of % shall have
integral or unscoped enumeration type. The usual arithmetic conversions are performed on the operands
and determine the type of the result.
3 The binary * operator indicates multiplication.
4 The binary / operator yields the quotient, and the binary % operator yields the remainder from the division
of the first expression by the second. If the second operand of / or % is zero the behavior is undefined. For
integral operands the / operator yields the algebraic quotient with any fractional part discarded;80 if the
quotient a/b is representable in the type of the result, (a/b)*b + a%b is equal to a.
5.7 Additive operators [expr.add]
1 The additive operators + and - group left-to-right. The usual arithmetic conversions are performed for
operands of arithmetic or enumeration type.
additive-expression:
multiplicative-expression
additive-expression + multiplicative-expression
additive-expression - multiplicative-expression
For addition, either both operands shall have arithmetic or unscoped enumeration type, or one operand shall
be a pointer to a completely-defined object type and the other shall have integral or unscoped enumeration
type.
2 For subtraction, one of the following shall hold:
— both operands have arithmetic or unscoped enumeration type; or
— both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined
object type; or
— the left operand is a pointer to a completely-defined object type and the right operand has integral or
unscoped enumeration type.
80) This is often called truncation towards zero.
§ 5.7 118

 c ISO/IEC N3242=11-0012
3 The result of the binary + operator is the sum of the operands. The result of the binary - operator is the
difference resulting from the subtraction of the second operand from the first.
4 For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the
first element of an array of length one with the type of the object as its element type.
5 When an expression that has integral type is added to or subtracted from a pointer, the result has the type
of the pointer operand. If the pointer operand points to an element of an array object, and the array is
large enough, the result points to an element offset from the original element such that the difference of
the subscripts of the resulting and original array elements equals the integral expression. In other words, if
the expression P points to the i-th element of an array object, the expressions (P)+N (equivalently, N+(P))
and (P)-N (where N has the value n) point to, respectively, the i + n-th and i − n-th elements of the array
object, provided they exist. Moreover, if the expression P points to the last element of an array object,
the expression (P)+1 points one past the last element of the array object, and if the expression Q points
one past the last element of an array object, the expression (Q)-1 points to the last element of the array
object. If both the pointer operand and the result point to elements of the same array object, or one past
the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is
undefined.
6 When two pointers to elements of the same array object are subtracted, the result is the difference of the
subscripts of the two array elements. The type of the result is an implementation-defined signed integral
type; this type shall be the same type that is defined as std::ptrdiff_t in the <cstddef> header (18.2). As
with any other arithmetic overflow, if the result does not fit in the space provided, the behavior is undefined.
In other words, if the expressions P and Q point to, respectively, the i-th and j-th elements of an array object,
the expression (P)-(Q) has the value i − j provided the value fits in an object of type std::ptrdiff_t.
Moreover, if the expression P points either to an element of an array object or one past the last element of
an array object, and the expression Q points to the last element of the same array object, the expression
((Q)+1)-(P) has the same value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
expression P points one past the last element of the array object, even though the expression (Q)+1 does not
point to an element of the array object. Unless both pointers point to elements of the same array object, or
one past the last element of the array object, the behavior is undefined.81
7 If the value 0 is added to or subtracted from a pointer value, the result compares equal to the original pointer
value. If two pointers point to the same object or both point one past the end of the same array or both
are null, and the two pointers are subtracted, the result compares equal to the value 0 converted to the type
std::ptrdiff_t.
5.8 Shift operators [expr.shift]
1 The shift operators << and >> group left-to-right.
shift-expression:
additive-expression
shift-expression << additive-expression
shift-expression >> additive-expression
The operands shall be of integral or unscoped enumeration type and integral promotions are performed.
The type of the result is that of the promoted left operand. The behavior is undefined if the right operand
is negative, or greater than or equal to the length in bits of the promoted left operand.
81) Another way to approach pointer arithmetic is first to convert the pointer(s) to character pointer(s): In this scheme the
integral value of the expression added to or subtracted from the converted pointer is first multiplied by the size of the object
originally pointed to, and the resulting pointer is converted back to the original type. For pointer subtraction, the result of the
difference between the character pointers is similarly divided by the size of the object originally pointed to.
When viewed in this way, an implementation need only provide one extra byte (which might overlap another object in the
program) just after the end of the object in order to satisfy the “one past the last element” requirements.
§ 5.8 119

 c ISO/IEC N3242=11-0012
2 The value of E1 << E2 is E1 left-shifted E2 bit positions; vacated bits are zero-filled. If E1 has an unsigned
type, the value of the result is E1 × 2E2, reduced modulo one more than the maximum value representable
in the result type. Otherwise, if E1 has a signed type and non-negative value, and E1 × 2E2 is representable
in the result type, then that is the resulting value; otherwise, the behavior is undefined.
3 The value of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type or if E1 has a signed
type and a non-negative value, the value of the result is the integral part of the quotient of E1/2E2. If E1
has a signed type and a negative value, the resulting value is implementation-defined.
5.9 Relational operators [expr.rel]
1 The relational operators group left-to-right. [ Example: a<b<c means (a<b)<c and not (a<b)&&(b<c).
— end example ]
relational-expression:
shift-expression
relational-expression < shift-expression
relational-expression > shift-expression
relational-expression <= shift-expression
relational-expression >= shift-expression
The operands shall have arithmetic, enumeration, or pointer type, or type std::nullptr_t. The operators
< (less than), > (greater than), <= (less than or equal to), and >= (greater than or equal to) all yield false
or true. The type of the result is bool.
2 The usual arithmetic conversions are performed on operands of arithmetic or enumeration type. Pointer
conversions (4.10) and qualification conversions (4.4) are performed on pointer operands (or on a pointer
operand and a null pointer constant, or on two null pointer constants, at least one of which is non-integral)
to bring them to their composite pointer type. If one operand is a null pointer constant, the composite
pointer type is std::nullptr_t if the other operand is also a null pointer constant or, if the other operand
is a pointer, the type of the other operand. Otherwise, if one of the operands has type “pointer to cv1 void,”
then the other has type “pointer to cv2 T ” and the composite pointer type is “pointer to cv12 void,” where
cv12 is the union of cv1 and cv2. Otherwise, the composite pointer type is a pointer type similar (4.4) to the
type of one of the operands, with a cv-qualification signature (4.4) that is the union of the cv-qualification
signatures of the operand types. [ Note: this implies that any pointer can be compared to a null pointer
constant and that any object pointer can be compared to a pointer to (possibly cv-qualified) void. — end
note ] [ Example:
void *p;
const int *q;
int **pi;
const int *const *pci;
void ct() {
p <= q; // Both converted to const void* before comparison
pi <= pci; // Both converted to const int *const * before comparison
}
— end example ] Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a result defined as follows:
— If two pointers p and q of the same type point to the same object or function, or both point one past
the end of the same array, or are both null, then p<=q and p>=q both yield true and p<q and p>q
both yield false.
§ 5.9 120

 c ISO/IEC N3242=11-0012
— If two pointers p and q of the same type point to different objects that are not members of the same
object or elements of the same array or to different functions, or if only one of them is null, the results
of p<q, p>q, p<=q, and p>=q are unspecified.
— If two pointers point to non-static data members of the same object, or to subobjects or array elements
of such members, recursively, the pointer to the later declared member compares greater provided the
two members have the same access control (Clause 11) and provided their class is not a union.
— If two pointers point to non-static data members of the same object with different access control
(Clause 11) the result is unspecified.
— If two pointers point to non-static data members of the same union object, they compare equal (after
conversion to void*, if necessary). If two pointers point to elements of the same array or one beyond
the end of the array, the pointer to the object with the higher subscript compares higher.
— Other pointer comparisons are unspecified.
3 Pointers to void (after pointer conversions) can be compared, with a result defined as follows: If both
pointers represent the same address or are both the null pointer value, the result is true if the operator is
<= or >= and false otherwise; otherwise the result is unspecified.
4 If two operands of type std::nullptr_t are compared, the result is true if the operator is <= or >=, and
false otherwise.
5 If both operands (after conversions) are of arithmetic or enumeration type, each of the operators shall yield
true if the specified relationship is true and false if it is false.
5.10 Equality operators [expr.eq]
equality-expression:
relational-expression
equality-expression == relational-expression
equality-expression != relational-expression
1 The == (equal to) and the != (not equal to) operators have the same semantic restrictions, conversions, and
result type as the relational operators except for their lower precedence and truth-value result. [ Note: a<b
== c<d is true whenever a<b and c<d have the same truth-value. — end note ] Pointers of the same type
(after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if
and only if they are both null, both point to the same function, or both represent the same address (3.9.2).
2 In addition, pointers to members can be compared, or a pointer to member and a null pointer constant.
Pointer to member conversions (4.11) and qualification conversions (4.4) are performed to bring them to a
common type. If one operand is a null pointer constant, the common type is the type of the other operand.
Otherwise, the common type is a pointer to member type similar (4.4) to the type of one of the operands,
with a cv-qualification signature (4.4) that is the union of the cv-qualification signatures of the operand
types. [ Note: this implies that any pointer to member can be compared to a null pointer constant. — end
note ] If both operands are null, they compare equal. Otherwise if only one is null, they compare unequal.
Otherwise if either is a pointer to a virtual member function, the result is unspecified. Otherwise they
compare equal if and only if they would refer to the same member of the same most derived object (1.8)
or the same subobject if they were dereferenced with a hypothetical object of the associated class type.
[ Example:
struct B {
int f();
};
struct L : B { };
§ 5.10 121

 c ISO/IEC N3242=11-0012
struct R : B { };
struct D : L, R { };
int (B::*pb)() = &B::f;
int (L::*pl)() = pb;
int (R::*pr)() = pb;
int (D::*pdl)() = pl;
int (D::*pdr)() = pr;
bool x = (pdl == pdr); // false
— end example ]
3 If two operands of type std::nullptr_t are compared, the result is true if the operator is ==, and false
otherwise.
4 Each of the operators shall yield true if the specified relationship is true and false if it is false.
5.11 Bitwise AND operator [expr.bit.and]
and-expression:
equality-expression
and-expression & equality-expression
1 The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The
operator applies only to integral or unscoped enumeration operands.
5.12 Bitwise exclusive OR operator [expr.xor]
exclusive-or-expression:
and-expression
exclusive-or-expression ˆ and-expression
1 The usual arithmetic conversions are performed; the result is the bitwise exclusive OR function of the
operands. The operator applies only to integral or unscoped enumeration operands.
5.13 Bitwise inclusive OR operator [expr.or]
inclusive-or-expression:
exclusive-or-expression
inclusive-or-expression | exclusive-or-expression
1 The usual arithmetic conversions are performed; the result is the bitwise inclusive OR function of its operands.
The operator applies only to integral or unscoped enumeration operands.
5.14 Logical AND operator [expr.log.and]
logical-and-expression:
inclusive-or-expression
logical-and-expression && inclusive-or-expression
1 The && operator groups left-to-right. The operands are both contextually converted to type bool (Clause 4).
The result is true if both operands are true and false otherwise. Unlike &, && guarantees left-to-right
evaluation: the second operand is not evaluated if the first operand is false.
§ 5.14 122

 c ISO/IEC N3242=11-0012
2 The result is a bool. If the second expression is evaluated, every value computation and side effect associated
with the first expression is sequenced before every value computation and side effect associated with the
second expression.
5.15 Logical OR operator [expr.log.or]
logical-or-expression:
logical-and-expression
logical-or-expression || logical-and-expression
1 The || operator groups left-to-right. The operands are both contextually converted to bool (Clause 4). It
returns true if either of its operands is true, and false otherwise. Unlike |, || guarantees left-to-right
evaluation; moreover, the second operand is not evaluated if the first operand evaluates to true.
2 The result is a bool. If the second expression is evaluated, every value computation and side effect associated
with the first expression is sequenced before every value computation and side effect associated with the
second expression.
5.16 Conditional operator [expr.cond]
conditional-expression:
logical-or-expression
logical-or-expression ? expression : assignment-expression
1 Conditional expressions group right-to-left. The first expression is contextually converted to bool (Clause 4).
It is evaluated and if it is true, the result of the conditional expression is the value of the second expression,
otherwise that of the third expression. Only one of the second and third expressions is evaluated. Every value
computation and side effect associated with the first expression is sequenced before every value computation
and side effect associated with the second or third expression.
2 If either the second or the third operand has type (possibly cv-qualified) void, then the lvalue-to-rvalue (4.1),
array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the second and
third operands, and one of the following shall hold:
— The second or the third operand (but not both) is a throw-expression (15.1); the result is of the type
of the other and is a prvalue.
— Both the second and the third operands have type void; the result is of type void and is a prvalue.
[ Note: This includes the case where both operands are throw-expressions. — end note ]
3 Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class
type, or if both are glvalues of the same value category and the same type except for cv-qualification, an
attempt is made to convert each of those operands to the type of the other. The process for determining
whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type
T2 is defined as follows:
— If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the
type “lvalue reference to T2”, subject to the constraint that in the conversion the reference must bind
directly (8.5.3) to an lvalue.
— If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type
“rvalue reference to T2”, subject to the constraint that the reference must bind directly.
— If E2 is an rvalue or if neither of the conversions above can be done and at least one of the operands
has (possibly cv-qualified) class type:
— if E1 and E2 have class type, and the underlying class types are the same or one is a base class
of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base
§ 5.16 123

 c ISO/IEC N3242=11-0012
class of, the class of T1, and the cv-qualification of T2 is the same cv-qualification as, or a greater
cv-qualification than, the cv-qualification of T1. If the conversion is applied, E1 is changed to a
prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary
as the converted operand.
— Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have class types but the underlying
classes are not either the same or one a base class of the other): E1 can be converted to match E2
if E1 can be implicitly converted to the type that expression E2 would have if E2 were converted
to a prvalue (or the type it has, if E2 is a prvalue).
Using this process, it is determined whether the second operand can be converted to match the third
operand, and whether the third operand can be converted to match the second operand. If both can
be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed.
If neither can be converted, the operands are left unchanged and further checking is performed as
described below. If exactly one conversion is possible, that conversion is applied to the chosen operand
and the converted operand is used in place of the original operand for the remainder of this section.
4 If the second and third operands are glvalues of the same value category and have the same type, the result
is of that type and value category and it is a bit-field if the second or the third operand is a bit-field, or if
both are bit-fields.
5 Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either
has (possibly cv-qualified) class type, overload resolution is used to determine the conversions (if any) to be
applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise,
the conversions thus determined are applied, and the converted operands are used in place of the original
operands for the remainder of this section.
6 Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions are performed on the second and third operands. After those conversions, one of the following shall hold:
— The second and third operands have the same type; the result is of that type. If the operands have
class type, the result is a prvalue temporary of the result type, which is copy-initialized from either
the second operand or the third operand depending on the value of the first operand.
— The second and third operands have arithmetic or enumeration type; the usual arithmetic conversions
are performed to bring them to a common type, and the result is of that type.
— The second and third operands have pointer type, or one has pointer type and the other is a null
pointer constant, or both are null pointer constants, at least one of which is non-integral; pointer
conversions (4.10) and qualification conversions (4.4) are performed to bring them to their composite
pointer type (5.9). The result is of the composite pointer type.
— The second and third operands have pointer to member type, or one has pointer to member type and the
other is a null pointer constant; pointer to member conversions (4.11) and qualification conversions (4.4)
are performed to bring them to a common type, whose cv-qualification shall match the cv-qualification
of either the second or the third operand. The result is of the common type.
5.17 Assignment and compound assignment operators [expr.ass]
1 The assignment operator (=) and the compound assignment operators all group right-to-left. All require a
modifiable lvalue as their left operand and return an lvalue referring to the left operand. The result in all
cases is a bit-field if the left operand is a bit-field. In all cases, the assignment is sequenced after the value
computation of the right and left operands, and before the value computation of the assignment expression.
With respect to an indeterminately-sequenced function call, the operation of a compound assignment is
§ 5.17 124

 c ISO/IEC N3242=11-0012
a single evaluation. [ Note: Therefore, a function call shall not intervene between the lvalue-to-rvalue
conversion and the side effect associated with any single compound assignment operator. — end note ]
assignment-expression:
conditional-expression
logical-or-expression assignment-operator initializer-clause
throw-expression
assignment-operator: one of
= *= /= %= += -= >>= <<= &= ˆ= |=
2 In simple assignment (=), the value of the expression replaces that of the object referred to by the left
operand.
3 If the left operand is not of class type, the expression is implicitly converted (Clause 4) to the cv-unqualified
type of the left operand.
4 If the left operand is of class type, the class shall be complete. Assignment to objects of a class is defined
by the copy/move assignment operator (12.8, 13.5.3).
5 [ Note: For class objects, assignment is not in general the same as initialization (8.5, 12.1, 12.6, 12.8). — end
note ]
6 When the left operand of an assignment operator denotes a reference to T, the operation assigns to the
object of type T denoted by the reference.
7 The behavior of an expression of the form E1 op = E2 is equivalent to E1 = E1 op E2 except that E1 is
evaluated only once. In += and -=, E1 shall either have arithmetic type or be a pointer to a possibly
cv-qualified completely-defined object type. In all other cases, E1 shall have arithmetic type.
8 If the value being stored in an object is accessed from another object that overlaps in any way the storage of
the first object, then the overlap shall be exact and the two objects shall have the same type, otherwise the
behavior is undefined. [ Note: This restriction applies to the relationship between the left and right sides of
the assignment operation; it is not a statement about how the target of the assignment may be aliased in
general. See 3.10. — end note ]
9 A braced-init-list may appear on the right-hand side of
— an assignment to a scalar, in which case the initializer list shall have at most a single element. The
meaning of x={v}, where T is the scalar type of the expression x, is that of x=T(v) except that no
narrowing conversion (8.5.4) is allowed. The meaning of x={} is x=T().
— an assignment defined by a user-defined assignment operator, in which case the initializer list is passed
as the argument to the operator function.
[ Example:
complex<double> z;
z = { 1,2 }; // meaning z.operator=({1,2})
z += { 1, 2 }; // meaning z.operator+=({1,2})
int a, b;
a = b = { 1 }; // meaning a=b=1;
a = { 1 } = b; // syntax error
— end example ]
5.18 Comma operator [expr.comma]
1 The comma operator groups left-to-right.
§ 5.18 125

 c ISO/IEC N3242=11-0012
expression:
assignment-expression
expression , assignment-expression
A pair of expressions separated by a comma is evaluated left-to-right and the value of the left expression
is discarded.82 The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard
conversions are not applied to the left expression. Every value computation and side effect associated with
the left expression is sequenced before every value computation and side effect associated with the right
expression. The type and value of the result are the type and value of the right operand; the result is of the
same value category as its right operand, and is a bit-field if its right operand is a glvalue and a bit-field.
2 In contexts where comma is given a special meaning, [ Example: in lists of arguments to functions (5.2.2)
and lists of initializers (8.5) — end example ] the comma operator as described in Clause 5 can appear only
in parentheses. [ Example:
f(a, (t=3, t+2), c);
has three arguments, the second of which has the value 5. — end example ]
5.19 Constant expressions [expr.const]
1 Certain contexts require expressions that satisfy additional requirements as detailed in this sub-clause; other
contexts have different semantics depending on whether or not an expression satisfies these requirements.
Expressions that satisfy these requirements are called constant expressions. [ Note: Constant expressions
can be evaluated during translation. — end note ]
constant-expression:
conditional-expression
2 A conditional-expression is a constant expression unless it involves one of the following as a potentially
evaluated subexpression (3.2), but subexpressions of logical AND (5.14), logical OR (5.15), and conditional (5.16) operations that are not evaluated are not considered [ Note: An overloaded operator invokes a
function. — end note ]:
— this (5.1) unless it appears as the postfix-expression in a class member access expression, including
the result of the implicit transformation in the body of a non-static member function (9.3.1);
— an invocation of a function other than a constexpr constructor for a literal class or a constexpr
function [ Note: Overload resolution (13.3) is applied as usual — end note ];
— an invocation of an undefined constexpr function or an undefined constexpr constructor outside the
definition of a constexpr function or a constexpr constructor;
— an invocation of a constexpr function with arguments that, when substituted by function invocation
substitution (7.1.5), do not produce a constant expression; [ Example:
constexpr const int* addr(const int& ir) { return &ir; } // OK
static const int x = 5;
constexpr const int* xp = addr(x); // OK: (const int*)&(const int&)x is an
// address contant expression
constexpr const int* tp = addr(5); // error, initializer for constexpr variable not a constant
// expression; (const int*)&(const int&)5 is not a constant
// expression because it takes the address of a temporary
— end example ]
82) However, an invocation of an overloaded comma operator is an ordinary function call; hence, the evaluations of its argument
expressions are unsequenced relative to one another (see 1.9).
§ 5.19 126

 c ISO/IEC N3242=11-0012
— an invocation of a constexpr constructor with arguments that, when substituted by function invocation substitution (7.1.5), do not produce all constant expressions for the constructor calls and
full-expressions in the mem-initializers; [ Example:
int x; // not constant
struct A {
constexpr A(bool b) : m(b?42:x) { }
int m;
};
constexpr int v = A(true).m; // OK: constructor call initializes
// m with the value 42 after substitution
constexpr int w = A(false).m; // error: initializer for m is
// x, which is non-constant
— end example ]
— a result that is not mathematically defined or not in the range of representable values for its type;
— a lambda-expression (5.1.2);
— an lvalue-to-rvalue conversion (4.1) unless it is applied to
— a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding
initialization, initialized with a constant expression, or
— a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers
to a sub-object of such an object, or
— a glvalue of literal type that refers to a non-volatile temporary object initialized with a constant
expression;83
— an array-to-pointer conversion (4.2) that is applied to a glvalue that does not designate an object with
static storage duration;
— a unary operator & (5.3.1) that is applied to an lvalue that does not designate an object with static
storage duration;
— an id-expression that refers to a variable or data member of reference type;84
— a dynamic cast (5.2.7);
— a type conversion from a pointer or pointer-to-member type to a literal type [ Note: A user-defined
conversion invokes a function — end note ];
— a pseudo-destructor call (5.2.4);
— increment or decrement operations (5.2.6, 5.3.2);
— a typeid expression (5.2.8) whose operand is of a polymorphic class type;
— a new-expression (5.3.4);
— a delete-expression (5.3.5);
— a subtraction (5.7) where both operands are pointers;
— a relational (5.9) or equality (5.10) operator where at least one of the operands is a pointer;
83) The temporary must be part of the constant expression, as any longer-lived temporary would have to be bound to a
reference, and reference variables cannot appear in a constant expression.
84) Use of a reference parameter of a constexpr function does not prevent the function from being used in constant expressions,
because function invocation substitution will replace the parameters with the argument expressions.
§ 5.19 127

 c ISO/IEC N3242=11-0012
— an assignment or a compound assignment (5.17); or
— a throw-expression (15.1).
3 A constant expression is an integral constant expression if it is of integral or enumeration type. [ Note: Such
expressions may be used as array bounds (8.3.4, 5.3.4), as case expressions (6.4.2), as bit-field lengths (9.6),
as enumerator initializers (7.2), and as integral or enumeration non-type template arguments (14.3). — end
note ]
4 [ Note: Although in some contexts constant expressions must be evaluated during program translation, others
may be evaluated during program execution. Since this International Standard imposes no restrictions on the
accuracy of floating-point operations, it is unspecified whether the evaluation of a floating-point expression
during translation yields the same result as the evaluation of the same expression (or the same operations
on the same values) during program execution.85 [ Example:
bool f() {
char array[1 + int(1 + 0.2 - 0.1 - 0.1)]; // Must be evaluated during translation
int size = 1 + int(1 + 0.2 - 0.1 - 0.1); // May be evaluated at runtime
return sizeof(array) == size;
}
It is unspecified whether the value of f() will be true or false. — end example ] — end note ]
5 If an expression of literal class type is used in a context where an integral constant expression is required,
then that class type shall have a single non-explicit conversion function to an integral or enumeration type
and that conversion function shall be constexpr. [ Example:
struct A {
constexpr A(int i) : val(i) { }
constexpr operator int() { return val; }
constexpr operator long() { return 43; }
private:
int val;
};
template<int> struct X { };
constexpr A a = 42;
X<a> x; // OK: unique conversion to int
int ary[a]; // error: ambiguous conversion
— end example ]
85) Nonetheless, implementations are encouraged to provide consistent results, irrespective of whether the evaluation was
actually performed during translation or during program execution.
§ 5.19 128

 c ISO/IEC N3242=11-0012
6 Statements [stmt.stmt]
1 Except as indicated, statements are executed in sequence.
statement:
labeled-statement
attribute-specifier-seqopt expression-statement
attribute-specifier-seqopt compound-statement
attribute-specifier-seqopt selection-statement
attribute-specifier-seqopt iteration-statement
attribute-specifier-seqopt jump-statement
declaration-statement
attribute-specifier-seqopt try-block
The optional attribute-specifier-seq appertains to the respective statement.
6.1 Labeled statement [stmt.label]
1 A statement can be labeled.
labeled-statement:
attribute-specifier-seqopt identifier : statement
attribute-specifier-seqoptcase constant-expression : statement
attribute-specifier-seqoptdefault : statement
The optional attribute-specifier-seq appertains to the label. An identifier label declares the identifier. The
only use of an identifier label is as the target of a goto. The scope of a label is the function in which it
appears. Labels shall not be redeclared within a function. A label can be used in a goto statement before
its definition. Labels have their own name space and do not interfere with other identifiers.
2 Case labels and default labels shall occur only in switch statements.
6.2 Expression statement [stmt.expr]
1 Expression statements have the form
expression-statement:
expressionopt;
The expression is evaluated and its value is discarded. The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and
function-to-pointer (4.3) standard conversions are not applied to the expression. All side effects from an
expression statement are completed before the next statement is executed. An expression statement with the
expression missing is called a null statement. [ Note: Most statements are expression statements — usually
assignments or function calls. A null statement is useful to carry a label just before the } of a compound
statement and to supply a null body to an iteration statement such as a while statement (6.5.1). — end
note ]
6.3 Compound statement or block [stmt.block]
1 So that several statements can be used where one is expected, the compound statement (also, and equivalently, called “block”) is provided.
compound-statement:
{ statement-seqopt}
§ 6.3 129

 c ISO/IEC N3242=11-0012
statement-seq:
statement
statement-seq statement
A compound statement defines a block scope (3.3). [ Note: A declaration is a statement (6.7). — end note ]
6.4 Selection statements [stmt.select]
1 Selection statements choose one of several flows of control.
selection-statement:
if ( condition ) statement
if ( condition ) statement else statement
switch ( condition ) statement
condition:
expression
attribute-specifier-seqopt decl-specifier-seq declarator = initializer-clause
attribute-specifier-seqopt decl-specifier-seq declarator braced-init-list
See 8.3 for the optional attribute-specifier-seq in a condition. In Clause 6, the term substatement refers to
the contained statement or statements that appear in the syntax notation. The substatement in a selectionstatement (each substatement, in the else form of the if statement) implicitly defines a block scope (3.3).
If the substatement in a selection-statement is a single statement and not a compound-statement, it is as if
it was rewritten to be a compound-statement containing the original substatement. [ Example:
if (x)
int i;
can be equivalently rewritten as
if (x) {
int i;
}
Thus after the if statement, i is no longer in scope. — end example ]
2 The rules for conditions apply both to selection-statements and to the for and while statements (6.5). The
declarator shall not specify a function or an array. If the auto type-specifier appears in the type-specifier-seq,
the type of the identifier being declared is deduced from the initializer as described in 7.1.6.4.
3 A name introduced by a declaration in a condition (either introduced by the type-specifier-seq or the declarator of the condition) is in scope from its point of declaration until the end of the substatements controlled
by the condition. If the name is re-declared in the outermost block of a substatement controlled by the
condition, the declaration that re-declares the name is ill-formed. [ Example:
if (int x = f()) {
int x; // ill-formed, redeclaration of x
}
else {
int x; // ill-formed, redeclaration of x
}
— end example ]
4 The value of a condition that is an initialized declaration in a statement other than a switch statement is the
value of the declared variable contextually converted to bool (Clause 4). If that conversion is ill-formed, the
program is ill-formed. The value of a condition that is an initialized declaration in a switch statement is the
value of the declared variable if it has integral or enumeration type, or of that variable implicitly converted
§ 6.4 130

 c ISO/IEC N3242=11-0012
to integral or enumeration type otherwise. The value of a condition that is an expression is the value of the
expression, contextually converted to bool for statements other than switch; if that conversion is ill-formed,
the program is ill-formed. The value of the condition will be referred to as simply “the condition” where the
usage is unambiguous.
5 If a condition can be syntactically resolved as either an expression or the declaration of a block-scope name,
it is interpreted as a declaration.
6 In the decl-specifier-seq of a condition, each decl-specifier shall be either a type-specifier or constexpr.
6.4.1 The if statement [stmt.if]
1 If the condition (6.4) yields true the first substatement is executed. If the else part of the selection
statement is present and the condition yields false, the second substatement is executed. In the second
form of if statement (the one including else), if the first substatement is also an if statement then that
inner if statement shall contain an else part.86
6.4.2 The switch statement [stmt.switch]
1 The switch statement causes control to be transferred to one of several statements depending on the value
of a condition.
2 The condition shall be of integral type, enumeration type, or of a class type for which a single non-explicit
conversion function to integral or enumeration type exists (12.3). If the condition is of class type, the
condition is converted by calling that conversion function, and the result of the conversion is used in place of
the original condition for the remainder of this section. Integral promotions are performed. Any statement
within the switch statement can be labeled with one or more case labels as follows:
case constant-expression :
where the constant-expression shall be an integral constant expression (5.19). The integral constant expression is implicitly converted to the promoted type of the switch condition. No two of the case constants in
the same switch shall have the same value after conversion to the promoted type of the switch condition.
3 There shall be at most one label of the form
default :
within a switch statement.
4 Switch statements can be nested; a case or default label is associated with the smallest switch enclosing
it.
5 When the switch statement is executed, its condition is evaluated and compared with each case constant. If
one of the case constants is equal to the value of the condition, control is passed to the statement following
the matched case label. If no case constant matches the condition, and if there is a default label, control
passes to the statement labeled by the default label. If no case matches and if there is no default then
none of the statements in the switch is executed.
6 case and default labels in themselves do not alter the flow of control, which continues unimpeded across
such labels. To exit from a switch, see break, 6.6.1. [ Note: Usually, the substatement that is the subject
of a switch is compound and case and default labels appear on the top-level statements contained within
86) In other words, the else is associated with the nearest un-elsed if.
§ 6.4.2 131

 c ISO/IEC N3242=11-0012
the (compound) substatement, but this is not required. Declarations can appear in the substatement of a
switch-statement. — end note ]
6.5 Iteration statements [stmt.iter]
1 Iteration statements specify looping.
iteration-statement:
while ( condition ) statement
do statement while ( expression ) ;
for ( for-init-statement conditionopt; expressionopt) statement
for ( for-range-declaration : for-range-initializer ) statement
for-init-statement:
expression-statement
simple-declaration
for-range-declaration:
attribute-specifier-seqopt type-specifier-seq declarator
for-range-initializer:
expression
braced-init-list
See 8.3 for the optional attribute-specifier-seq in a for-range-declaration. [ Note: A for-init-statement ends
with a semicolon. — end note ]
2 The substatement in an iteration-statement implicitly defines a block scope (3.3) which is entered and exited
each time through the loop.
If the substatement in an iteration-statement is a single statement and not a compound-statement, it is as if
it was rewritten to be a compound-statement containing the original statement. [ Example:
while (--x >= 0)
int i;
can be equivalently rewritten as
while (--x >= 0) {
int i;
}
3 Thus after the while statement, i is no longer in scope. — end example ]
4 [ Note: The requirements on conditions in iteration statements are described in 6.4. — end note ]
6.5.1 The while statement [stmt.while]
1 In the while statement the substatement is executed repeatedly until the value of the condition (6.4) becomes
false. The test takes place before each execution of the substatement.
2 When the condition of a while statement is a declaration, the scope of the variable that is declared extends
from its point of declaration (3.3.2) to the end of the while statement. A while statement of the form
while (T t = x) statement
is equivalent to
label:
{ // start of condition scope
T t = x;
§ 6.5.1 132

 c ISO/IEC N3242=11-0012
if (t) {
statement
goto label;
}
} // end of condition scope
The variable created in a condition is destroyed and created with each iteration of the loop. [ Example:
struct A {
int val;
A(int i) : val(i) { }
~A() { }
operator bool() { return val != 0; }
};
int i = 1;
while (A a = i) {
// ...
i = 0;
}
In the while-loop, the constructor and destructor are each called twice, once for the condition that succeeds
and once for the condition that fails. — end example ]
6.5.2 The do statement [stmt.do]
1 The expression is contextually converted to bool (Clause 4); if that conversion is ill-formed, the program is
ill-formed.
2 In the do statement the substatement is executed repeatedly until the value of the expression becomes false.
The test takes place after each execution of the statement.
6.5.3 The for statement [stmt.for]
1 The for statement
for ( for-init-statement conditionopt; expressionopt) statement
is equivalent to
{
for-init-statement
while ( condition ) {
statement
expression ;
}
}
except that names declared in the for-init-statement are in the same declarative-region as those declared in
the condition, and except that a continue in statement (not enclosed in another iteration statement) will
execute expression before re-evaluating condition. [ Note: Thus the first statement specifies initialization for
the loop; the condition (6.4) specifies a test, made before each iteration, such that the loop is exited when
the condition becomes false; the expression often specifies incrementing that is done after each iteration.
— end note ]
2 Either or both of the condition and the expression can be omitted. A missing condition makes the implied
while Clause equivalent to while(true).
§ 6.5.3 133

 c ISO/IEC N3242=11-0012
3 If the for-init-statement is a declaration, the scope of the name(s) declared extends to the end of the forstatement. [ Example:
int i = 42;
int a[10];
for (int i = 0; i < 10; i++)
a[i] = i;
int j = i; // j = 42
— end example ]
6.5.4 The range-based for statement [stmt.ranged]
1 For a range-based for statement of the form
for ( for-range-declaration : expression ) statement
let range-init be equivalent to the expression surrounded by parentheses87
( expression )
and for a range-based for statement of the form
for ( for-range-declaration : braced-init-list ) statement
let range-init be equivalent to the braced-init-list. In each case, a range-based for statement is equivalent
to
{
auto && __range = range-init;
for ( auto __begin = begin-expr,
__end = end-expr;
__begin != __end;
++__begin ) {
for-range-declaration = *__begin;
statement
}
}
where __range, __begin, and __end are variables defined for exposition only, and _RangeT is the type of
the expression, and begin-expr and end-expr are determined as follows:
— if _RangeT is an array type, begin-expr and end-expr are __range and __range + __bound, respectively, where __bound is the array bound. If _RangeT is an array of unknown size or an array of
incomplete type, the program is ill-formed.
— otherwise, begin-expr and end-expr are begin(__range) and end(__range), respectively, where begin
and end are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup,
namespace std is an associated namespace.
[ Example:
int array[5] = { 1, 2, 3, 4, 5 };
for (int& x : array)
x *= 2;
87) this ensures that a top-level comma operator cannot be reinterpreted as a delimiter between init-declarators in the declaration of __range.
§ 6.5.4 134

 c ISO/IEC N3242=11-0012
— end example ]
6.6 Jump statements [stmt.jump]
1 Jump statements unconditionally transfer control.
jump-statement:
break ;
continue ;
return expressionopt;
return braced-init-list ;
goto identifier ;
2 On exit from a scope (however accomplished), objects with automatic storage duration (3.7.3) that have been
constructed in that scope are destroyed in the reverse order of their construction. [ Note: For temporaries,
see 12.2. — end note ] Transfer out of a loop, out of a block, or back past an initialized variable with
automatic storage duration involves the destruction of objects with automatic storage duration that are in
scope at the point transferred from but not at the point transferred to. (See 6.7 for transfers into blocks).
[ Note: However, the program can be terminated (by calling std::exit() or std::abort() (18.5), for
example) without destroying class objects with automatic storage duration. — end note ]
6.6.1 The break statement [stmt.break]
1 The break statement shall occur only in an iteration-statement or a switch statement and causes termination
of the smallest enclosing iteration-statement or switch statement; control passes to the statement following
the terminated statement, if any.
6.6.2 The continue statement [stmt.cont]
1 The continue statement shall occur only in an iteration-statement and causes control to pass to the loopcontinuation portion of the smallest enclosing iteration-statement, that is, to the end of the loop. More
precisely, in each of the statements
while (foo) {
{
// ...
}
contin: ;
}
do {
{
// ...
}
contin: ;
} while (foo);
for (;;) {
{
// ...
}
contin: ;
}
a continue not contained in an enclosed iteration statement is equivalent to goto contin.
6.6.3 The return statement [stmt.return]
1 A function returns to its caller by the return statement.
2 A return statement without an expression can be used only in functions that do not return a value, that is,
a function with the return type void, a constructor (12.1), or a destructor (12.4). A return statement with
an expression of non-void type can be used only in functions returning a value; the value of the expression
is returned to the caller of the function. The value of the expression is implicitly converted to the return
type of the function in which it appears. A return statement can involve the construction and copy or move
of a temporary object (12.2). [ Note: A copy or move operation associated with a return statement may
be elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8).
— end note ] A return statement with a braced-init-list initializes the object or reference to be returned from
the function by copy-list-initialization (8.5.4) from the specified initializer list. [ Example:
§ 6.6.3 135

 c ISO/IEC N3242=11-0012
std::pair<std::string,int> f(const char* p, int x) {
return {p,x};
}
— end example ]
Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior
in a value-returning function.
3 A return statement with an expression of type “cv void” can be used only in functions with a return type
of cv void; the expression is evaluated just before the function returns to its caller.
6.6.4 The goto statement [stmt.goto]
1 The goto statement unconditionally transfers control to the statement labeled by the identifier. The identifier
shall be a label (6.1) located in the current function.
6.7 Declaration statement [stmt.dcl]
1 A declaration statement introduces one or more new identifiers into a block; it has the form
declaration-statement:
block-declaration
If an identifier introduced by a declaration was previously declared in an outer block, the outer declaration
is hidden for the remainder of the block, after which it resumes its force.
2 Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is
executed. Variables with automatic storage duration declared in the block are destroyed on exit from the
block (6.6).
3 It is possible to transfer into a block, but not in a way that bypasses declarations with initialization. A
program that jumps88 from a point where a variable with automatic storage duration is not in scope to a
point where it is in scope is ill-formed unless the variable has scalar type, class type with a trivial default
constructor and a trivial destructor, a cv-qualified version of one of these types, or an array of one of the
preceding types and is declared without an initializer (8.5). [ Example:
void f() {
// ...
goto lx; // ill-formed: jump into scope of a
// ...
ly:
X a = 1;
// ...
lx:
goto ly; // OK, jump implies destructor
// call for a followed by construction
// again immediately following label ly
} —
end example ]
4 The zero-initialization (8.5) of all block-scope variables with static storage duration (3.7.1) or thread storage
duration (3.7.2) is performed before any other initialization takes place. Constant initialization (3.6.2) of a
block-scope entity with static storage duration, if applicable, is performed before its block is first entered.
An implementation is permitted to perform early initialization of other block-scope variables with static or
88) The transfer from the condition of a switch statement to a case label is considered a jump in this respect.
§ 6.7 136

 c ISO/IEC N3242=11-0012
thread storage duration under the same conditions that an implementation is permitted to statically initialize
a variable with static or thread storage duration in namespace scope (3.6.2). Otherwise such a variable is
initialized the first time control passes through its declaration; such a variable is considered initialized upon
the completion of its initialization. If the initialization exits by throwing an exception, the initialization
is not complete, so it will be tried again the next time control enters the declaration. If control enters
the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for
completion of the initialization.89 If control re-enters the declaration recursively while the variable is being
initialized, the behavior is undefined. [ Example:
int foo(int i) {
static int s = foo(2*i); // recursive call - undefined
return i+1;
} —
end example ]
5 The destructor for a block-scope object with static or thread storage duration will be executed if and only
if it was constructed. [ Note: 3.6.3 describes the order in which block-scope objects with static and thread
storage duration are destroyed. — end note ]
6.8 Ambiguity resolution [stmt.ambig]
1 There is an ambiguity in the grammar involving expression-statements and declarations: An expressionstatement with a function-style explicit type conversion (5.2.3) as its leftmost subexpression can be indistinguishable from a declaration where the first declarator starts with a (. In those cases the statement is a
declaration. [ Note: To disambiguate, the whole statement might have to be examined to determine if it is
an expression-statement or a declaration. This disambiguates many examples. [ Example: assuming T is a
simple-type-specifier (7.1.6),
T(a)->m = 7; // expression-statement
T(a)++; // expression-statement
T(a,5)<<c; // expression-statement
T(*d)(int); // declaration
T(e)[5]; // declaration
T(f) = { 1, 2 }; // declaration
T(*g)(double(3)); // declaration
In the last example above, g, which is a pointer to T, is initialized to double(3). This is of course ill-formed
for semantic reasons, but that does not affect the syntactic analysis. — end example ]
2 The remaining cases are declarations. [ Example:
class T {
// ...
public:
T();
T(int);
T(int, int);
};
T(a); // declaration
T(*b)(); // declaration
T(c)=7; // declaration
T(d),e,f=3; // declaration
89) The implementation must not introduce any deadlock around execution of the initializer.
§ 6.8 137

 c ISO/IEC N3242=11-0012
extern int h;
T(g)(h,2); // declaration
— end example ] — end note ]
3 The disambiguation is purely syntactic; that is, the meaning of the names occurring in such a statement,
beyond whether they are type-names or not, is not generally used in or changed by the disambiguation. Class
templates are instantiated as necessary to determine if a qualified name is a type-name. Disambiguation
precedes parsing, and a statement disambiguated as a declaration may be an ill-formed declaration. If,
during parsing, a name in a template parameter is bound differently than it would be bound during a trial
parse, the program is ill-formed. No diagnostic is required. [ Note: This can occur only when the name is
declared earlier in the declaration. — end note ] [ Example:
struct T1 {
T1 operator()(int x) { return T1(x); }
int operator=(int x) { return x; }
T1(int) { }
};
struct T2 { T2(int){ } };
int a, (*(*b)(T2))(int), c, d;
void f() {
// disambiguation requires this to be parsed as a declaration:
T1(a) = 3,
T2(4), // T2 will be declared as
(*(*b)(T2(c)))(int(d)); // a variable of type T1
// but this will not allow
// the last part of the
// declaration to parse
// properly since it depends
// on T2 being a type-name
} —
end example ]
§ 6.8 138

 c ISO/IEC N3242=11-0012
7 Declarations [dcl.dcl]
1 Declarations generally specify how names are to be interpreted. Declarations have the form
declaration-seq:
declaration
declaration-seq declaration
declaration:
block-declaration
function-definition
template-declaration
explicit-instantiation
explicit-specialization
linkage-specification
namespace-definition
empty-declaration
attribute-declaration
block-declaration:
simple-declaration
asm-definition
namespace-alias-definition
using-declaration
using-directive
static_assert-declaration
alias-declaration
opaque-enum-declaration
alias-declaration:
using identifier = type-id ;
simple-declaration:
attribute-specifier-seqopt decl-specifier-seqopt init-declarator-listopt;
static_assert-declaration:
static_assert ( constant-expression , string-literal ) ;
empty-declaration:
;
attribute-declaration:
attribute-specifier-seq ;
[ Note: asm-definitions are described in 7.4, and linkage-specifications are described in 7.5. Functiondefinitions are described in 8.4 and template-declarations are described in Clause 14. Namespace-definitions
are described in 7.3.1, using-declarations are described in 7.3.3 and using-directives are described in 7.3.4.
— end note ]
The simple-declaration
attribute-specifier-seqopt decl-specifier-seqopt init-declarator-listopt;
is divided into three parts. Attributes are described in 7.6. decl-specifiers, the principal components of a
decl-specifier-seq, are described in 7.1. declarators, the components of an init-declarator-list, are described
in Clause 8. The optional attribute-specifier-seq in a simple-declaration appertains to each of the entities
declared by the declarators; it shall not appear if the optional init-declarator-list is omitted. [ Note: In the
139

 c ISO/IEC N3242=11-0012
declaration for an entity, attributes appertaining to that entity may appear at the start of the declaration
and after the declarator-id for that declaration. — end note ] [ Example:
[[noreturn, nothrow]] void f [[noreturn]] (); // OK
— end example ]
Except where otherwise specified, the meaning of an attribute-declaration is implementation-defined.
2 A declaration occurs in a scope (3.3); the scope rules are summarized in 3.4. A declaration that declares a
function or defines a class, namespace, template, or function also has one or more scopes nested within it.
These nested scopes, in turn, can have declarations nested within them. Unless otherwise stated, utterances
in Clause 7 about components in, of, or contained by a declaration or subcomponent thereof refer only to
those components of the declaration that are not nested within scopes nested within the declaration.
3 In a simple-declaration, the optional init-declarator-list can be omitted only when declaring a class (Clause 9)
or enumeration (7.2), that is, when the decl-specifier-seq contains either a class-specifier, an elaboratedtype-specifier with a class-key (9.1), or an enum-specifier. In these cases and whenever a class-specifier or
enum-specifier is present in the decl-specifier-seq, the identifiers in these specifiers are among the names being
declared by the declaration (as class-names, enum-names, or enumerators, depending on the syntax). In such
cases, and except for the declaration of an unnamed bit-field (9.6), the decl-specifier-seq shall introduce one
or more names into the program, or shall redeclare a name introduced by a previous declaration. [ Example:
enum { }; // ill-formed
typedef class { }; // ill-formed
— end example ]
4 In a static_assert-declaration the constant-expression shall be a constant expression (5.19) that can be
contextually converted to bool (Clause 4). If the value of the expression when so converted is true, the
declaration has no effect. Otherwise, the program is ill-formed, and the resulting diagnostic message (1.4)
shall include the text of the string-literal, except that characters not in the basic source character set (2.3)
are not required to appear in the diagnostic message. [ Example:
static_assert(sizeof(long) >= 8, "64-bit code generation required for this library.");
— end example ]
5 An empty-declaration has no effect.
6 Each init-declarator in the init-declarator-list contains exactly one declarator-id, which is the name declared
by that init-declarator and hence one of the names declared by the declaration. The type-specifiers (7.1.6)
in the decl-specifier-seq and the recursive declarator structure of the init-declarator describe a type (8.3),
which is then associated with the name being declared by the init-declarator.
7 If the decl-specifier-seq contains the typedef specifier, the declaration is called a typedef declaration and the
name of each init-declarator is declared to be a typedef-name, synonymous with its associated type (7.1.3).
If the decl-specifier-seq contains no typedef specifier, the declaration is called a function declaration if the
type associated with the name is a function type (8.3.5) and an object declaration otherwise.
8 Syntactic components beyond those found in the general form of declaration are added to a function declaration to make a function-definition. An object declaration, however, is also a definition unless it contains
the extern specifier and has no initializer (3.1). A definition causes the appropriate amount of storage to
be reserved and any appropriate initialization (8.5) to be done.
140

 c ISO/IEC N3242=11-0012
9 Only in function declarations for constructors, destructors, and type conversions can the decl-specifier-seq
be omitted.90
7.1 Specifiers [dcl.spec]
1 The specifiers that can be used in a declaration are
decl-specifier:
storage-class-specifier
type-specifier
function-specifier
friend
typedef
constexpr
decl-specifier-seq:
decl-specifier attribute-specifier-seqopt
decl-specifier decl-specifier-seq
The optional attribute-specifier-seq in a decl-specifier-seq appertains to the type determined by the preceding
decl-specifiers (8.3). The attribute-specifier-seq affects the type only for the declaration it appears in, not
other declarations involving the same type.
2 If a type-name is encountered while parsing a decl-specifier-seq, it is interpreted as part of the decl-specifierseq if and only if there is no previous type-specifier other than a cv-qualifier in the decl-specifier-seq. The
sequence shall be self-consistent as described below. [ Example:
typedef char* Pc;
static Pc; // error: name missing
Here, the declaration static Pc is ill-formed because no name was specified for the static variable of type Pc.
To get a variable called Pc, a type-specifier (other than const or volatile) has to be present to indicate that
the typedef-name Pc is the name being (re)declared, rather than being part of the decl-specifier sequence.
For another example,
void f(const Pc); // void f(char* const) (not const char*)
void g(const int Pc); // void g(const int)
— end example ]
3 [ Note: Since signed, unsigned, long, and short by default imply int, a type-name appearing after one of
those specifiers is treated as the name being (re)declared. [ Example:
void h(unsigned Pc); // void h(unsigned int)
void k(unsigned int Pc); // void k(unsigned int)
— end example ] — end note ]
7.1.1 Storage class specifiers [dcl.stc]
1 The storage class specifiers are
storage-class-specifier:
register
static
thread_local
extern
mutable
90) The “implicit int” rule of C is no longer supported.
§ 7.1.1 141

 c ISO/IEC N3242=11-0012
At most one storage-class-specifier shall appear in a given decl-specifier-seq, except that thread_local may
appear with static or extern. If thread_local appears in any declaration of a variable it shall be present
in all declarations of that entity. If a storage-class-specifier appears in a decl-specifier-seq, there can be
no typedef specifier in the same decl-specifier-seq and the init-declarator-list of the declaration shall not
be empty (except for an anonymous union declared in a named namespace or in the global namespace,
which shall be declared static (9.5)). The storage-class-specifier applies to the name declared by each
init-declarator in the list and not to any names declared by other specifiers. A storage-class-specifier shall
not be specified in an explicit specialization (14.7.3) or an explicit instantiation (14.7.2) directive.
2 The register specifier shall be applied only to names of variables declared in a block (6.3) or to function
parameters (8.4). It specifies that the named variable has automatic storage duration (3.7.3). A variable
declared without a storage-class-specifier at block scope or declared as a function parameter has automatic
storage duration by default.
3 A register specifier is a hint to the implementation that the variable so declared will be heavily used.
[ Note: The hint can be ignored and in most implementations it will be ignored if the address of the variable
is taken. This use is deprecated (see D.2). — end note ]
4 The thread_local specifier indicates that the named entity has thread storage duration (3.7.2). It shall be
applied only to the names of variables of namespace or block scope and to the names of static data members.
When thread_local is applied to a variable of block scope the storage-class-specifier static is implied if
it does not appear explicitly.
5 The static specifier can be applied only to names of variables and functions and to anonymous unions (9.5).
There can be no static function declarations within a block, nor any static function parameters. A static
specifier used in the declaration of a variable declares the variable to have static storage duration (3.7.1),
unless accompanied by the thread_local specifier, which declares the variable to have thread storage
duration (3.7.2). A static specifier can be used in declarations of class members; 9.4 describes its effect.
For the linkage of a name declared with a static specifier, see 3.5.
6 The extern specifier can be applied only to the names of variables and functions. The extern specifier cannot
be used in the declaration of class members or function parameters. For the linkage of a name declared with
an extern specifier, see 3.5. [ Note: The extern keyword can also be used in explicit-instantiations and
linkage-specifications, but it is not a storage-class-specifier in such contexts. — end note ]
7 A name declared in a namespace scope without a storage-class-specifier has external linkage unless it has
internal linkage because of a previous declaration and provided it is not declared const. Objects declared
const and not explicitly declared extern have internal linkage.
8 The linkages implied by successive declarations for a given entity shall agree. That is, within a given scope,
each declaration declaring the same variable name or the same overloading of a function name shall imply
the same linkage. Each function in a given set of overloaded functions can have a different linkage, however.
[ Example:
static char* f(); // f() has internal linkage
char* f() // f() still has internal linkage
{ /∗ ... ∗/ }
char* g(); // g() has external linkage
static char* g() // error: inconsistent linkage
{ /∗ ... ∗/ }
void h();
inline void h(); // external linkage
inline void l();
§ 7.1.1 142

 c ISO/IEC N3242=11-0012
void l(); // external linkage
inline void m();
extern void m(); // external linkage
static void n();
inline void n(); // internal linkage
static int a; // a has internal linkage
int a; // error: two definitions
static int b; // b has internal linkage
extern int b; // b still has internal linkage
int c; // c has external linkage
static int c; // error: inconsistent linkage
extern int d; // d has external linkage
static int d; // error: inconsistent linkage
— end example ]
9 The name of a declared but undefined class can be used in an extern declaration. Such a declaration can
only be used in ways that do not require a complete class type. [ Example:
struct S;
extern S a;
extern S f();
extern void g(S);
void h() {
g(a); // error: S is incomplete
f(); // error: S is incomplete
}
— end example ]
10 The mutable specifier can be applied only to names of class data members (9.2) and cannot be applied to
names declared const or static, and cannot be applied to reference members. [ Example:
class X {
mutable const int* p; // OK
mutable int* const q; // ill-formed
};
— end example ]
11 The mutable specifier on a class data member nullifies a const specifier applied to the containing class object
and permits modification of the mutable class member even though the rest of the object is const (7.1.6.1).
7.1.2 Function specifiers [dcl.fct.spec]
1 Function-specifiers can be used only in function declarations.
function-specifier:
inline
virtual
explicit
§ 7.1.2 143

 c ISO/IEC N3242=11-0012
2 A function declaration (8.3.5, 9.3, 11.3) with an inline specifier declares an inline function. The inline
specifier indicates to the implementation that inline substitution of the function body at the point of call
is to be preferred to the usual function call mechanism. An implementation is not required to perform this
inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules
for inline functions defined by 7.1.2 shall still be respected.
3 A function defined within a class definition is an inline function. The inline specifier shall not appear on
a block scope function declaration.91 If the inline specifier is used in a friend declaration, that declaration
shall be a definition or the function shall have previously been declared inline.
4 An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly
the same definition in every case (3.2). [ Note: A call to the inline function may be encountered before its
definition appears in the translation unit. — end note ] If the definition of a function appears in a translation
unit before its first declaration as inline, the program is ill-formed. If a function with external linkage is
declared inline in one translation unit, it shall be declared inline in all translation units in which it appears;
no diagnostic is required. An inline function with external linkage shall have the same address in all
translation units. A static local variable in an extern inline function always refers to the same object.
A string literal in the body of an extern inline function is the same object in different translation units.
[ Note: A string literal appearing in a default argument is not in the body of an inline function merely
because the expression is used in a function call from that inline function. — end note ] A type defined
within the body of an extern inline function is the same type in every translation unit.
5 The virtual specifier shall be used only in the initial declaration of a non-static class member function;
see 10.3.
6 The explicit specifier shall be used only in the declaration of a constructor or conversion function within
its class definition; see 12.3.1 and 12.3.2.
7.1.3 The typedef specifier [dcl.typedef]
1 Declarations containing the decl-specifier typedef declare identifiers that can be used later for naming
fundamental (3.9.1) or compound (3.9.2) types. The typedef specifier shall not be combined in a declspecifier-seq with any other kind of specifier except a type-specifier, and it shall not be used in the declspecifier-seq of a parameter-declaration (8.3.5) nor in the decl-specifier-seq of a function-definition (8.4).
typedef-name:
identifier
A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a
typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier in
the way described in Clause 8. A typedef-name is thus a synonym for another type. A typedef-name does
not introduce a new type the way a class declaration (9.1) or enum declaration does. [ Example: after
typedef int MILES, *KLICKSP;
the constructions
MILES distance;
extern KLICKSP metricp;
are all correct declarations; the type of distance is int and that of metricp is “pointer to int.” — end
example ]
2 A typedef-name can also be introduced by an alias-declaration. The identifier following the using keyword
becomes a typedef-name. It has the same semantics as if it were introduced by the typedef specifier. In
particular, it does not define a new type and it shall not appear in the type-id. [ Example:
91) The inline keyword has no effect on the linkage of a function.
§ 7.1.3 144

 c ISO/IEC N3242=11-0012
using handler_t = void (*)(int);
extern handler_t ignore;
extern void (*ignore)(int); // redeclare ignore
using cell = pair<void*, cell*>; // ill-formed
— end example ]
3 In a given non-class scope, a typedef specifier can be used to redefine the name of any type declared in that
scope to refer to the type to which it already refers. [ Example:
typedef struct s { /∗ ... ∗/ } s;
typedef int I;
typedef int I;
typedef I I;
— end example ]
4 In a given class scope, a typedef specifier can be used to redefine any class-name declared in that scope
that is not also a typedef-name to refer to the type to which it already refers. [ Example:
struct S {
typedef struct A { } A; // OK
typedef struct B B; // OK
typedef A A; // error
};
— end example ]
5 In a given scope, a typedef specifier shall not be used to redefine the name of any type declared in that
scope to refer to a different type. [ Example:
class complex { /∗ ... ∗/ };
typedef int complex; // error: redefinition
— end example ]
6 Similarly, in a given scope, a class or enumeration shall not be declared with the same name as a typedef-name
that is declared in that scope and refers to a type other than the class or enumeration itself. [ Example:
typedef int complex;
class complex { /* ... */ }; // error: redefinition
— end example ]
7 [ Note: A typedef-name that names a class type, or a cv-qualified version thereof, is also a class-name (9.1).
If a typedef-name is used to identify the subject of an elaborated-type-specifier (7.1.6.3), a class definition
(Clause 9), a constructor declaration (12.1), or a destructor declaration (12.4), the program is ill-formed.
— end note ] [ Example:
struct S {
S();
~S();
};
typedef struct S T;
S a = T(); // OK
struct T * p; // error
§ 7.1.3 145

 c ISO/IEC N3242=11-0012
— end example ]
8 If the typedef declaration defines an unnamed class (or enum), the first typedef-name declared by the declaration to be that class type (or enum type) is used to denote the class type (or enum type) for linkage
purposes only (3.5). [ Example:
typedef struct { } *ps, S; // S is the class name for linkage purposes
— end example ]
7.1.4 The friend specifier [dcl.friend]
1 The friend specifier is used to specify access to class members; see 11.3.
7.1.5 The constexpr specifier [dcl.constexpr]
1 The constexpr specifier shall be applied only to the definition of an object, the declaration of a function or
function template, or the declaration of a static data member of a literal type (3.9). If any declaration of a
function or function template has constexpr specifier, then all its declarations shall contain the constexpr
specifier. [ Note: An explicit specialization can differ from the template declaration with respect to the
constexpr specifier. — end note ] [ Note: Function parameters cannot be declared constexpr. — end note ]
[ Example:
constexpr int square(int x); // OK: declaration
constexpr int bufsz = 1024; // OK: definition
constexpr struct pixel { // error: pixel is a type
int x;
int y;
constexpr pixel(int); // OK: declaration
};
constexpr pixel::pixel(int a)
: x(square(a)), y(square(a)) // OK: definition
{ }
constexpr pixel small(2); // error: square not defined, so small(2)
// not constant (5.19) so constexpr not satisfied
constexpr int square(int x) { // OK: definition
return x * x;
}
constexpr pixel large(4); // OK: square defined
int next(constexpr int x) { // error: not for parameters
return x + 1;
}
extern constexpr int memsz; // error: not a definition
— end example ]
2 A constexpr specifier used in the declaration of a function that is not a constructor declares that function
to be a constexpr function. Similarly, a constexpr specifier used in a constructor declaration declares that
constructor to be a constexpr constructor. constexpr functions and constexpr constructors are implicitly
inline (7.1.2).
3 The definition of a constexpr function shall satisfy the following constraints:
— it shall not be virtual (10.3)
— its return type shall be a literal type or a reference to literal type
§ 7.1.5 146

 c ISO/IEC N3242=11-0012
— each of its parameter types shall be a literal type or a reference to literal type
— its function-body shall be a compound-statement of the form
{ return expression ; }
— every implicit conversion used in converting expression to the function return type (8.5) shall be one
of those allowed in a constant expression (5.19).
[ Example:
constexpr int square(int x)
{ return x * x; } // OK
constexpr long long_max()
{ return 2147483647; } // OK
constexpr int abs(int x)
{ return x < 0 ? -x : x; } // OK
constexpr void f(int x) // error: return type is void
{ /∗ ... ∗/ }
constexpr int prev(int x)
{ return --x; } // error: use of decrement
constexpr int g(int x, int n) { // error: body not just “return expr”
int r = 1;
while (--n > 0) r *= x;
return r;
} —
end example ]
4 The definition of a constexpr constructor shall satisfy the following constraints:
— each of its parameter types shall be a literal type or a reference to literal type;
— its function-body shall not be a function-try-block;
— the compound-statement of its function-body shall be empty;
— every non-static data member and base class sub-object shall be initialized (12.6.2);
— every constructor involved in initializing non-static data members and base class sub-objects shall be
a constexpr constructor;
— every assignment-expression that is an initializer-clause appearing directly or indirectly within a braceor-equal-initializer for a non-static data member that is not named by a mem-initializer-id shall be a
constant expression; and
— every implicit conversion used in converting a constructor argument to the corresponding parameter
type and converting a full-expression to the corresponding member type shall be one of those allowed
in a constant expression.
A trivial copy/move constructor is also a constexpr constructor.
[ Example:
struct Length {
explicit constexpr Length(int i = 0) : val(i) { }
private:
int val;
};
§ 7.1.5 147

 c ISO/IEC N3242=11-0012
— end example ]
5 Function invocation substitution for a call of a constexpr function or of a constexpr constructor means implicitly converting each argument expression to the corresponding parameter type as if by copy-initialization92,
substituting that converted expression for each use of the corresponding parameter in the function-body, and,
for constexpr functions, implicitly converting the resulting expression to the return type of the function.
Such substitution does not change the meaning. [ Example:
constexpr int f(void *) { return 0; }
constexpr int f(...) { return 1; }
constexpr int g1() { return f(0); } // calls f(void *)
constexpr int g2(int n) { return f(n); } // calls f(...) even for n == 0
constexpr int g3(int n) { return f(n*0); } // calls f(...)
namespace N {
constexpr int c = 5;
constexpr int h() { return c; }
}
constexpr int c = 0;
constexpr int g4() { return N::h(); } // value is 5, c is not looked up again after the substitution
— end example ]
For a constexpr function, if no function argument values exist such that the function invocation substitution would produce a constant expression (5.19), the program is ill-formed; no diagnostic required. For
a constexpr constructor, if no argument values exist such that after function invocation substitution, every constructor call and full-expression in the mem-initializers would be a constant expression (including
conversions), the program is ill-formed; no diagnostic required. [ Example:
constexpr int f(bool b)
{ return b ? throw 0 : 0; } // OK
constexpr int f() { throw 0; } // ill-formed, no diagnostic required
struct B {
constexpr B(int x) : i(0) { } // x is unused
int i;
};
int global;
struct D : B {
constexpr D() : B(global) { } // ill-formed, no diagnostic required
// lvalue-to-rvalue conversion on non-constant global
};
— end example ]
6 If the instantiated template specialization of a constexpr function template or member function of a class
template would fail to satisfy the requirements for a constexpr function or constexpr constructor, that
specialization is not a constexpr function or constexpr constructor. [ Note: If the function is a member
function it will still be const as described below. Implementations are encouraged to issue a warning if a
function is rendered not constexpr by a non-dependent construct. — end note ]
92) The resulting converted value will include an lvalue-to-rvalue conversion (4.1) if the corresponding copy-initialization
requires one.
§ 7.1.5 148

 c ISO/IEC N3242=11-0012
7 A call to a constexpr function produces the same result as a call to an equivalent non-constexpr function
in all respects except that a call to a constexpr function can appear in a constant expression.
8 A constexpr specifier for a non-static member function that is not a constructor declares that member
function to be const (9.3.1). [ Note: The constexpr specifier has no other effect on the function type. —
end note ] The keyword const is ignored if it appears in the cv-qualifier-seq of the function declarator of
the declaration of such a member function. The class of which that function is a member shall be a literal
type (3.9). [ Example:
class debug_flag {
public:
explicit debug_flag(bool);
constexpr bool is_on(); // error: debug_flag not
// literal type
private:
bool flag;
};
constexpr int bar(int x, int y) // OK
{ return x + y + x*y; }
// ...
int bar(int x, int y) // error: redefinition of bar
{ return x * 2 + 3 * y; }
— end example ]
9 A constexpr specifier used in an object declaration declares the object as const. Such an object shall
have literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a
constant expression (5.19). Otherwise, every full-expression that appears in its initializer shall be a constant
expression. Each implicit conversion used in converting the initializer expressions and each constructor call
used for the initialization shall be one of those allowed in a constant expression (5.19). [ Example:
struct pixel {
int x, y;
};
constexpr pixel ur = { 1294, 1024 };// OK
constexpr pixel origin; // error: initializer missing
— end example ]
7.1.6 Type specifiers [dcl.type]
1 The type-specifiers are
type-specifier:
trailing-type-specifier
class-specifier
enum-specifier
trailing-type-specifier:
simple-type-specifier
elaborated-type-specifier
typename-specifier
cv-qualifier
type-specifier-seq:
type-specifier attribute-specifier-seqopt
type-specifier type-specifier-seq
§ 7.1.6 149

 c ISO/IEC N3242=11-0012
trailing-type-specifier-seq:
trailing-type-specifier attribute-specifier-seqopt
trailing-type-specifier trailing-type-specifier-seq
The optional attribute-specifier-seq in a type-specifier-seq or a trailing-type-specifier-seq appertains to the
type denoted by the preceding type-specifiers (8.3). The attribute-specifier-seq affects the type only for the
declaration it appears in, not other declarations involving the same type.
2 As a general rule, at most one type-specifier is allowed in the complete decl-specifier-seq of a declaration or
in a type-specifier-seq or trailing-type-specifier-seq. The only exceptions to this rule are the following:
— const can be combined with any type specifier except itself.
— volatile can be combined with any type specifier except itself.
— signed or unsigned can be combined with char, long, short, or int.
— short or long can be combined with int.
— long can be combined with double.
— long can be combined with long.
3 At least one type-specifier that is not a cv-qualifier is required in a declaration unless it declares a constructor,
destructor or conversion function.93 A type-specifier-seq shall not define a class or enumeration unless it
appears in the type-id of an alias-declaration (7.1.3) that is not the declaration of a template-declaration.
4 [ Note: enum-specifiers, class-specifiers, and typename-specifiers are discussed in 7.2, 9, and 14.6, respectively. The remaining type-specifiers are discussed in the rest of this section. — end note ]
7.1.6.1 The cv-qualifiers [dcl.type.cv]
1 There are two cv-qualifiers, const and volatile. If a cv-qualifier appears in a decl-specifier-seq, the initdeclarator-list of the declaration shall not be empty. [ Note: 3.9.3 and 8.3.5 describe how cv-qualifiers affect
object and function types. — end note ] Redundant cv-qualifications are ignored. [ Note: For example, these
could be introduced by typedefs. — end note ]
2 [ Note: Declaring a variable const can affect its linkage (7.1.1) and its usability in constant expressions (5.19).
As described in 8.5, the definition of an object or subobject of const-qualified type must specify an initializer
or be subject to default-initialization. — end note ]
3 A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it
is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object
referenced is a non-const object and can be modified through some other access path. [ Note: Cv-qualifiers
are supported by the type system so that they cannot be subverted without casting (5.2.11). — end note ]
4 Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const
object during its lifetime (3.8) results in undefined behavior. [ Example:
const int ci = 3; // cv-qualified (initialized as required)
ci = 4; // ill-formed: attempt to modify const
int i = 2; // not cv-qualified
const int* cip; // pointer to const int
cip = &i; // OK: cv-qualified access path to unqualified
*cip = 4; // ill-formed: attempt to modify through ptr to const
93) There is no special provision for a decl-specifier-seq that lacks a type-specifier or that has a type-specifier that only specifies
cv-qualifiers. The “implicit int” rule of C is no longer supported.
§ 7.1.6.1 150

 c ISO/IEC N3242=11-0012
int* ip;
ip = const_cast<int*>(cip); // cast needed to convert const int* to int*
*ip = 4; // defined: *ip points to i, a non-const object
const int* ciq = new const int (3); // initialized as required
int* iq = const_cast<int*>(ciq); // cast required
*iq = 4; // undefined: modifies a const object
5 For another example
struct X {
mutable int i;
int j;
};
struct Y {
X x;
Y();
};
const Y y;
y.x.i++; // well-formed: mutable member can be modified
y.x.j++; // ill-formed: const-qualified member modified
Y* p = const_cast<Y*>(&y); // cast away const-ness of y
p->x.i = 99; // well-formed: mutable member can be modified
p->x.j = 99; // undefined: modifies a const member
— end example ]
6 If an attempt is made to refer to an object defined with a volatile-qualified type through the use of a glvalue
with a non-volatile-qualified type, the program behavior is undefined.
7 [ Note: volatile is a hint to the implementation to avoid aggressive optimization involving the object
because the value of the object might be changed by means undetectable by an implementation. See 1.9 for
detailed semantics. In general, the semantics of volatile are intended to be the same in C++ as they are
in C. — end note ]
7.1.6.2 Simple type specifiers [dcl.type.simple]
1 The simple type specifiers are
§ 7.1.6.2 151

 c ISO/IEC N3242=11-0012
simple-type-specifier:
::opt nested-name-specifieropt type-name
::opt nested-name-specifier template simple-template-id
char
char16_t
char32_t
wchar_t
bool
short
int
long
signed
unsigned
float
double
void
auto
decltype-specifier
type-name:
class-name
enum-name
typedef-name
simple-template-id
decltype-specifier:
decltype ( expression )
2 The auto specifier is a placeholder for a type to be deduced (7.1.6.4). The other simple-type-specifiers specify
either a previously-declared user-defined type or one of the fundamental types (3.9.1). Table 10 summarizes
the valid combinations of simple-type-specifiers and the types they specify.
Table 10 — simple-type-specifiers and the types they specify
Specifier(s) Type
type-name the type named
simple-template-id the type as defined in 14.2
char “char”
unsigned char “unsigned char”
signed char “signed char”
char16_t “char16_t”
char32_t “char32_t”
bool “bool”
unsigned “unsigned int”
unsigned int “unsigned int”
signed “int”
signed int “int”
int “int”
unsigned short int “unsigned short int”
unsigned short “unsigned short int”
unsigned long int “unsigned long int”
unsigned long “unsigned long int”
unsigned long long int “unsigned long long int”
unsigned long long “unsigned long long int”
signed long int “long int”
§ 7.1.6.2 152

 c ISO/IEC N3242=11-0012
Table 10 — simple-type-specifiers and the types they specify (continued)
Specifier(s) Type
signed long “long int”
signed long long int “long long int”
signed long long “long long int”
long long int “long long int”
long long “long long int”
long int “long int”
long “long int”
signed short int “short int”
signed short “short int”
short int “short int”
short “short int”
wchar_t “wchar_t”
float “float”
double “double”
long double “long double”
void “void”
auto placeholder for a type to be deduced
decltype(expression) the type as defined below
3 When multiple simple-type-specifiers are allowed, they can be freely intermixed with other decl-specifiers in
any order. [ Note: It is implementation-defined whether objects of char type and certain bit-fields (9.6) are
represented as signed or unsigned quantities. The signed specifier forces char objects and bit-fields to be
signed; it is redundant in other contexts. — end note ]
4 The type denoted by decltype(e) is defined as follows:
— if e is an unparenthesized id-expression or a an unparenthesized class member access (5.2.5), decltype(e)
is the type of the entity named by e. If there is no such entity, or if e names a set of overloaded functions, the program is ill-formed;
— otherwise, if e is a function call (5.2.2) or an invocation of an overloaded operator (parentheses around
e are ignored), decltype(e) is the return type of the statically chosen function;
— otherwise, if e is an lvalue, decltype(e) is T&, where T is the type of e;
— otherwise, decltype(e) is the type of e.
The operand of the decltype specifier is an unevaluated operand (Clause 5).
[ Example:
const int&& foo();
int i;
struct A { double x; };
const A* a = new A();
decltype(foo()) x1 = i; // type is const int&&
decltype(i) x2; // type is int
decltype(a->x) x3; // type is double
decltype((a->x)) x4 = x3; // type is const double&
— end example ]
§ 7.1.6.2 153

 c ISO/IEC N3242=11-0012
7.1.6.3 Elaborated type specifiers [dcl.type.elab]
elaborated-type-specifier:
class-key attribute-specifier-seqopt::opt nested-name-specifieropt identifier
class-key ::opt nested-name-specifieropttemplateopt simple-template-id
enum ::opt nested-name-specifieropt identifier
1 An attribute-specifier-seq shall not appear in an elaborated-type-specifier unless the latter is the sole constituent of a declaration. If an elaborated-type-specifier is the sole constituent of a declaration, the declaration
is ill-formed unless it is an explicit specialization (14.7.3), an explicit instantiation (14.7.2) or it has one of
the following forms:
class-key attribute-specifier-seqopt identifier ;
friend class-key ::opt identifier ;
friend class-key ::opt simple-template-id ;
friend class-key ::opt nested-name-specifier identifier ;
friend class-key ::opt nested-name-specifier templateopt simple-template-id ;
In the first case, the attribute-specifier-seq, if any, appertains to the class being declared; the attributes in
the attribute-specifier-seq are thereafter considered attributes of the class whenever it is named.
2 3.4.4 describes how name lookup proceeds for the identifier in an elaborated-type-specifier. If the identifier
resolves to a class-name or enum-name, the elaborated-type-specifier introduces it into the declaration the
same way a simple-type-specifier introduces its type-name. If the identifier resolves to a typedef-name or the
simple-template-id resolves to [FI 11] a template aliasan alias template specialization, the elaborated-typespecifier is ill-formed. [ Note: This implies that, within a class template with a template type-parameter T,
the declaration
friend class T;
is ill-formed. However, the similar declaration friend T; is allowed (11.3). — end note ]
3 The class-key or enum keyword present in the elaborated-type-specifier shall agree in kind with the declaration to which the name in the elaborated-type-specifier refers. This rule also applies to the form of
elaborated-type-specifier that declares a class-name or friend class since it can be construed as referring to
the definition of the class. Thus, in any elaborated-type-specifier, the enum keyword shall be used to refer to
an enumeration (7.2), the union class-key shall be used to refer to a union (Clause 9), and either the class
or struct class-key shall be used to refer to a class (Clause 9) declared using the class or struct class-key.
[ Example:
enum class E { a, b };
enum E x = E::a; // OK
— end example ]
7.1.6.4 auto specifier [dcl.spec.auto]
1 The auto type-specifier signifies that the type of a variable being declared shall be deduced from its initializer
or that a function declarator shall include a trailing-return-type.
2 The auto type-specifier may appear with a function declarator with a trailing-return-type (8.3.5) in any
context where such a declarator is valid.
3 Otherwise, the type of the variable is deduced from its initializer. The name of the variable being declared
shall not appear in the initializer expression. This use of auto is allowed when declaring variables in a
block (6.3), in namespace scope (3.3.6), and in a for-init-statement (6.5.3). auto shall appear as one of
the decl-specifiers in the decl-specifier-seq and the decl-specifier-seq shall be followed by one or more initdeclarators, each of which shall have a non-empty initializer.
§ 7.1.6.4 154

 c ISO/IEC N3242=11-0012
[ Example:
auto x = 5; // OK: x has type int
const auto *v = &x, u = 6; // OK: v has type const int*, u has type const int
static auto y = 0.0; // OK: y has type double
auto int r; // error: auto is not a storage-class-specifier
— end example ]
4 The auto type-specifier can also be used in declaring a variable in the condition of a selection statement (6.4) or
an iteration statement (6.5), in the type-specifier-seq in the new-type-id or type-id of a new-expression (5.3.4), in
a for-range-declaration, and in declaring a static data member with a brace-or-equal-initializer that appears
within the member-specification of a class definition (9.4.2).
5 A program that uses auto in a context not explicitly allowed in this section is ill-formed.
6 Once the type of a declarator-id has been determined according to 8.3, the type of the declared variable
using the declarator-id is determined from the type of its initializer using the rules for template argument
deduction. Let T be the type that has been determined for a variable identifier d. Obtain P from T by
replacing the occurrences of auto with either a new invented type template parameter U or, if the initializer
is a braced-init-list (8.5.4), with std::initializer_list<U>. The type deduced for the variable d is then
the deduced A determined using the rules of template argument deduction from a function call (14.8.2.1),
where P is a function template parameter type and the initializer for d is the corresponding argument. If
the deduction fails, the declaration is ill-formed. [ Example:
auto x1 = { 1, 2 }; // decltype(x1) is std::initializer_list<int>
auto x2 = { 1, 2.0 }; // error: cannot deduce element type
— end example ]
7 If the list of declarators contains more than one declarator, the type of each declared variable is determined
as described above. If the type deduced for the template parameter U is not the same in each deduction, the
program is ill-formed.
[ Example:
const auto &i = expr;
The type of i is the deduced type of the parameter u in the call f(expr) of the following invented function
template:
template <class U> void f(const U& u);
— end example ]
7.2 Enumeration declarations [dcl.enum]
1 An enumeration is a distinct type (3.9.2) with named constants. Its name becomes an enum-name, within
its scope.
enum-name:
identifier
enum-specifier:
enum-head { enumerator-listopt}
enum-head { enumerator-list , }
enum-head:
enum-key attribute-specifier-seqopt identifieropt enum-baseopt
enum-key attribute-specifier-seqopt nested-name-specifier identifier
enum-base
opt
§ 7.2 155

 c ISO/IEC N3242=11-0012
opaque-enum-declaration:
enum-key attribute-specifier-seqopt identifier enum-baseopt;
enum-key:
enum
enum class
enum struct
enum-base:
: type-specifier-seq
enumerator-list:
enumerator-definition
enumerator-list , enumerator-definition
enumerator-definition:
enumerator
enumerator = constant-expression
enumerator:
identifier
The optional attribute-specifier-seq in the enum-head and the opaque-enum-declaration appertains to the
enumeration; the attributes in that attribute-specifier-seq are thereafter considered attributes of the enumeration whenever it is named.
2 The enumeration type declared with an enum-key of only enum is an unscoped enumeration, and its enumerators are unscoped enumerators. The enum-keys enum class and enum struct are semantically equivalent;
an enumeration type declared with one of these is a scoped enumeration, and its enumerators are scoped
enumerators. The optional identifier shall not be omitted in the declaration of a scoped enumeration. The
type-specifier-seq of an enum-base shall name an integral type; any cv-qualification is ignored. An opaqueenum-declaration declaring an unscoped enumeration shall not omit the enum-base. The identifiers in an
enumerator-list are declared as constants, and can appear wherever constants are required. An enumeratordefinition with = gives the associated enumerator the value indicated by the constant-expression. The
constant-expression shall be an integral constant expression (5.19). If the first enumerator has no initializer,
the value of the corresponding constant is zero. An enumerator-definition without an initializer gives the
enumerator the value obtained by increasing the value of the previous enumerator by one.
[ Example:
enum { a, b, c=0 };
enum { d, e, f=e+2 };
defines a, c, and d to be zero, b and e to be 1, and f to be 3. — end example ]
3 An opaque-enum-declaration is either a redeclaration of an enumeration in the current scope or a declaration
of a new enumeration. [ Note: An enumeration declared by an opaque-enum-declaration has fixed underlying
type and is a complete type. The list of enumerators can be provided in a later redeclaration with an enumspecifier. — end note ] A scoped enumeration shall not be later redeclared as unscoped or with a different
underlying type. An unscoped enumeration shall not be later redeclared as scoped and each redeclaration
shall include an enum-base specifying the same underlying type as in the original declaration.
4 If the enum-key is followed by a nested-name-specifier, the enum-specifier shall refer to an enumeration that
was previously declared directly in the class or namespace to which the nested-name-specifier refers (i.e.,
neither inherited nor introduced by a using-declaration), and the enum-specifier shall appear in a namespace
enclosing the previous declaration.
5 Each enumeration defines a type that is different from all other types. Each enumeration also has an
underlying type. The underlying type can be explicitly specified using enum-base; if not explicitly specified,
the underlying type of a scoped enumeration type is int. In these cases, the underlying type is said to be
§ 7.2 156

 c ISO/IEC N3242=11-0012
fixed. Following the closing brace of an enum-specifier, each enumerator has the type of its enumeration.
If the underlying type is fixed, the type of each enumerator prior to the closing brace is the underlying
type; if the initializing value of an enumerator cannot be represented by the underlying type, the program
is ill-formed. If the underlying type is not fixed, the type of each enumerator is the type of its initializing
value:
— If an initializer is specified for an enumerator, the initializing value has the same type as the expression.
— If no initializer is specified for the first enumerator, the initializing value has an unspecified integral
type.
— Otherwise the type of the initializing value is the same as the type of the initializing value of the
preceding enumerator unless the incremented value is not representable in that type, in which case the
type is an unspecified integral type sufficient to contain the incremented value. If no such type exists,
the program is ill-formed.
6 For an enumeration whose underlying type is not fixed, the underlying type is an integral type that can
represent all the enumerator values defined in the enumeration. If no integral type can represent all the
enumerator values, the enumeration is ill-formed. It is implementation-defined which integral type is used
as the underlying type except that the underlying type shall not be larger than int unless the value of an
enumerator cannot fit in an int or unsigned int. If the enumerator-list is empty, the underlying type is
as if the enumeration had a single enumerator with value 0.
7 For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the
underlying type. Otherwise, for an enumeration where emin is the smallest enumerator and emax is the
largest, the values of the enumeration are the values in the range bmin to bmax, defined as follows: Let K
be 1 for a two’s complement representation and 0 for a one’s complement or sign-magnitude representation.
b
max is the smallest value greater than or equal to max(|emin| − K, |emax|) and equal to 2M − 1, where
M is a non-negative integer. bmin is zero if emin is non-negative and −(bmax + K) otherwise. The size of
the smallest bit-field large enough to hold all the values of the enumeration type is max(M,1) if bmin is
zero and M + 1 otherwise. It is possible to define an enumeration that has values not defined by any of its
enumerators. If the enumerator-list is empty, the values of the enumeration are as if the enumeration had a
single enumerator with value 0.
8 Two enumeration types are layout-compatible if they have the same underlying type.
9 The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by
integral promotion (4.5). [ Example:
enum color { red, yellow, green=20, blue };
color col = red;
color* cp = &col;
if (*cp == blue) // ...
makes color a type describing various colors, and then declares col as an object of that type, and cp as a
pointer to an object of that type. The possible values of an object of type color are red, yellow, green,
blue; these values can be converted to the integral values 0, 1, 20, and 21. Since enumerations are distinct
types, objects of type color can be assigned only values of type color.
color c = 1; // error: type mismatch,
// no conversion from int to color
int i = yellow; // OK: yellow converted to integral value 1
// integral promotion
Note that this implicit enum to int conversion is not provided for a scoped enumeration:
§ 7.2 157

 c ISO/IEC N3242=11-0012
enum class Col { red, yellow, green };
int x = Col::red; // error: no Col to int conversion
Col y = Col::red;
if (y) { } // error: no Col to bool conversion
— end example ]
10 An expression of arithmetic or enumeration type can be converted to an enumeration type explicitly. The
value is unchanged if it is in the range of enumeration values of the enumeration type; otherwise the resulting
enumeration value is unspecified.
11 Each enum-name and each unscoped enumerator is declared in the scope that immediately contains the
enum-specifier. Each scoped enumerator is declared in the scope of the enumeration. These names obey the
scope rules defined for all names in (3.3) and (3.4).[ Example:
enum direction { left=’l’, right=’r’ };
void g() {
direction d; // OK
d = left; // OK
d = direction::right; // OK
}
enum class altitude { high=’h’, low=’l’ };
void h() {
altitude a; // OK
a = high; // error: high not in scope
a = altitude::low; // OK
} —
end example ] An enumerator declared in class scope can be referred to using the class member access
operators (::, . (dot) and -> (arrow)), see 5.2.5. [ Example:
struct X {
enum direction { left=’l’, right=’r’ };
int f(int i) { return i==left ? 0 : i==right ? 1 : 2; }
};
void g(X* p) {
direction d; // error: direction not in scope
int i;
i = p->f(left); // error: left not in scope
i = p->f(X::right); // OK
i = p->f(p->left); // OK
// ...
}
— end example ]
7.3 Namespaces [basic.namespace]
1 A namespace is an optionally-named declarative region. The name of a namespace can be used to access
entities declared in that namespace; that is, the members of the namespace. Unlike other declarative regions,
the definition of a namespace can be split over several parts of one or more translation units.
§ 7.3 158

 c ISO/IEC N3242=11-0012
2 The outermost declarative region of a translation unit is a namespace; see 3.3.6.
7.3.1 Namespace definition [namespace.def]
1 The grammar for a namespace-definition is
namespace-name:
original-namespace-name
namespace-alias
original-namespace-name:
identifier
namespace-definition:
named-namespace-definition
unnamed-namespace-definition
named-namespace-definition:
original-namespace-definition
extension-namespace-definition
original-namespace-definition:
inline
opt namespace identifier { namespace-body }
extension-namespace-definition:
inline
opt namespace original-namespace-name { namespace-body }
unnamed-namespace-definition:
inline
opt namespace { namespace-body }
namespace-body:
declaration-seqopt
2 The identifier in an original-namespace-definition shall not have been previously defined in the declarative
region in which the original-namespace-definition appears. The identifier in an original-namespace-definition
is the name of the namespace. Subsequently in that declarative region, it is treated as an original-namespacename.
3 The original-namespace-name in an extension-namespace-definition shall have previously been defined in an
original-namespace-definition in the same declarative region.
4 Every namespace-definition shall appear in the global scope or in a namespace scope (3.3.6).
5 Because a namespace-definition contains declarations in its namespace-body and a namespace-definition is
itself a declaration, it follows that namespace-definitions can be nested. [ Example:
namespace Outer {
int i;
namespace Inner {
void f() { i++; } // Outer::i
int i;
void g() { i++; } // Inner::i
}
}
— end example ]
6 The enclosing namespaces of a declaration are those namespaces in which the declaration lexically appears,
except for a redeclaration of a namespace member outside its original namespace (e.g., a definition as
specified in 7.3.1.2). Such a redeclaration has the same enclosing namespaces as the original declaration.
[ Example:
§ 7.3.1 159

 c ISO/IEC N3242=11-0012
namespace Q {
namespace V {
void f(); // enclosing namespaces are the global namespace, Q, and Q::V
class C { void m(); };
}
void V::f() { // enclosing namespaces are the global namespace, Q, and Q::V
extern void h(); // ... so this declares Q::V::h
}
void V::C::m() { // enclosing namespaces are the global namespace, Q, and Q::V
}
} —
end example ]
7 If the optional initial inline keyword appears in a namespace-definition for a particular namespace, that
namespace is declared to be an inline namespace. The inline keyword may be used on an extensionnamespace-definition only if it was previously used on the original-namespace-definition for that namespace.
8 Members of an inline namespace can be used in most respects as though they were members of the enclosing
namespace. Specifically, the inline namespace and its enclosing namespace are both added to the set of
associated namespaces used in argument-dependent lookup (3.4.2) whenever one of them is, and a usingdirective (7.3.4) that names the inline namespace is implicitly inserted into the enclosing namespace as for
an unnamed namespace (7.3.1.1). Furthermore, each member of the inline namespace can subsequently be
explicitly instantiated (14.7.2) or explicitly specialized (14.7.3) as though it were a member of the enclosing
namespace. Finally, looking up a name in the enclosing namespace via explicit qualification (3.4.3.2) will
include members of the inline namespace brought in by the using-directive even if there are declarations of
that name in the enclosing namespace.
9 These properties are transitive: if a namespace N contains an inline namespace M, which in turn contains an
inline namespace O, then the members of O can be used as though they were members of M or N. The inline
namespace set of N is the transitive closure of all inline namespaces in N. The enclosing namespace set of O
is the set of namespaces consisting of the innermost non-inline namespace enclosing an inline namespace O,
together with any intervening inline namespaces.
7.3.1.1 Unnamed namespaces [namespace.unnamed]
1 An unnamed-namespace-definition behaves as if it were replaced by
inline
optnamespace unique { /* empty body */ }
using namespace unique ;
namespace unique { namespace-body }
where inline appears if and only if it appears in the unnamed-namespace-definition, all occurrences of
unique in a translation unit are replaced by the same identifier, and this identifier differs from all other
identifiers in the entire program.94 [ Example:
namespace { int i; } // unique ::i
void f() { i++; } // unique ::i++
namespace A {
namespace {
int i; // A:: unique ::i
int j; // A:: unique ::j
}
94) Although entities in an unnamed namespace might have external linkage, they are effectively qualified by a name unique
to their translation unit and therefore can never be seen from any other translation unit.
§ 7.3.1.1 160

 c ISO/IEC N3242=11-0012
void g() { i++; } // A:: unique ::i++
}
using namespace A;
void h() {
i++; // error: unique ::i or A:: unique ::i
A::i++; // A:: unique ::i
j++; // A:: unique ::j
} —
end example ]
7.3.1.2 Namespace member definitions [namespace.memdef]
1 Members (including explicit specializations of templates (14.7.3)) of a namespace can be defined within that
namespace. [ Example:
namespace X {
void f() { /∗ ... ∗/ }
}
— end example ]
2 Members of a named namespace can also be defined outside that namespace by explicit qualification (3.4.3.2)
of the name being defined, provided that the entity being defined was already declared in the namespace
and the definition appears after the point of declaration in a namespace that encloses the declaration’s
namespace. [ Example:
namespace Q {
namespace V {
void f();
}
void V::f() { /∗ ... ∗/ } // OK
void V::g() { /∗ ... ∗/ } // error: g() is not yet a member of V
namespace V {
void g();
}
}
namespace R {
void Q::V::g() { /∗ ... ∗/ } // error: R doesn’t enclose Q
} —
end example ]
3 Every name first declared in a namespace is a member of that namespace. If a friend declaration in a nonlocal class first declares a class or function95 the friend class or function is a member of the innermost enclosing
namespace. The name of the friend is not found by unqualified lookup (3.4.1) or by qualified lookup (3.4.3)
until a matching declaration is provided in that namespace scope (either before or after the class definition
granting friendship). If a friend function is called, its name may be found by the name lookup that considers
functions from namespaces and classes associated with the types of the function arguments (3.4.2). If the
name in a friend declaration is neither qualified nor a template-id and the declaration is a function or
an elaborated-type-specifier, the lookup to determine whether the entity has been previously declared shall
not consider any scopes outside the innermost enclosing namespace. [ Note: The other forms of friend
95) this implies that the name of the class or function is unqualified.
§ 7.3.1.2 161

 c ISO/IEC N3242=11-0012
declarations cannot declare a new member of the innermost enclosing namespace and thus follow the usual
lookup rules. — end note ] [ Example:
// Assume f and g have not yet been defined.
void h(int);
template <class T> void f2(T);
namespace A {
class X {
friend void f(X); // A::f(X) is a friend
class Y {
friend void g(); // A::g is a friend
friend void h(int); // A::h is a friend
// ::h not considered
friend void f2<>(int); // ::f2<>(int) is a friend
};
};
// A::f, A::g and A::h are not visible here
X x;
void g() { f(x); } // definition of A::g
void f(X) { /* ... */} // definition of A::f
void h(int) { /* ... */ } // definition of A::h
// A::f, A::g and A::h are visible here and known to be friends
}
using A::x;
void h() {
A::f(x);
A::X::f(x); // error: f is not a member of A::X
A::X::Y::g(); // error: g is not a member of A::X::Y
} —
end example ]
7.3.2 Namespace alias [namespace.alias]
1 A namespace-alias-definition declares an alternate name for a namespace according to the following grammar:
namespace-alias:
identifier
namespace-alias-definition:
namespace identifier = qualified-namespace-specifier ;
qualified-namespace-specifier:
::opt nested-name-specifieropt namespace-name
2 The identifier in a namespace-alias-definition is a synonym for the name of the namespace denoted by the
qualified-namespace-specifier and becomes a namespace-alias. [ Note: When looking up a namespace-name
in a namespace-alias-definition, only namespace names are considered, see 3.4.6. — end note ]
3 In a declarative region, a namespace-alias-definition can be used to redefine a namespace-alias declared in
that declarative region to refer only to the namespace to which it already refers. [ Example: the following
declarations are well-formed:
namespace Company_with_very_long_name { /∗ ... ∗/ }
namespace CWVLN = Company_with_very_long_name;
namespace CWVLN = Company_with_very_long_name; // OK: duplicate
§ 7.3.2 162

 c ISO/IEC N3242=11-0012
namespace CWVLN = CWVLN;
— end example ]
4 A namespace-name or namespace-alias shall not be declared as the name of any other entity in the same
declarative region. A namespace-name defined at global scope shall not be declared as the name of any
other entity in any global scope of the program. No diagnostic is required for a violation of this rule by
declarations in different translation units.
7.3.3 The using declaration [namespace.udecl]
1 A using-declaration introduces a name into the declarative region in which the using-declaration appears.
using-declaration:
using typenameopt::opt nested-name-specifier unqualified-id ;
using :: unqualified-id ;
The member name specified in a using-declaration is declared in the declarative region in which the usingdeclaration appears. [ Note: Only the specified name is so declared; specifying an enumeration name in a
using-declaration does not declare its enumerators in the using-declaration’s declarative region. — end note ]
If a using-declaration names a constructor (3.4.3.1), it implicitly declares a set of constructors in the class in
which the using-declaration appears (12.9); otherwise the name specified in a using-declaration is a synonym
for the name of some entity declared elsewhere.
2 Every using-declaration is a declaration and a member-declaration and so can be used in a class definition.
[ Example:
struct B {
void f(char);
void g(char);
enum E { e };
union { int x; };
};
struct D : B {
using B::f;
void f(int) { f(’c’); } // calls B::f(char)
void g(int) { g(’c’); } // recursively calls D::g(int)
};
— end example ]
3 In a using-declaration used as a member-declaration, the nested-name-specifier shall name a base class of the
class being defined. If such a using-declaration names a constructor, the nested-name-specifier shall name a
direct base class of the class being defined; otherwise it introduces the set of declarations found by member
name lookup (10.2, 3.4.3.1). [ Example:
class C {
int g();
};
class D2 : public B {
using B::f; // OK: B is a base of D2
using B::e; // OK: e is an enumerator of base B
using B::x; // OK: x is a union member of base B
using C::g; // error: C isn’t a base of D2
};
§ 7.3.3 163

 c ISO/IEC N3242=11-0012
— end example ]
4 [ Note: Since destructors do not have names, a using-declaration cannot refer to a destructor for a base
class. Since specializations of member templates for conversion functions are not found by name lookup,
they are not considered when a using-declaration specifies a conversion function (14.5.2). — end note ] If an
assignment operator brought from a base class into a derived class scope has the signature of a copy/move
assignment operator for the derived class (12.8), the using-declaration does not by itself suppress the implicit
declaration of the derived class assignment operator; the copy/move assignment operator from the base class
is hidden or overridden by the implicitly-declared copy/move assignment operator of the derived class, as
described below.
5 A using-declaration shall not name a template-id. [ Example:
struct A {
template <class T> void f(T);
template <class T> struct X { };
};
struct B : A {
using A::f<double>; // ill-formed
using A::X<int>; // ill-formed
};
— end example ]
6 A using-declaration shall not name a namespace.
7 A using-declaration shall not name a scoped enumerator.
8 A using-declaration for a class member shall be a member-declaration. [ Example:
struct X {
int i;
static int s;
};
void f() {
using X::i; // error: X::i is a class member
// and this is not a member declaration.
using X::s; // error: X::s is a class member
// and this is not a member declaration.
}
— end example ]
9 Members declared by a using-declaration can be referred to by explicit qualification just like other member
names (3.4.3.2). In a using-declaration, a prefix :: refers to the global namespace. [ Example:
void f();
namespace A {
void g();
}
namespace X {
using ::f; // global f
using A::g; // A’s g
}
§ 7.3.3 164

 c ISO/IEC N3242=11-0012
void h()
{
X::f(); // calls ::f
X::g(); // calls A::g
} —
end example ]
10 A using-declaration is a declaration and can therefore be used repeatedly where (and only where) multiple
declarations are allowed. [ Example:
namespace A {
int i;
}
namespace A1 {
using A::i;
using A::i; // OK: double declaration
}
void f() {
using A::i;
using A::i; // error: double declaration
}
struct B {
int i;
};
struct X : B {
using B::i;
using B::i; // error: double member declaration
};
— end example ]
11 The entity declared by a using-declaration shall be known in the context using it according to its definition
at the point of the using-declaration. Definitions added to the namespace after the using-declaration are not
considered when a use of the name is made. [ Example:
namespace A {
void f(int);
}
using A::f; // f is a synonym for A::f;
// that is, for A::f(int).
namespace A {
void f(char);
}
void foo() {
f(’a’); // calls f(int),
} // even though f(char) exists.
void bar() {
using A::f; // f is a synonym for A::f;
§ 7.3.3 165

 c ISO/IEC N3242=11-0012
// that is, for A::f(int) and A::f(char).
f(’a’); // calls f(char)
}
— end example ]
12 [ Note: Partial specializations of class templates are found by looking up the primary class template and then
considering all partial specializations of that template. If a using-declaration names a class template, partial
specializations introduced after the using-declaration are effectively visible because the primary template is
visible (14.5.5). — end note ]
13 Since a using-declaration is a declaration, the restrictions on declarations of the same name in the same
declarative region (3.3) also apply to using-declarations. [ Example:
namespace A {
int x;
}
namespace B {
int i;
struct g { };
struct x { };
void f(int);
void f(double);
void g(char); // OK: hides struct g
}
void func() {
int i;
using B::i; // error: i declared twice
void f(char);
using B::f; // OK: each f is a function
f(3.5); // calls B::f(double)
using B::g;
g(’a’); // calls B::g(char)
struct g g1; // g1 has class type B::g
using B::x;
using A::x; // OK: hides struct B::x
x = 99; // assigns to A::x
struct x x1; // x1 has class type B::x
} —
end example ]
14 If a function declaration in namespace scope or block scope has the same name and the same parameter
types as a function introduced by a using-declaration, and the declarations do not declare the same function,
the program is ill-formed. [ Note: Two using-declarations may introduce functions with the same name and
the same parameter types. If, for a call to an unqualified function name, function overload resolution selects
the functions introduced by such using-declarations, the function call is ill-formed. [ Example:
namespace B {
void f(int);
void f(double);
}
namespace C {
void f(int);
§ 7.3.3 166

 c ISO/IEC N3242=11-0012
void f(double);
void f(char);
}
void h() {
using B::f; // B::f(int) and B::f(double)
using C::f; // C::f(int), C::f(double), and C::f(char)
f(’h’); // calls C::f(char)
f(1); // error: ambiguous: B::f(int) or C::f(int)?
void f(int); // error: f(int) conflicts with C::f(int) and B::f(int)
}
— end example ] — end note ]
15 When a using-declaration brings names from a base class into a derived class scope, member functions and
member function templates in the derived class override and/or hide member functions and member function
templates with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (if any) in a
base class (rather than conflicting). [ Note: For using-declarations that name a constructor, see 12.9. — end
note ] [ Example:
struct B {
virtual void f(int);
virtual void f(char);
void g(int);
void h(int);
};
struct D : B {
using B::f;
void f(int); // OK: D::f(int) overrides B::f(int);
using B::g;
void g(char); // OK
using B::h;
void h(int); // OK: D::h(int) hides B::h(int)
};
void k(D* p)
{
p->f(1); // calls D::f(int)
p->f(’a’); // calls B::f(char)
p->g(1); // calls B::g(int)
p->g(’a’); // calls D::g(char)
}
— end example ]
16 For the purpose of overload resolution, the functions which are introduced by a using-declaration into a
derived class will be treated as though they were members of the derived class. In particular, the implicit
this parameter shall be treated as if it were a pointer to the derived class rather than to the base class.
This has no effect on the type of the function, and in all other respects the function remains a member of
the base class.
17 The access rules for inheriting constructors are specified in 12.9; otherwise all instances of the name mentioned
in a using-declaration shall be accessible. In particular, if a derived class uses a using-declaration to access
§ 7.3.3 167

 c ISO/IEC N3242=11-0012
a member of a base class, the member name shall be accessible. If the name is that of an overloaded
member function, then all functions named shall be accessible. The base class members mentioned by a
using-declaration shall be visible in the scope of at least one of the direct base classes of the class where the
using-declaration is specified. [ Note: Because a using-declaration designates a base class member (and not
a member subobject or a member function of a base class subobject), a using-declaration cannot be used to
resolve inherited member ambiguities. For example,
struct A { int x(); };
struct B : A { };
struct C : A {
using A::x;
int x(int);
};
struct D : B, C {
using C::x;
int x(double);
};
int f(D* d) {
return d->x(); // ambiguous: B::x or C::x
}
— end note ]
18 The alias created by the using-declaration has the usual accessibility for a member-declaration. [ Note: A
using-declaration that names a constructor does not create aliases; see 12.9 for the pertinent accessibility
rules. — end note ] [ Example:
class A {
private:
void f(char);
public:
void f(int);
protected:
void g();
};
class B : public A {
using A::f; // error: A::f(char) is inaccessible
public:
using A::g; // B::g is a public synonym for A::g
};
— end example ]
19 If a using-declaration uses the keyword typename and specifies a dependent name (14.6.2), the name introduced by the using-declaration is treated as a typedef-name (7.1.3).
7.3.4 Using directive [namespace.udir]
using-directive:
attribute-specifier-seqoptusing namespace ::opt nested-name-specifieropt namespace-name ;
1 A using-directive shall not appear in class scope, but may appear in namespace scope or in block scope.
[ Note: When looking up a namespace-name in a using-directive, only namespace names are considered,
see 3.4.6. — end note ] The optional attribute-specifier-seq appertains to the using-directive.
§ 7.3.4 168

 c ISO/IEC N3242=11-0012
2 A using-directive specifies that the names in the nominated namespace can be used in the scope in which the
using-directive appears after the using-directive. During unqualified name lookup (3.4.1), the names appear
as if they were declared in the nearest enclosing namespace which contains both the using-directive and the
nominated namespace. [ Note: In this context, “contains” means “contains directly or indirectly”. — end
note ]
3 A using-directive does not add any members to the declarative region in which it appears. [ Example:
namespace A {
int i;
namespace B {
namespace C {
int i;
}
using namespace A::B::C;
void f1() {
i = 5; // OK, C::i visible in B and hides A::i
}
}
namespace D {
using namespace B;
using namespace C;
void f2() {
i = 5; // ambiguous, B::C::i or A::i?
}
}
void f3() {
i = 5; // uses A::i
}
}
void f4() {
i = 5; // ill-formed; neither i is visible
}
— end example ]
4 For unqualified lookup (3.4.1), the using-directive is transitive: if a scope contains a using-directive that
nominates a second namespace that itself contains using-directives, the effect is as if the using-directives
from the second namespace also appeared in the first. [ Note: For qualified lookup, see 3.4.3.2. — end note ]
[ Example:
namespace M {
int i;
}
namespace N {
int i;
using namespace M;
}
void f() {
using namespace N;
i = 7; // error: both M::i and N::i are visible
}
For another example,
§ 7.3.4 169

 c ISO/IEC N3242=11-0012
namespace A {
int i;
}
namespace B {
int i;
int j;
namespace C {
namespace D {
using namespace A;
int j;
int k;
int a = i; // B::i hides A::i
}
using namespace D;
int k = 89; // no problem yet
int l = k; // ambiguous: C::k or D::k
int m = i; // B::i hides A::i
int n = j; // D::j hides B::j
}
}
— end example ]
5 If a namespace is extended by an extension-namespace-definition after a using-directive for that namespace
is given, the additional members of the extended namespace and the members of namespaces nominated by
using-directives in the extension-namespace-definition can be used after the extension-namespace-definition.
6 If name lookup finds a declaration for a name in two different namespaces, and the declarations do not
declare the same entity and do not declare functions, the use of the name is ill-formed. [ Note: In particular,
the name of a variable, function or enumerator does not hide the name of a class or enumeration declared
in a different namespace. For example,
namespace A {
class X { };
extern "C" int g();
extern "C++" int h();
}
namespace B {
void X(int);
extern "C" int g();
extern "C++" int h(int);
}
using namespace A;
using namespace B;
void f() {
X(1); // error: name X found in two namespaces
g(); // okay: name g refers to the same entity
h(); // okay: overload resolution selects A::h
}
— end note ]
7 During overload resolution, all functions from the transitive search are considered for argument matching.
The set of declarations found by the transitive search is unordered. [ Note: In particular, the order in which
namespaces were considered and the relationships among the namespaces implied by the using-directives do
§ 7.3.4 170

 c ISO/IEC N3242=11-0012
not cause preference to be given to any of the declarations found by the search. — end note ] An ambiguity
exists if the best match finds two functions with the same signature, even if one is in a namespace reachable
through using-directives in the namespace of the other.96 [ Example:
namespace D {
int d1;
void f(char);
}
using namespace D;
int d1; // OK: no conflict with D::d1
namespace E {
int e;
void f(int);
}
namespace D { // namespace extension
int d2;
using namespace E;
void f(int);
}
void f() {
d1++; // error: ambiguous ::d1 or D::d1?
::d1++; // OK
D::d1++; // OK
d2++; // OK: D::d2
e++; // OK: E::e
f(1); // error: ambiguous: D::f(int) or E::f(int)?
f(’a’); // OK: D::f(char)
} —
end example ]
7.4 The asm declaration [dcl.asm]
1 An asm declaration has the form
asm-definition:
asm ( string-literal ) ;
The asm declaration is conditionally-supported; its meaning is implementation-defined. [ Note: Typically it
is used to pass information through the implementation to an assembler. — end note ]
7.5 Linkage specifications [dcl.link]
1 All function types, function names with external linkage, and variable names with external linkage have a
language linkage. [ Note: Some of the properties associated with an entity with language linkage are specific
to each implementation and are not described here. For example, a particular language linkage may be
associated with a particular form of representing names of objects and functions with external linkage, or
with a particular calling convention, etc. — end note ] The default language linkage of all function types,
96) During name lookup in a class hierarchy, some ambiguities may be resolved by considering whether one member hides
the other along some paths (10.2). There is no such disambiguation when considering the set of names found as a result of
following using-directives.
§ 7.5 171

 c ISO/IEC N3242=11-0012
function names, and variable names is C++ language linkage. Two function types with different language
linkages are distinct types even if they are otherwise identical.
2 Linkage (3.5) between C++ and non-C++ code fragments can be achieved using a linkage-specification:
linkage-specification:
extern string-literal { declaration-seqopt}
extern string-literal declaration
The string-literal indicates the required language linkage. This International Standard specifies the semantics
for the string-literals "C" and "C++". Use of a string-literal other than "C" or "C++" is conditionallysupported, with implementation-defined semantics. [ Note: Therefore, a linkage-specification with a stringliteral that is unknown to the implementation requires a diagnostic. — end note ] [ Note: It is recommended
that the spelling of the string-literal be taken from the document defining that language. For example, Ada
(not ADA) and Fortran or FORTRAN, depending on the vintage. — end note ]
3 Every implementation shall provide for linkage to functions written in the C programming language, "C",
and linkage to C++ functions, "C++". [ Example:
complex sqrt(complex); // C++ linkage by default
extern "C" {
double sqrt(double); // C linkage
} —
end example ]
4 Linkage specifications nest. When linkage specifications nest, the innermost one determines the language
linkage. A linkage specification does not establish a scope. A linkage-specification shall occur only in
namespace scope (3.3). In a linkage-specification, the specified language linkage applies to the function
types of all function declarators, function names with external linkage, and variable names with external
linkage declared within the linkage-specification. [ Example:
extern "C" void f1(void(*pf)(int));
// the name f1 and its function type have C language
// linkage; pf is a pointer to a C function
extern "C" typedef void FUNC();
FUNC f2; // the name f2 has C++ language linkage and the
// function’s type has C language linkage
extern "C" FUNC f3; // the name of function f3 and the function’s type
// have C language linkage
void (*pf2)(FUNC*); // the name of the variable pf2 has C++ linkage and
// the type of pf2 is pointer to C++ function that
// takes one parameter of type pointer to C function
extern "C" {
static void f4(); // the name of the function f4 has
// internal linkage (not C language
// linkage) and the function’s type
// has C language linkage.
}
extern "C" void f5() {
extern void f4(); // OK: Name linkage (internal)
// and function type linkage (C
// language linkage) gotten from
// previous declaration.
}
§ 7.5 172

 c ISO/IEC N3242=11-0012
extern void f4(); // OK: Name linkage (internal)
// and function type linkage (C
// language linkage) gotten from
// previous declaration.
}
void f6() {
extern void f4(); // OK: Name linkage (internal)
// and function type linkage (C
// language linkage) gotten from
// previous declaration.
}
— end example ] A C language linkage is ignored for the names of class members and the member function
type of class member functions. [ Example:
extern "C" typedef void FUNC_c();
class C {
void mf1(FUNC_c*); // the name of the function mf1 and the member
// function’s type have C++ language linkage; the
// parameter has type pointer to C function
FUNC_c mf2; // the name of the function mf2 and the member
// function’s type have C++ language linkage
static FUNC_c* q; // the name of the data member q has C++ language
// linkage and the data member’s type is pointer to
// C function
};
extern "C" {
class X {
void mf(); // the name of the function mf and the member
// function’s type have C++ language linkage
void mf2(void(*)()); // the name of the function mf2 has C++ language
// linkage; the parameter has type pointer to
// C function
};
} —
end example ]
5 If two declarations declare functions with the same name and parameter-type-list (8.3.5) to be members of
the same namespace or declare objects with the same name to be members of the same namespace and the
declarations give the names different language linkages, the program is ill-formed; no diagnostic is required
if the declarations appear in different translation units. Except for functions with C++ linkage, a function
declaration without a linkage specification shall not precede the first linkage specification for that function.
A function can be declared without a linkage specification after an explicit linkage specification has been
seen; the linkage explicitly specified in the earlier declaration is not affected by such a function declaration.
6 At most one function with a particular name can have C language linkage. Two declarations for a function
with C language linkage with the same function name (ignoring the namespace names that qualify it) that
appear in different namespace scopes refer to the same function. Two declarations for a variable with C
language linkage with the same name (ignoring the namespace names that qualify it) that appear in different
namespace scopes refer to the same variable. An entity with C language linkage shall not be declared with
the same name as an entity in global scope, unless both declarations denote the same entity; no diagnostic
is required if the declarations appear in different translation units. A variable with C language linkage shall
§ 7.5 173

 c ISO/IEC N3242=11-0012
not be declared with the same name as a function with C language linkage (ignoring the namespace names
that qualify the respective names); no diagnostic is required if the declarations appear in different translation
units. [ Note: Only one definition for an entity with a given name with C language linkage may appear in
the program (see 3.2); this implies that such an entity must not be defined in more than one namespace
scope. — end note ] [ Example:
int x;
namespace A {
extern "C" int f();
extern "C" int g() { return 1; }
extern "C" int h();
extern "C" int x(); // ill-formed: same name as global-space object x
}
namespace B {
extern "C" int f(); // A::f and B::f refer to the same function
extern "C" int g() { return 1; } // ill-formed, the function g
// with C language linkage has two definitions
}
int A::f() { return 98; } //definition for the function f with C language linkage
extern "C" int h() { return 97; } // definition for the function h with C language linkage
// A::h and ::h refer to the same function
— end example ]
7 A declaration directly contained in a linkage-specification is treated as if it contains the extern specifier (7.1.1) for the purpose of determining the linkage of the declared name and whether it is a definition.
Such a declaration shall not specify a storage class. [ Example:
extern "C" double f();
static double f(); // error
extern "C" int i; // declaration
extern "C" {
int i; // definition
}
extern "C" static void g(); // error
— end example ]
8 [ Note: Because the language linkage is part of a function type, when a pointer to C function (for example)
is dereferenced, the function to which it refers is considered a C function. — end note ]
9 Linkage from C++ to objects defined in other languages and to objects defined in C++ from other languages
is implementation-defined and language-dependent. Only where the object layout strategies of two language
implementations are similar enough can such linkage be achieved.
7.6 Attributes [dcl.attr]
7.6.1 Attribute syntax and semantics [dcl.attr.grammar]
1 Attributes specify additional information for various source constructs such as types, variables, names,
blocks, or translation units.
attribute-specifier-seq:
attribute-specifier-seqopt attribute-specifier
§ 7.6.1 174

 c ISO/IEC N3242=11-0012
attribute-specifier:
[ [ attribute-list ] ]
alignment-specifier
alignment-specifier:
alignas ( type-id ...opt)
alignas ( alignment-expression ...opt)
attribute-list:
attribute
opt
attribute-list , attributeopt
attribute ...
attribute-list , attribute ...
attribute:
attribute-token attribute-argument-clauseopt
attribute-token:
identifier
attribute-scoped-token
attribute-scoped-token:
attribute-namespace :: identifier
attribute-namespace:
identifier
attribute-argument-clause:
( balanced-token-seq )
balanced-token-seq:
balanced-token
balanced-token-seq balanced-token
balanced-token:
( balanced-token-seq )
[ balanced-token-seq ]
{ balanced-token-seq }
any token other than a parenthesis, a bracket, or a brace
2 [ Note: For each individual attribute, the form of the balanced-token-seq will be specified. — end note ]
3 In an attribute-list, an ellipsis may appear only if that attribute’s specification permits it. An attribute
followed by an ellipsis is a pack expansion (14.5.3). An attribute-specifier that contains no attributes has no
effect. The order in which the attribute-tokens appear in an attribute-list is not significant. If a keyword (2.12)
or an alternative token (2.6) that satisfies the syntactic requirements of an identifier (2.11) is contained
in an attribute-token, it is considered an identifier. No name lookup (3.4) is performed on any of the
identifiers contained in an attribute-token. The attribute-token determines additional requirements on the
attribute-argument-clause (if any). The use of an attribute-scoped-token is conditionally-supported, with
implementation-defined behavior. [ Note: Each implementation should choose a distinctive name for the
attribute-namespace in an attribute-scoped-token. — end note ]
4 Each attribute-specifier-seq is said to appertain to some entity or statement, identified by the syntactic
context where it appears (Clause 6, Clause 7, Clause 8). If an attribute-specifier-seq that appertains to
some entity or statement contains an attribute that is not allowed to apply to that entity or statement, the
program is ill-formed. If an attribute-specifier-seq appertains to a friend declaration (11.3), that declaration
shall be a definition. No attribute-specifier-seq shall appertain to an explicit instantiation (14.7.2).
5 For an attribute-token not specified in this International Standard, the behavior is implementation-defined.
§ 7.6.1 175

 c ISO/IEC N3242=11-0012
6 Two consecutive left square bracket tokens shall appear only when introducing an attribute-specifier. [ Note:
If two consecutive left square brackets appear where an attribute-specifier is not allowed, the program is ill
formed even if the brackets match an alternative grammar production. — end note ] [ Example:
int p[10];
void f() {
int x = 42, y[5];
int(p[[x] { return x; }()]); // error: malformed attribute on a nested
// declarator-id and not a function-style cast of
// an element of p.
y[[] { return 2; }()] = 2; // error even though attributes are not allowed
// in this context.
}
— end example ]
7.6.2 Alignment specifier [dcl.align]
1 An alignment-specifier may be applied to a variable or to a class data member, but it shall not be applied
to a bit-field, a function parameter, the formal parameter of a catch clause (15.3), or a variable declared
with the register storage class specifier. An alignment-specifier may also be applied to the declaration of
a class or enumeration type. An alignment-specifier with an ellipsis is a pack expansion (14.5.3).
2 When the alignment-specifier is of the form alignas( assignment-expression ):
— the assignment-expression shall be an integral constant expression
— if the constant expression evaluates to a fundamental alignment, the alignment requirement of the
declared entity shall be the specified fundamental alignment
— if the constant expression evaluates to an extended alignment and the implementation supports that
alignment in the context of the declaration, the alignment of the declared entity shall be that alignment
— if the constant expression evaluates to an extended alignment and the implementation does not support
that alignment in the context of the declaration, the program is ill-formed
— if the constant expression evaluates to zero, the alignment specifier shall have no effect
— otherwise, the program is ill-formed.
3 When the alignment-specifier is of the form alignas( type-id ), it shall have the same effect as alignas(alignof(typeid )) (5.3.6).
4 When multiple alignment-specifiers are specified for an entity, the alignment requirement shall be set to the
strictest specified alignment.
5 The combined effect of all alignment-specifiers in a declaration shall not specify an alignment that is less
strict than the alignment that would otherwise be required for the entity being declared.
6 If the defining declaration of an entity has an alignment-specifier, any non-defining declaration of that
entity shall either specify equivalent alignment or have no alignment-specifier. Conversely, if any declaration
of an entity has an alignment-specifier, every defining declaration of that entity shall specify an equivalent
alignment. No diagnostic is required if declarations of an entity have different alignment-specifiers in different
translation units.
[ Example:
// Translation unit #1:
struct S { int x; } s, p = &s;
§ 7.6.2 176

 c ISO/IEC N3242=11-0012
// Translation unit #2:
struct alignas(16) S; // error: definition of S lacks alignment; no
extern S* p; // diagnostic required
— end example ]
7 [ Example: An aligned buffer with an alignment requirement of A and holding N elements of type T other
than char, signed char, or unsigned char can be declared as:
alignas(T) alignas(A) T buffer[N];
Specifying alignas(T) ensures that the final requested alignment will not be weaker than alignof(T), and
therefore the program will not be ill-formed. — end example ]
8 [ Example:
alignas(double) void f(); // error: alignment applied to function
alignas(double) unsigned char c[sizeof(double)]; // array of characters, suitably aligned for a double
extern unsigned char c[sizeof(double)]; // no alignas necessary
alignas(float)
extern unsigned char c[sizeof(double)]; // error: different alignment in declaration
— end example ]
7.6.3 Noreturn attribute [dcl.attr.noreturn]
1 The attribute-token noreturn specifies that a function does not return. It shall appear at most once in
each attribute-list and no attribute-argument-clause shall be present. The attribute may be applied to
the declarator-id in a function declaration. The first declaration of a function shall specify the noreturn
attribute if any declaration of that function specifies the noreturn attribute. If a function is declared with
the noreturn attribute in one translation unit and the same function is declared without the noreturn
attribute in another translation unit, the program is ill-formed; no diagnostic required.
2 If a function f is called where f was previously declared with the noreturn attribute and f eventually
returns, the behavior is undefined. [ Note: The function may terminate by throwing an exception. — end
note ] [ Note: Implementations are encouraged to issue a warning if a function marked [[noreturn]] might
return. — end note ]
3 [ Example:
[[ noreturn ]] void f() {
throw "error"; // OK
}
[[ noreturn ]] void q(int i) { // behavior is undefined if called with an argument <= 0
if (i > 0)
throw "positive";
} —
end example ]
7.6.4 Carries dependency attribute [dcl.attr.depend]
1 The attribute-token carries_dependency specifies dependency propagation into and out of functions. It
shall appear at most once in each attribute-list and no attribute-argument-clause shall be present. The
§ 7.6.4 177

 c ISO/IEC N3242=11-0012
attribute may be applied to the declarator-id of a parameter-declaration in a function declaration or lambda,
in which case it specifies that the initialization of the parameter carries a dependency to (1.10) each lvalueto-rvalue conversion (4.1) of that object. The attribute may also be applied to the declarator-id of a function
declaration, in which case it specifies that the return value, if any, carries a dependency to the evaluation of
the function call expression.
2 The first declaration of a function shall specify the carries_dependency attribute for its declarator-id if any
declaration of the function specifies the carries_dependency attribute. Furthermore, the first declaration of
a function shall specify the carries_dependency attribute for a parameter if any declaration of that function
specifies the carries_dependency attribute for that parameter. If a function or one of its parameters is
declared with the carries_dependency attribute in its first declaration in one translation unit and the
same function or one of its parameters is declared without the carries_dependency attribute in its first
declaration in another translation unit, the program is ill-formed; no diagnostic required.
3 [ Note: The carries_dependency attribute does not change the meaning of the program, but may result in
generation of more efficient code. — end note ]
4 [ Example:
/∗
Translation unit A. ∗/
struct foo { int* a; int* b; };
std::atomic<struct foo *> foo_head[10];
int foo_array[10][10];
[[carries_dependency]] struct foo* f(int i) {
return foo_head[i].load(memory_order_consume);
}
[[carries_dependency]] int g(int* x, int* y) {
return kill_dependency(foo_array[*x][*y]);
} /∗
Translation unit B. ∗/
[[carries_dependency]] struct foo* f(int i);
[[carries_dependency]] int* g(int* x, int* y);
int c = 3;
void h(int i) {
struct foo* p;
p = f(i);
do_something_with(g(&c, p->a));
do_something_with(g(p->a, &c));
}
5 The carries_dependency attribute on function f means that the return value carries a dependency out of
f, so that the implementation need not constrain ordering upon return from f. Implementations of f and
its caller may choose to preserve dependencies instead of emitting hardware memory ordering instructions
(a.k.a. fences).
6 Function g’s second argument has a carries_dependency attribute, but its first argument does not. Therefore, function h’s first call to g carries a dependency into g, but its second call does not. The implementation
might need to insert a fence prior to the second call to g.
§ 7.6.4 178

 c ISO/IEC N3242=11-0012
— end example ]
§ 7.6.4 179

 c ISO/IEC N3242=11-0012
8 Declarators [dcl.decl]
1 A declarator declares a single variable, function, or type, within a declaration. The init-declarator-list
appearing in a declaration is a comma-separated sequence of declarators, each of which can have an initializer.
init-declarator-list:
init-declarator
init-declarator-list , init-declarator
init-declarator:
declarator initializer
opt
2 The three components of a simple-declaration are the attributes (7.6), the specifiers (decl-specifier-seq; 7.1)
and the declarators (init-declarator-list). The specifiers indicate the type, storage class or other properties
of the entities being declared. The declarators specify the names of these entities and (optionally) modify
the type of the specifiers with operators such as * (pointer to) and () (function returning). Initial values
can also be specified in a declarator; initializers are discussed in 8.5 and 12.6.
3 Each init-declarator in a declaration is analyzed separately as if it was in a declaration by itself.97
4 Declarators have the syntax
declarator:
ptr-declarator
noptr-declarator parameters-and-qualifiers trailing-return-type
ptr-declarator:
noptr-declarator
ptr-operator ptr-declarator
noptr-declarator:
declarator-id attribute-specifier-seqopt
noptr-declarator parameters-and-qualifiers
noptr-declarator [ constant-expressionopt] attribute-specifier-seqopt
( ptr-declarator )
parameters-and-qualifiers:
( parameter-declaration-clause ) attribute-specifier-seqopt cv-qualifier-seqopt
ref-qualifieropt exception-specificationopt
trailing-return-type:
-> trailing-type-specifier-seq abstract-declaratoropt
97) A declaration with several declarators is usually equivalent to the corresponding sequence of declarations each with a single
declarator. That is
T D1, D2, ... Dn;
is usually equvalent to
T D1; T D2; ... T Dn;
where T is a decl-specifier-seq and each Di is an init-declarator. The exception occurs when a name introduced by one of
the declarators hides a type name used by the decl-specifiers, so that when the same decl-specifiers are used in a subsequent
declaration, they do not have the same meaning, as in
struct S ... ;
S S, T; // declare two instances of struct S
which is not equivalent to
struct S ... ;
S S;
S T; // error
180

 c ISO/IEC N3242=11-0012
ptr-operator:
* attribute-specifier-seqopt cv-qualifier-seqopt
& attribute-specifier-seqopt
&& attribute-specifier-seqopt
::opt nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt
cv-qualifier-seq:
cv-qualifier cv-qualifier-seqopt
cv-qualifier:
const
volatile
ref-qualifier:
&
&&
declarator-id:
...opt id-expression
::opt nested-name-specifieropt class-name
A class-name has special meaning in a declaration of the class of that name and when qualified by that
name using the scope resolution operator :: (5.1, 12.1, 12.4).
5 The optional attribute-specifier-seq in a trailing-return-type appertains to the indicated return type. The
type-id in a trailing-return-type includes the longest possible sequence of abstract-declarators. [ Note: This
resolves the ambiguous binding of array and function declarators. [ Example:
auto f()->int(*)[4]; // function returning a pointer to array[4] of int
// not function returning array[4] of pointer to int
— end example ] — end note ]
8.1 Type names [dcl.name]
1 To specify type conversions explicitly, and as an argument of sizeof, alignof, new, or typeid, the name of
a type shall be specified. This can be done with a type-id, which is syntactically a declaration for a variable
or function of that type that omits the name of the entity.
type-id:
type-specifier-seq abstract-declaratoropt
abstract-declarator:
ptr-abstract-declarator
noptr-abstract-declaratoropt parameters-and-qualifiers trailing-return-type
...
ptr-abstract-declarator:
noptr-abstract-declarator
ptr-operator ptr-abstract-declaratoropt
noptr-abstract-declarator:
noptr-abstract-declaratoropt parameters-and-qualifiers
noptr-abstract-declaratoropt[ constant-expression ] attribute-specifier-seqopt
( ptr-abstract-declarator )
It is possible to identify uniquely the location in the abstract-declarator where the identifier would appear
if the construction were a declarator in a declaration. The named type is then the same as the type of the
hypothetical identifier. [ Example:
int // int i
int * // int *pi
int *[3] // int *p[3]
§ 8.1 181

 c ISO/IEC N3242=11-0012
int (*)[3] // int (*p3i)[3]
int *() // int *f()
int (*)(double) // int (*pf)(double)
name respectively the types “int,” “pointer to int,” “array of 3 pointers to int,” “pointer to array of 3 int,”
“function of (no parameters) returning pointer to int,” and “pointer to a function of (double) returning
int.” — end example ]
2 A type can also be named (often more easily) by using a typedef (7.1.3).
8.2 Ambiguity resolution [dcl.ambig.res]
1 The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8
can also occur in the context of a declaration. In that context, the choice is between a function declaration
with a redundant set of parentheses around a parameter name and an object declaration with a function-style
cast as the initializer. Just as for the ambiguities mentioned in 6.8, the resolution is to consider any construct
that could possibly be a declaration a declaration. [ Note: A declaration can be explicitly disambiguated by
a nonfunction-style cast, by an = to indicate initialization or by removing the redundant parentheses around
the parameter name. — end note ] [ Example:
struct S {
S(int);
};
void foo(double a) {
S w(int(a)); // function declaration
S x(int()); // function declaration
S y((int)a); // object declaration
S z = int(a); // object declaration
}
— end example ]
2 The ambiguity arising from the similarity between a function-style cast and a type-id can occur in different
contexts. The ambiguity appears as a choice between a function-style cast expression and a declaration of a
type. The resolution is that any construct that could possibly be a type-id in its syntactic context shall be
considered a type-id.
3 [ Example:
#include <cstddef>
char *p;
void *operator new(std::size_t, int);
void foo() {
const int x = 63;
new (int(*p)) int; // new-placement expression
new (int(*[x])); // new type-id
}
4 For another example,
template <class T>
struct S {
T *p;
};
S<int()> x; // type-id
S<int(1)> y; // expression (ill-formed)
§ 8.2 182

 c ISO/IEC N3242=11-0012
5 For another example,
void foo() {
sizeof(int(1)); // expression
sizeof(int()); // type-id (ill-formed)
}
6 For another example,
void foo() {
(int(1)); // expression
(int())1; // type-id (ill-formed)
}
— end example ]
7 Another ambiguity arises in a parameter-declaration-clause of a function declaration, or in a type-id that
is the operand of a sizeof or typeid operator, when a type-name is nested in parentheses. In this case,
the choice is between the declaration of a parameter of type pointer to function and the declaration of a
parameter with redundant parentheses around the declarator-id. The resolution is to consider the type-name
as a simple-type-specifier rather than a declarator-id. [ Example:
class C { };
void f(int(C)) { } // void f(int(*fp)(C c)) { }
// not: void f(int C);
int g(C);
void foo() {
f(1); // error: cannot convert 1 to function pointer
f(g); // OK
}
For another example,
class C { };
void h(int *(C[10])); // void h(int *(*_fp)(C _parm[10]));
// not: void h(int *C[10]);
— end example ]
8.3 Meaning of declarators [dcl.meaning]
1 A list of declarators appears after an optional (Clause 7) decl-specifier-seq (7.1). Each declarator contains
exactly one declarator-id; it names the identifier that is declared. An unqualified-id occurring in a declaratorid shall be a simple identifier except for the declaration of some special functions (12.3, 12.4, 13.5) and for
the declaration of template specializations or partial specializations (14.7). A declarator-id shall not be
qualified except for the definition of a member function (9.3) or static data member (9.4) outside of its
class, the definition or explicit instantiation of a function or variable member of a namespace outside of its
namespace, or the definition of an explicit specialization outside of its namespace, or the declaration of a
friend function that is a member of another class or namespace (11.3). When the declarator-id is qualified,
the declaration shall refer to a previously declared member of the class or namespace to which the qualifier
refers (or, in the case of a namespace, of an element of the inline namespace set of that namespace (7.3.1))
or to a specialization thereof; the member shall not merely have been introduced by a using-declaration
in the scope of the class or namespace nominated by the nested-name-specifier of the declarator-id. The
nested-name-specifier of a qualified declarator-id shall not begin with a decltype-specifier. [ Note: If the
§ 8.3 183

 c ISO/IEC N3242=11-0012
qualifier is the global :: scope resolution operator, the declarator-id refers to a name declared in the global
namespace scope. — end note ] The optional attribute-specifier-seq following a declarator-id appertains to
the entity that is declared.
2 A static, thread_local, extern, register, mutable, friend, inline, virtual, or typedef specifier applies directly to each declarator-id in an init-declarator-list; the type specified for each declarator-id depends
on both the decl-specifier-seq and its declarator.
3 Thus, a declaration of a particular identifier has the form
T D
where T is of the form attribute-specifier-seqopt decl-specifier-seq and D is a declarator. Following is a
recursive procedure for determining the type specified for the contained declarator-id by such a declaration.
4 First, the decl-specifier-seq determines a type. In a declaration
T D
the decl-specifier-seq T determines the type T. [ Example: in the declaration
int unsigned i;
the type specifiers int unsigned determine the type “unsigned int” (7.1.6.2). — end example ]
5 In a declaration attribute-specifier-seqopt T D where D is an unadorned identifier the type of this identifier is
“T”.
6 In a declaration T D where D has the form
( D1 )
the type of the contained declarator-id is the same as that of the contained declarator-id in the declaration
T D1
Parentheses do not alter the type of the embedded declarator-id, but they can alter the binding of complex
declarators.
8.3.1 Pointers [dcl.ptr]
1 In a declaration T D where D has the form
* attribute-specifier-seqopt cv-qualifier-seqoptD1
and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T,” then the type of
the identifier of D is “derived-declarator-type-list cv-qualifier-seq pointer to T.” The cv-qualifiers apply to the
pointer and not to the object pointed to. Similarly, the optional attribute-specifier-seq (7.6.1) appertains to
the pointer and not to the object pointed to.
2 [ Example: the declarations
const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
int i, *p, *const cp = &i;
declare ci, a constant integer; pc, a pointer to a constant integer; cpc, a constant pointer to a constant
integer; ppc, a pointer to a pointer to a constant integer; i, an integer; p, a pointer to integer; and cp, a
constant pointer to integer. The value of ci, cpc, and cp cannot be changed after initialization. The value
of pc can be changed, and so can the object pointed to by cp. Examples of some correct operations are
§ 8.3.1 184

 c ISO/IEC N3242=11-0012
i = ci;
*cp = ci;
pc++;
pc = cpc;
pc = p;
ppc = &pc;
Examples of ill-formed operations are
ci = 1; // error
ci++; // error
*pc = 2; // error
cp = &ci; // error
cpc++; // error
p = pc; // error
ppc = &p; // error
Each is unacceptable because it would either change the value of an object declared const or allow it to be
changed through a cv-unqualified pointer later, for example:
*ppc = &ci; // OK, but would make p point to ci ...
// ... because of previous error
*p = 5; // clobber ci
— end example ]
3 See also 5.17 and 8.5.
4 [ Note: There are no pointers to references; see 8.3.2. Since the address of a bit-field (9.6) cannot be taken,
a pointer can never point to a bit-field. — end note ]
8.3.2 References [dcl.ref]
1 In a declaration T D where D has either of the forms
& attribute-specifier-seqoptD1
&& attribute-specifier-seqoptD1
and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T,” then the type of the
identifier of D is “derived-declarator-type-list reference to T.” The optional attribute-specifier-seq appertains
to the reference type. Cv-qualified references are ill-formed except when the cv-qualifiers are introduced
through the use of a typedef (7.1.3) or of a template type argument (14.3), in which case the cv-qualifiers
are ignored. [ Example:
typedef int& A;
const A aref = 3; // ill-formed; lvalue reference to non-const initialized with rvalue
The type of aref is “lvalue reference to int”, not “lvalue reference to const int”. — end example ] [ Note:
A reference can be thought of as a name of an object. — end note ] A declarator that specifies the type
“reference to cv void” is ill-formed.
2 A reference type that is declared using & is called an lvalue reference, and a reference type that is declared
using && is called an rvalue reference. Lvalue references and rvalue references are distinct types. Except
where explicitly noted, they are semantically equivalent and commonly referred to as references.
3 [ Example:
§ 8.3.2 185

 c ISO/IEC N3242=11-0012
void f(double& a) { a += 3.14; }
// ...
double d = 0;
f(d);
declares a to be a reference parameter of f so the call f(d) will add 3.14 to d.
int v[20];
// ...
int& g(int i) { return v[i]; }
// ...
g(3) = 7;
declares the function g() to return a reference to an integer so g(3)=7 will assign 7 to the fourth element
of the array v. For another example,
struct link {
link* next;
};
link* first;
void h(link*& p) { // p is a reference to pointer
p->next = first;
first = p;
p = 0;
}
void k() {
link* q = new link;
h(q);
}
declares p to be a reference to a pointer to link so h(q) will leave q with the value zero. See also 8.5.3.
— end example ]
4 It is unspecified whether or not a reference requires storage (3.7).
5 There shall be no references to references, no arrays of references, and no pointers to references. The
declaration of a reference shall contain an initializer (8.5.3) except when the declaration contains an explicit
extern specifier (7.1.1), is a class member (9.2) declaration within a class definition, or is the declaration
of a parameter or a return type (8.3.5); see 3.1. A reference shall be initialized to refer to a valid object
or function. [ Note: in particular, a null reference cannot exist in a well-defined program, because the only
way to create such a reference would be to bind it to the “object” obtained by dereferencing a null pointer,
which causes undefined behavior. As described in 9.6, a reference cannot be bound directly to a bit-field.
— end note ]
6 If a typedef (7.1.3), a type template-parameter (14.3.1), or a decltype-specifier (7.1.6.2) denotes a type TR
that is a reference to a type T, an attempt to create the type “lvalue reference to cv TR” creates the type
“lvalue reference to T”, while an attempt to create the type “rvalue reference to cv TR” creates the type TR.
[ Example:
int i;
typedef int& LRI;
typedef int&& RRI;
§ 8.3.2 186

 c ISO/IEC N3242=11-0012
LRI& r1 = i; // r1 has the type int&
const LRI& r2 = i; // r2 has the type int&
const LRI&& r3 = i; // r3 has the type int&
RRI& r4 = i; // r4 has the type int&
RRI&& r5 = i; // r5 has the type int&&
decltype(r2)& r6 = i; // r6 has the type int&
decltype(r2)&& r7 = i; // r7 has the type int&
— end example ]
8.3.3 Pointers to members [dcl.mptr]
1 In a declaration T D where D has the form
::opt nested-name-specifier * attribute-specifier-seqopt cv-qualifier-seqopt D1
and the nested-name-specifier denotes a class, and the type of the identifier in the declaration T D1 is “deriveddeclarator-type-list T”, then the type of the identifier of D is “derived-declarator-type-list cv-qualifier-seq pointer
to member of class nested-name-specifier of type T”. The optional attribute-specifier-seq (7.6.1) appertains to
the pointer-to-member.
2 [ Example:
struct X {
void f(int);
int a;
};
struct Y;
int X::* pmi = &X::a;
void (X::* pmf)(int) = &X::f;
double X::* pmd;
char Y::* pmc;
declares pmi, pmf, pmd and pmc to be a pointer to a member of X of type int, a pointer to a member of
X of type void(int), a pointer to a member of X of type double and a pointer to a member of Y of type
char respectively. The declaration of pmd is well-formed even though X has no members of type double.
Similarly, the declaration of pmc is well-formed even though Y is an incomplete type. pmi and pmf can be
used like this:
X obj;
// ...
obj.*pmi = 7; // assign 7 to an integer
// member of obj
(obj.*pmf)(7); // call a function member of obj
// with the argument 7
— end example ]
3 A pointer to member shall not point to a static member of a class (9.4), a member with reference type, or
“cv void.”
§ 8.3.3 187

 c ISO/IEC N3242=11-0012
[ Note: See also 5.3 and 5.5. The type “pointer to member” is distinct from the type “pointer”, that is, a
pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer
declarator syntax. There is no “reference-to-member” type in C++. — end note ]
8.3.4 Arrays [dcl.array]
1 In a declaration T D where D has the form
D1 [ constant-expressionopt] attribute-specifier-seqopt
and the type of the identifier in the declaration T D1 is “derived-declarator-type-list T”, then the type of the
identifier of D is an array type; if the type of the identifier of D contains the auto type-specifier, the program
is ill-formed. T is called the array element type; this type shall not be a reference type, the (possibly cvqualified) type void, a function type or an abstract class type. If the constant-expression (5.19) is present,
it shall be an integral constant expression and its value shall be greater than zero. The constant expression
specifies the bound of (number of elements in) the array. If the value of the constant expression is N, the array
has N elements numbered 0 to N-1, and the type of the identifier of D is “derived-declarator-type-list array of N
T”. An object of array type contains a contiguously allocated non-empty set of N subobjects of type T. Except
as noted below, if the constant expression is omitted, the type of the identifier of D is “derived-declarator-typelist array of unknown bound of T”, an incomplete object type. The type “derived-declarator-type-list array of
N T” is a different type from the type “derived-declarator-type-list array of unknown bound of T”, see 3.9. Any
type of the form “cv-qualifier-seq array of N T” is adjusted to “array of N cv-qualifier-seq T”, and similarly for
“array of unknown bound of T”. The optional attribute-specifier-seq appertains to the array. [ Example:
typedef int A[5], AA[2][3];
typedef const A CA; // type is “array of 5 const int”
typedef const AA CAA; // type is “array of 2 array of 3 const int”
— end example ] [ Note: An “array of N cv-qualifier-seq T” has cv-qualified type; see 3.9.3. — end note ]
2 An array can be constructed from one of the fundamental types (except void), from a pointer, from a pointer
to member, from a class, from an enumeration type, or from another array.
3 When several “array of” specifications are adjacent, a multidimensional array is created; only the first of the
constant expressions that specify the bounds of the arrays may be omitted. In addition to declarations in
which an incomplete object type is allowed, an array bound may be omitted in some cases in the declaration
of a function parameter (8.3.5). An array bound may also be omitted when the declarator is followed by an
initializer (8.5). In this case the bound is calculated from the number of initial elements (say, N) supplied
(8.5.1), and the type of the identifier of D is “array of N T.” Furthermore, if there is a preceding declaration
of the entity in the same scope in which the bound was specified, an omitted array bound is taken to be the
same as in that earlier declaration, and similarly for the definition of a static data member of a class.
4 [ Example:
float fa[17], *afp[17];
declares an array of float numbers and an array of pointers to float numbers. For another example,
static int x3d[3][5][7];
declares a static three-dimensional array of integers, with rank 3 × 5 × 7. In complete detail, x3d is an array
of three items; each item is an array of five arrays; each of the latter arrays is an array of seven integers.
Any of the expressions x3d, x3d[i], x3d[i][j], x3d[i][j][k] can reasonably appear in an expression.
Finally,
§ 8.3.4 188

 c ISO/IEC N3242=11-0012
extern int x[10];
struct S {
static int y[10];
};
int x[]; // OK: bound is 10
int S::y[]; // OK: bound is 10
void f() {
extern int x[];
int i = sizeof(x); // error: incomplete object type
}
— end example ]
5 [ Note: conversions affecting expressions of array type are described in 4.2. Objects of array types cannot
be modified, see 3.10. — end note ]
6 [ Note: Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such
a way that E1[E2] is identical to *((E1)+(E2)). Because of the conversion rules that apply to +, if E1 is an
array and E2 an integer, then E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric
appearance, subscripting is a commutative operation.
7 A consistent rule is followed for multidimensional arrays. If E is an n-dimensional array of rank i×j×...×k,
then E appearing in an expression that is subject to the array-to-pointer conversion (4.2) is converted to a
pointer to an (n−1)-dimensional array with rank j ×...×k. If the * operator, either explicitly or implicitly
as a result of subscripting, is applied to this pointer, the result is the pointed-to (n − 1)-dimensional array,
which itself is immediately converted into a pointer.
8 [ Example: consider
int x[3][5];
Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the
first of three) five-membered arrays of integers. In the expression x[i] which is equivalent to *(x+i), x is
first converted to a pointer as described; then x+i is converted to the type of x, which involves multiplying
i by the length of the object to which the pointer points, namely five integer objects. The results are added
and indirection applied to yield an array (of five integers), which in turn is converted to a pointer to the
first of the integers. If there is another subscript the same argument applies again; this time the result is an
integer. — end example ] — end note ]
9 [ Note: It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that
the first subscript in the declaration helps determine the amount of storage consumed by an array but plays
no other part in subscript calculations. — end note ]
8.3.5 Functions [dcl.fct]
1 In a declaration T D where D has the form
D1 ( parameter-declaration-clause ) attribute-specifier-seqopt cv-qualifier-seqopt
ref-qualifieropt exception-specificationopt attribute-specifier-seqopt
and the type of the contained declarator-id in the declaration T D1 is “derived-declarator-type-list T”, the
type of the declarator-id in D is “derived-declarator-type-list function of (parameter-declaration-clause ) cv-qualifierseqopt ref-qualifieropt returning T”. The optional attribute-specifier-seq appertains to the function type.
2 In a declaration T D where D has the form
§ 8.3.5 189

 c ISO/IEC N3242=11-0012
D1 ( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt exception-specificationopt attribute-specifier-seqopt trailing-return-type
and the type of the contained declarator-id in the declaration T D1 is “derived-declarator-type-list T”, T
shall be the single type-specifier auto. The type of the declarator-id in D is “derived-declarator-type-list
function of (parameter-declaration-clause) cv-qualifier-seqopt ref-qualifieropt returning trailing-return-type”.
The optional attribute-specifier-seq appertains to the function type.
3 A type of either form is a function type.98
parameter-declaration-clause:
parameter-declaration-listopt...opt
parameter-declaration-list , ...
parameter-declaration-list:
parameter-declaration
parameter-declaration-list , parameter-declaration
parameter-declaration:
attribute-specifier-seqopt decl-specifier-seq declarator
attribute-specifier-seqopt decl-specifier-seq declarator = initializer-clause
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt
attribute-specifier-seqopt decl-specifier-seq abstract-declaratoropt= initializer-clause
The optional attribute-specifier-seq in a parameter-declaration appertains to the parameter.
4 The parameter-declaration-clause determines the arguments that can be specified, and their processing, when
the function is called. [ Note: the parameter-declaration-clause is used to convert the arguments specified
on the function call; see 5.2.2. — end note ] If the parameter-declaration-clause is empty, the function
takes no arguments. The parameter list (void) is equivalent to the empty parameter list. Except for this
special case, void shall not be a parameter type (though types derived from void, such as void*, can).
If the parameter-declaration-clause terminates with an ellipsis or a function parameter pack (14.5.3), the
number of arguments shall be equal to or greater than the number of parameters that do not have a default
argument and are not function parameter packs. Where syntactically correct and where “...” is not part of
an abstract-declarator, “, ...” is synonymous with “...”. [ Example: the declaration
int printf(const char*, ...);
declares a function that can be called with varying numbers and types of arguments.
printf("hello world");
printf("a=%d b=%d", a, b);
However, the first argument must be of a type that can be converted to a const char* — end example ]
[ Note: The standard header <cstdarg> contains a mechanism for accessing arguments passed using the
ellipsis (see 5.2.2 and 18.10). — end note ]
5 A single name can be used for several different functions in a single scope; this is function overloading
(Clause 13). All declarations for a function shall agree exactly in both the return type and the parametertype-list. The type of a function is determined using the following rules. The type of each parameter
(including function parameter packs) is determined from its own decl-specifier-seq and declarator. After
determining the type of each parameter, any parameter of type “array of T” or “function returning T” is
adjusted to be “pointer to T” or “pointer to function returning T,” respectively. After producing the list
of parameter types, any top-level cv-qualifiers modifying a parameter type are deleted when forming the
function type. The resulting list of transformed parameter types and the presence or absence of the ellipsis
or a function parameter pack is the function’s parameter-type-list. [ Note: This transformation does not
98) As indicated by syntax, cv-qualifiers are a signficant component in function return types.
§ 8.3.5 190

 c ISO/IEC N3242=11-0012
affect the types of the parameters. For example, int(*)(const int p, decltype(p)*) and int(*)(int,
const int*) are identical types. — end note ]
6 A cv-qualifier-seq shall only be part of the function type for a non-static member function, the function type
to which a pointer to member refers, or the top-level function type of a function typedef declaration. [ Note:
A function type that has a cv-qualifier-seq is not a cv-qualified type; there are no cv-qualified function types.
— end note ] The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification
on top of the function type. In the latter case, the cv-qualifiers are ignored. [ Example:
typedef void F();
struct S {
const F f; // OK: equivalent to: void f();
};
— end example ] A ref-qualifier shall only be part of the function type for a non-static member function,
the function type to which a pointer to member refers, or the top-level function type of a function typedef
declaration. The return type, the parameter-type-list, the ref-qualifier, and the cv-qualifier-seq, but not the
default arguments (8.3.6) or the exception specification (15.4), are part of the function type. [ Note: Function
types are checked during the assignments and initializations of pointer-to-functions, reference-to-functions,
and pointer-to-member-functions. — end note ]
7 [ Example: the declaration
int fseek(FILE*, long, int);
declares a function taking three arguments of the specified types, and returning int (7.1.6). — end example ]
8 If the type of a parameter includes a type of the form “pointer to array of unknown bound of T” or “reference
to array of unknown bound of T,” the program is ill-formed.99 Functions shall not have a return type of
type array or function, although they may have a return type of type pointer or reference to such things.
There shall be no arrays of functions, although there can be arrays of pointers to functions.
9 Types shall not be defined in return or parameter types. The type of a parameter or the return type for a
function definition shall not be an incomplete class type (possibly cv-qualified) unless the function definition
is nested within the member-specification for that class (including definitions in nested classes defined within
the class).
10 A typedef of function type may be used to declare a function but shall not be used to define a function (8.4).
[ Example:
typedef void F();
F fv; // OK: equivalent to void fv();
F fv { } // ill-formed
void fv() { } // OK: definition of fv
— end example ] A typedef of a function type whose declarator includes a cv-qualifier-seq shall be used
only to declare the function type for a non-static member function, to declare the function type to which a
pointer to member refers, or to declare the top-level function type of another function typedef declaration.
[ Example:
typedef int FIC(int) const;
FIC f; // ill-formed: does not declare a member function
struct S {
99) This excludes parameters of type “ptr-arr-seq T2” where T2 is “pointer to array of unknown bound of T” and where ptrarr-seq means any sequence of “pointer to” and “array of” derived declarator types. This exclusion applies to the parameters
of the function, and if a parameter is a pointer to function or pointer to member function then to its parameters also, etc.
§ 8.3.5 191

 c ISO/IEC N3242=11-0012
FIC f; // OK
};
FIC S::*pm = &S::f; // OK
— end example ]
11 An identifier can optionally be provided as a parameter name; if present in a function definition (8.4), it
names a parameter (sometimes called “formal argument”). [ Note: In particular, parameter names are also
optional in function definitions and names used for a parameter in different declarations and the definition
of a function need not be the same. If a parameter name is present in a function declaration that is not
a definition, it cannot be used outside of its function declarator because that is the extent of its potential
scope (3.3.4). — end note ]
12 [ Example: the declaration
int i,
*pi,
f(),
*fpi(int),
(*pif)(const char*, const char*),
(*fpif(int))(int);
declares an integer i, a pointer pi to an integer, a function f taking no arguments and returning an integer,
a function fpi taking an integer argument and returning a pointer to an integer, a pointer pif to a function
which takes two pointers to constant characters and returns an integer, a function fpif taking an integer
argument and returning a pointer to a function that takes an integer argument and returns an integer. It
is especially useful to compare fpi and pif. The binding of *fpi(int) is *(fpi(int)), so the declaration
suggests, and the same construction in an expression requires, the calling of a function fpi, and then using
indirection through the (pointer) result to yield an integer. In the declarator (*pif)(const char*, const
char*), the extra parentheses are necessary to indicate that indirection through a pointer to a function yields
a function, which is then called. — end example ] [ Note: Typedefs and trailing-return-types are sometimes
convenient when the return type of a function is complex. For example, the function fpif above could have
been declared
typedef int IFUNC(int);
IFUNC* fpif(int);
or
auto fpif(int)->int(*)(int)
A trailing-return-type is most useful for a type that would be more complicated to specify before the
declarator-id:
template <class T, class U> auto add(T t, U u) -> decltype(t + u);
rather than
template <class T, class U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);
— end note ]
13 A declarator-id or abstract-declarator containing an ellipsis shall only be used in a parameter-declaration.
Such a parameter-declaration is a parameter pack (14.5.3). When it is part of a parameter-declaration-clause,
the parameter pack is a function parameter pack (14.5.3). [ Note: Otherwise, the parameter-declaration is
part of a template-parameter-list and the parameter pack is a template parameter pack; see 14.1. — end
§ 8.3.5 192

 c ISO/IEC N3242=11-0012
note ] The type T of the declarator-id of the function parameter pack shall contain a template parameter
pack; each template parameter pack in T is expanded by the function parameter pack. [ Example:
template<typename... T> void f(T (* ...t)(int, int));
int add(int, int);
float subtract(int, int);
void g() {
f(add, subtract);
} —
end example ]
14 There is a syntactic ambiguity when an ellipsis occurs at the end of a parameter-declaration-clause without
a preceding comma. In this case, the ellipsis is parsed as part of the abstract-declarator if the type of the
parameter names a template parameter pack that has not been expanded; otherwise, it is parsed as part of
the parameter-declaration-clause.100
8.3.6 Default arguments [dcl.fct.default]
1 If an initializer-clause is specified in a parameter-declaration this initializer-clause is used as a default
argument. Default arguments will be used in calls where trailing arguments are missing.
2 [ Example: the declaration
void point(int = 3, int = 4);
declares a function that can be called with zero, one, or two arguments of type int. It can be called in any
of these ways:
point(1,2); point(1); point();
The last two calls are equivalent to point(1,4) and point(3,4), respectively. — end example ]
3 A default argument shall be specified only in the parameter-declaration-clause of a function declaration or
in a template-parameter (14.1); in the latter case, the initializer-clause shall be an assignment-expression.
A default argument shall not be specified for a parameter pack. If it is specified in a parameter-declarationclause, it shall not occur within a declarator or abstract-declarator of a parameter-declaration.101
4 For non-template functions, default arguments can be added in later declarations of a function in the
same scope. Declarations in different scopes have completely distinct sets of default arguments. That is,
declarations in inner scopes do not acquire default arguments from declarations in outer scopes, and vice
versa. In a given function declaration, each parameter subsequent to a parameter with a default argument
shall have a default argument supplied in this or a previous declaration or shall be a function parameter pack.
A default argument shall not be redefined by a later declaration (not even to the same value). [ Example:
void g(int = 0, ...); // OK, ellipsis is not a parameter so it can follow
// a parameter with a default argument
void f(int, int);
void f(int, int = 7);
void h() {
100) One can explicitly disambiguate the parse either by introducing a comma (so the ellipsis will be parsed as part of the
parameter-declaration-clause) or by introducing a name for the parameter (so the ellipsis will be parsed as part of the declaratorid).
101) This means that default arguments cannot appear, for example, in declarations of pointers to functions, references to
functions, or typedef declarations.
§ 8.3.6 193

 c ISO/IEC N3242=11-0012
f(3); // OK, calls f(3, 7)
void f(int = 1, int); // error: does not use default
// from surrounding scope
}
void m() {
void f(int, int); // has no defaults
f(4); // error: wrong number of arguments
void f(int, int = 5); // OK
f(4); // OK, calls f(4, 5);
void f(int, int = 5); // error: cannot redefine, even to
// same value
}
void n() {
f(6); // OK, calls f(6, 7)
} —
end example ] For a given inline function defined in different translation units, the accumulated sets of
default arguments at the end of the translation units shall be the same; see 3.2. If a friend declaration specifies
a default argument expression, that declaration shall be a definition and shall be the only declaration of the
function or function template in the translation unit.
5 A default argument is implicitly converted (Clause 4) to the parameter type. The default argument has
the same semantic constraints as the initializer in a declaration of a variable of the parameter type, using
the copy-initialization semantics (8.5). The names in the default argument are bound, and the semantic
constraints are checked, at the point where the default argument appears. Name lookup and checking of
semantic constraints for default arguments in function templates and in member functions of class templates
are performed as described in 14.7.1. [ Example: in the following code, g will be called with the value f(2):
int a = 1;
int f(int);
int g(int x = f(a)); // default argument: f(::a)
void h() {
a = 2;
{
int a = 3;
g(); // g(f(::a))
}
}
— end example ] [ Note: In member function declarations, names in default arguments are looked up as
described in 3.4.1. Access checking applies to names in default arguments as described in Clause 11. — end
note ]
6 Except for member functions of class templates, the default arguments in a member function definition that
appears outside of the class definition are added to the set of default arguments provided by the member
function declaration in the class definition. Default arguments for a member function of a class template
shall be specified on the initial declaration of the member function within the class template. [ Example:
class C {
void f(int i = 3);
void g(int i, int j = 99);
};
void C::f(int i = 3) { // error: default argument already
§ 8.3.6 194

 c ISO/IEC N3242=11-0012
} // specified in class scope
void C::g(int i = 88, int j) { // in this translation unit,
} // C::g can be called with no argument
— end example ]
7 Local variables shall not be used in a default argument. [ Example:
void f() {
int i;
extern void g(int x = i); //error
// ...
}
— end example ]
8 The keyword this shall not be used in a default argument of a member function. [ Example:
class A {
void f(A* p = this) { } // error
};
— end example ]
9 Default arguments are evaluated each time the function is called. The order of evaluation of function
arguments is unspecified. Consequently, parameters of a function shall not be used in a default argument,
even if they are not evaluated. Parameters of a function declared before a default argument are in scope
and can hide namespace and class member names. [ Example:
int a;
int f(int a, int b = a); // error: parameter a
// used as default argument
typedef int I;
int g(float I, int b = I(2)); // error: parameter I found
int h(int a, int b = sizeof(a)); // error, parameter a used
// in default argument
— end example ] Similarly, a non-static member shall not be used in a default argument, even if it is not
evaluated, unless it appears as the id-expression of a class member access expression (5.2.5) or unless it is
used to form a pointer to member (5.3.1). [ Example: the declaration of X::mem1() in the following example
is ill-formed because no object is supplied for the non-static member X::a used as an initializer.
int b;
class X {
int a;
int mem1(int i = a); // error: non-static member a
// used as default argument
int mem2(int i = b); // OK; use X::b
static int b;
};
The declaration of X::mem2() is meaningful, however, since no object is needed to access the static member
X::b. Classes, objects, and members are described in Clause 9. — end example ] A default argument is not
part of the type of a function. [ Example:
int f(int = 0);
§ 8.3.6 195

 c ISO/IEC N3242=11-0012
void h() {
int j = f(1);
int k = f(); // OK, means f(0)
}
int (*p1)(int) = &f;
int (*p2)() = &f; // error: type mismatch
— end example ] When a declaration of a function is introduced by way of a using-declaration (7.3.3), any
default argument information associated with the declaration is made known as well. If the function is
redeclared thereafter in the namespace with additional default arguments, the additional arguments are also
known at any point following the redeclaration where the using-declaration is in scope.
10 A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined
by the static type of the pointer or reference denoting the object. An overriding function in a derived class
does not acquire default arguments from the function it overrides. [ Example:
struct A {
virtual void f(int a = 7);
};
struct B : public A {
void f(int a);
};
void m() {
B* pb = new B;
A* pa = pb;
pa->f(); // OK, calls pa->B::f(7)
pb->f(); // error: wrong number of arguments for B::f()
}
— end example ]
8.4 Function definitions [dcl.fct.def]
8.4.1 In general [dcl.fct.def.general]
1 Function definitions have the form
function-definition:
attribute-specifier-seqopt decl-specifier-seqopt declarator function-body
attribute-specifier-seqopt decl-specifier-seqopt declarator = default ;
attribute-specifier-seqopt decl-specifier-seqopt declarator = delete ;
function-body:
ctor-initializer
opt compound-statement
function-try-block
Any informal reference to the body of a function should be interpreted as a reference to the non-terminal
function-body. The optional attribute-specifier-seq in a function-definition appertains to the function.
2 The declarator in a function-definition shall have the form
D1 ( parameter-declaration-clause ) cv-qualifier-seqopt
ref-qualifieropt exception-specificationopt attribute-specifier-seqopt trailing-return-typeopt
as described in 8.3.5. A function shall be defined only in namespace or class scope.
3 [ Example: a simple example of a complete function definition is
§ 8.4.1 196

 c ISO/IEC N3242=11-0012
int max(int a, int b, int c) {
int m = (a > b) ? a : b;
return (m > c) ? m : c;
}
Here int is the decl-specifier-seq; max(int a, int b, int c) is the declarator; { /* ... */ } is the
function-body. — end example ]
4 A ctor-initializer is used only in a constructor; see 12.1 and 12.6.
5 A cv-qualifier-seq or a ref-qualifier (or both) can be part of a non-static member function declaration,
non-static member function definition, or pointer to member function only (8.3.5); see 9.3.2.
6 [ Note: Unused parameters need not be named. For example,
void print(int a, int) {
std::printf("a = %d\n",a);
} —
end note ]
7 In the function-body, a function-local predefined variable denotes a block-scope object of static storage duration that is implicitly defined (see 3.3.3).
8 The function-local predefined variable __func__ is defined as if a definition of the form
static const char __func__[] = "function-name ";
had been provided, where function-name is an implementation-defined string. It is unspecified whether such
a variable has an address distinct from that of any other object in the program.102
[ Example:
struct S {
S() : s(__func__) { } // OK
const char *s;
};
void f(const char * s = __func__); // error: __func__ is undeclared
— end example ]
8.4.2 Explicitly-defaulted functions [dcl.fct.def.default]
1 A function definition of the form:
attribute-specifier-seqopt decl-specifier-seqopt declarator = default ;
is called an explicitly-defaulted definition. A function that is explicitly defaulted shall
— be a special member function,
— have the same declared function type (except for possibly differing ref-qualifiers and except that in
the case of a copy constructor or copy assignment operator, the parameter type may be “reference to
non-const T”, where T is the name of the member function’s class) as if it had been implicitly declared,
— not have default arguments, and
102) Implementations are permitted to provide additional predefined variables with names that are reserved to the implementation (17.6.4.3.2). If a predefined variable is not odr-used (3.2), its string value need not be present in the program image.
§ 8.4.2 197

 c ISO/IEC N3242=11-0012
— not have an exception-specification.
[ Note: This implies that parameter types, return type, and cv-qualifiers must match the hypothetical implicit
declaration. — end note ]
2 An explicitly-defaulted function may be declared constexpr only if it would have been implicitly declared
as constexpr. If it is explicitly defaulted on its first declaration,
— it shall be public,
— it shall not be explicit,
— it shall not be virtual,
— it is implicitly considered to have the same exception-specification as if it had been implicitly declared (15.4), and
— in the case of a copy constructor, move constructor, copy assignment operator, or move assignment
operator, it shall have the same parameter type as if it had been implicitly declared.
3 [ Note: Such a special member function may be trivial, and thus its accessibility and explicitness should
match the hypothetical implicit definition; see below. — end note ] [ Example:
struct S {
S(int a = 0) = default; // ill-formed: default argument
void operator=(const S&) = default; // ill-formed: non-matching return type
~S() throw() = default; // ill-formed: exception specification
private:
S(S&); // OK: private copy constructor
};
S::S(S&) = default; // OK: defines copy constructor
— end example ]
4 Explicitly-defaulted functions and implicitly-declared functions are collectively called defaulted functions,
and the implementation shall provide implicit definitions for them (12.1 12.4, 12.8), which might mean
defining them as deleted. A special member function is user-provided if it is user-declared and not explicitly
defaulted on its first declaration. A user-provided explicitly-defaulted function (i.e., explicitly defaulted after
its first declaration) is defined at the point where it is explicitly defaulted; if such a function is implicitly
defined as deleted, the program is ill-formed. [ Note: While an implicitly-declared special member function
is inline (Clause 12), an explicitly-defaulted definition may be non-inline. Non-inline definitions are userprovided, and hence non-trivial (12.1, 12.4, 12.8). This rule enables efficient execution and concise definition
while enabling a stable binary interface to an evolving code base. — end note ]
5 [ Example:
struct trivial {
trivial() = default;
trivial(const trivial&) = default;
trivial(trivial&&) = default;
trivial& operator=(const trivial&) = default;
trivial& operator=(trivial&&) = default;
~trivial() = default;
};
struct nontrivial1 {
nontrivial1();
};
§ 8.4.2 198

 c ISO/IEC N3242=11-0012
nontrivial1::nontrivial1() = default; // not inline
struct nontrivial2 {
nontrivial2();
};
inline nontrivial2::nontrivial2() = default; // not first declaration
struct nontrivial3 {
virtual ~nontrivial3() = 0; // virtual
};
inline nontrivial3::~nontrivial3() = default; // not first declaration
— end example ]
8.4.3 Deleted definitions [dcl.fct.def.delete]
1 A function definition of the form:
attribute-specifier-seqopt decl-specifier-seqopt declarator = delete ;
is called a deleted definition. A function with a deleted definition is also called a deleted function.
2 A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.
[ Note: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member
to the function. It applies even for references in expressions that are not potentially-evaluated. If a function
is overloaded, it is referenced only if the function is selected by overload resolution. — end note ]
3 [ Example: One can enforce non-default initialization and non-integral initialization with
struct sometype {
sometype() = delete; // OK, but redundant
some_type(std::intmax_t) = delete;
some_type(double);
};
— end example ]
[ Example: One can prevent use of a class in certain new expressions by using deleted definitions of a userdeclared operator new for that class.
struct sometype {
void *operator new(std::size_t) = delete;
void *operator new[](std::size_t) = delete;
};
sometype *p = new sometype; // error, deleted class operator new
sometype *q = new sometype[3]; // error, deleted class operator new[]
— end example ]
[ Example: One can make a class uncopyable, i.e. move-only, by using deleted definitions of the copy
constructor and copy assignment operator, and then providing defaulted definitions of the move constructor
and move assignment operator.
struct moveonly {
moveonly() = default;
moveonly(const moveonly&) = delete;
moveonly(moveonly&&) = default;
§ 8.4.3 199

 c ISO/IEC N3242=11-0012
moveonly& operator=(const moveonly&) = delete;
moveonly& operator=(moveonly&&) = default;
~moveonly() = default;
};
moveonly *p;
moveonly q(*p); // error, deleted copy constructor
— end example ]
4 A deleted function is implicitly inline. [ Note: The one-definition rule (3.2) applies to deleted definitions.
— end note ] A deleted definition of a function shall be the first declaration of the function or, for an explicit
specialization of a function template, the first declaration of that specialization. [ Example:
struct sometype {
sometype();
};
sometype::sometype() = delete; // ill-formed; not first declaration
— end example ]
8.5 Initializers [dcl.init]
1 A declarator can specify an initial value for the identifier being declared. The identifier designates a variable
being initialized. The process of initialization described in the remainder of 8.5 applies also to initializations specified by other syntactic contexts, such as the initialization of function parameters with argument
expressions (5.2.2) or the initialization of return values (6.6.3).
initializer:
brace-or-equal-initializer
( expression-list )
brace-or-equal-initializer:
= initializer-clause
braced-init-list
initializer-clause:
assignment-expression
braced-init-list
initializer-list:
initializer-clause ...
opt
initializer-list , initializer-clause ...opt
braced-init-list:
{ initializer-list ,opt }
{ }
2 Except for objects declared with the constexpr specifier, for which see 7.1.5, an initializer in the definition
of a variable can consist of arbitrary expressions involving literals and previously declared variables and
functions, regardless of the variable’s storage duration. [ Example:
int f(int);
int a = 2;
int b = f(a);
int c(b);
— end example ]
3 [ Note: Default arguments are more restricted; see 8.3.6.
4 The order of initialization of variables with static storage duration is described in 3.6 and 6.7. — end note ]
§ 8.5 200

 c ISO/IEC N3242=11-0012
5 To zero-initialize an object or reference of type T means:
— if T is a scalar type (3.9), the object is set to the value 0 (zero), taken as an integral constant expression,
converted to T;103
— if T is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class
subobject is zero-initialized and padding is initialized to zero bits;
— if T is a (possibly cv-qualified) union type, the object’s first non-static named data member is zeroinitialized and padding is initialized to zero bits;
— if T is an array type, each element is zero-initialized;
— if T is a reference type, no initialization is performed.
6 To default-initialize an object of type T means:
— if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the
initialization is ill-formed if T has no accessible default constructor);
— if T is an array type, each element is default-initialized;
— otherwise, no initialization is performed.
If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type
with a user-provided default constructor.
7 To value-initialize an object of type T means:
— if T is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the
default constructor for T is called (and the initialization is ill-formed if T has no accessible default
constructor);
— if T is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object
is zero-initialized and, if T’s implicitly-declared default constructor is non-trivial, that constructor is
called.
— if T is an array type, then each element is value-initialized;
— otherwise, the object is zero-initialized.
An object that is value-initialized is deemed to be constructed and thus subject to provisions of this International Standard applying to “constructed” objects, objects “for which the constructor has completed,” etc.,
even if no constructor is invoked for the object’s initialization.
8 A program that calls for default-initialization or value-initialization of an entity of reference type is ill-formed.
9 [ Note: Every object of static storage duration is zero-initialized at program startup before any other initialization takes place. In some cases, additional initialization is done later. — end note ]
10 An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.
[ Note: Since () is not permitted by the syntax for initializer,
X a();
is not the declaration of an object of class X, but the declaration of a function taking no argument and
returning an X. The form () is permitted in certain other initialization contexts (5.3.4, 5.2.3, 12.6.2). — end
note ]
103) As specified in 4.10, converting an integral constant expression whose value is 0 to a pointer type results in a null pointer
value.
§ 8.5 201

 c ISO/IEC N3242=11-0012
11 If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an
object with automatic or dynamic storage duration has indeterminate value. [ Note: Objects with static or
thread storage duration are zero-initialized, see 3.6.2. — end note ]
12 An initializer for a static member is in the scope of the member’s class. [ Example:
int a;
struct X {
static int a;
static int b;
};
int X::a = 1;
int X::b = a; // X::b = X::a
— end example ]
13 The form of initialization (using parentheses or =) is generally insignificant, but does matter when the
initializer or the entity being initialized has a class type; see below. A parenthesized initializer can be a list
of expressions only when the entity being initialized has a class type.
14 The initialization that occurs in the form
T x = a;
as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3),
and aggregate member initialization (8.5.1) is called copy-initialization. [ Note: Copy-initialization may
invoke a move (12.8). — end note ]
15 The initialization that occurs in the forms
T x(a);
T x{a};
as well as in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions
(5.2.3), and base and member initializers (12.6.2) is called direct-initialization.
16 The semantics of initializers are as follows. The destination type is the type of the object or reference being
initialized and the source type is the type of the initializer expression. The source type is not defined when
the initializer is a braced-init-list or when it is a parenthesized list of expressions.
— If the initializer is a braced-init-list, the object is list-initialized (8.5.4).
— If the destination type is a reference type, see 8.5.3.
— If the destination type is an array of characters, an array of char16_t, an array of char32_t, or an
array of wchar_t, and the initializer is a string literal, see 8.5.2.
— If the initializer is (), the object is value-initialized.
— Otherwise, if the destination type is an array, the program is ill-formed.
— If the destination type is a (possibly cv-qualified) class type:
— If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified
version of the source type is the same class as, or a derived class of, the class of the destination,
constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best
one is chosen through overload resolution (13.3). The constructor so selected is called to initialize
§ 8.5 202

 c ISO/IEC N3242=11-0012
the object, with the initializer expression(s) as its argument(s). If no constructor applies, or the
overload resolution is ambiguous, the initialization is ill-formed.
— Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences
that can convert from the source type to the destination type or (when a conversion function
is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is
chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the
initialization is ill-formed. The function selected is called with the initializer expression as its
argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified
version of the destination type. The temporary is a prvalue. The result of the call (which is the
temporary for the constructor case) is then used to direct-initialize, according to the rules above,
the object that is the destination of the copy-initialization. In certain cases, an implementation
is permitted to eliminate the copying inherent in this direct-initialization by constructing the
intermediate result directly into the object being initialized; see 12.2, 12.8.
— Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered.
The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through
overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer
expression into the object being initialized. If the conversion cannot be done or is ambiguous, the
initialization is ill-formed.
— Otherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression. Standard conversions (Clause 4) will be used, if necessary, to convert the initializer
expression to the cv-unqualified version of the destination type; no user-defined conversions are considered. If the conversion cannot be done, the initialization is ill-formed. [ Note: An expression of type
“cv1 T” can initialize an object of type “cv2 T” independently of the cv-qualifiers cv1 and cv2.
int a;
const int b = a;
int c = b;
— end note ]
17 An initializer-clause followed by an ellipsis is a pack expansion (14.5.3).
8.5.1 Aggregates [dcl.init.aggr]
1 An aggregate is an array or a class (Clause 9) with no user-provided constructors (12.1), no brace-or-equalinitializers for non-static data members (9.2), no private or protected non-static data members (Clause 11),
no base classes (Clause 10), and no virtual functions (10.3).
2 When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list
are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each
member is copy-initialized from the corresponding initializer-clause. If the initializer-clause is an expression
and a narrowing conversion (8.5.4) is required to convert the expression, the program is ill-formed. [ Note:
If an initializer-clause is itself an initializer list, the member is list-initialized, which will result in a recursive
application of the rules in this section if the member is an aggregate. — end note ] [ Example:
struct A {
int x;
struct B {
int i;
int j;
} b;
} a = { 1, { 2, 3 } };
§ 8.5.1 203

 c ISO/IEC N3242=11-0012
initializes a.x with 1, a.b.i with 2, a.b.j with 3. — end example ]
3 An aggregate that is a class can also be initialized with a single expression not enclosed in braces, as described
in 8.5.
4 An array of unknown size initialized with a brace-enclosed initializer-list containing n initializer-clauses,
where n shall be greater than zero, is defined as having n elements (8.3.4). [ Example:
int x[] = { 1, 3, 5 };
declares and initializes x as a one-dimensional array that has three elements since no size was specified and
there are three initializers. — end example ] An empty initializer list {} shall not be used as the initializerclause for an array of unknown bound.104
5 Static data members and anonymous bit fields are not considered members of the class for purposes of
aggregate initialization. [ Example:
struct A {
int i;
static int s;
int j;
int :17;
int k;
} a = { 1, 2, 3 };
Here, the second initializer 2 initializes a.j and not the static data member A::s, and the third initializer
3 initializes a.k and not the anonymous bit field before it. — end example ]
6 An initializer-list is ill-formed if the number of initializer-clauses exceeds the number of members or elements
to initialize. [ Example:
char cv[4] = { ’a’, ’s’, ’d’, ’f’, 0 }; // error
is ill-formed. — end example ]
7 If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member
not explicitly initialized shall be initialized from an empty initializer list (8.5.4). [ Example:
struct S { int a; const char* b; int c; };
S ss = { 1, "asdf" };
initializes ss.a with 1, ss.b with "asdf", and ss.c with the value of an expression of the form int(), that
is, 0. — end example ]
8 If an aggregate class C contains a subaggregate member m that has no members for purposes of aggregate
initialization, the initializer-clause for m shall not be omitted from an initializer-list for an object of type C
unless the initializer-clauses for all members of C following m are also omitted. [ Example:
struct S { } s;
struct A {
S s1;
int i1;
S s2;
int i2;
S s3;
int i3;
104) The syntax provides for empty initializer-lists, but nonetheless C++ does not have zero length arrays.
§ 8.5.1 204

 c ISO/IEC N3242=11-0012
} a = {
{ }, // Required initialization
0,
s, // Required initialization
0
}; // Initialization not required for A::s3 because A::i3 is also not initialized
— end example ]
9 If an incomplete or empty initializer-list leaves a member of reference type uninitialized, the program is
ill-formed.
10 When initializing a multi-dimensional array, the initializer-clauses initialize the elements with the last (rightmost) index of the array varying the fastest (8.3.4). [ Example:
int x[2][2] = { 3, 1, 4, 2 };
initializes x[0][0] to 3, x[0][1] to 1, x[1][0] to 4, and x[1][1] to 2. On the other hand,
float y[4][3] = {
{ 1 }, { 2 }, { 3 }, { 4 }
};
initializes the first column of y (regarded as a two-dimensional array) and leaves the rest zero. — end
example ]
11 In a declaration of the form
T x = { a };
braces can be elided in an initializer-list as follows.105 If the initializer-list begins with a left brace, then
the succeeding comma-separated list of initializer-clauses initializes the members of a subaggregate; it is
erroneous for there to be more initializer-clauses than members. If, however, the initializer-list for a subaggregate does not begin with a left brace, then only enough initializer-clauses from the list are taken to
initialize the members of the subaggregate; any remaining initializer-clauses are left to initialize the next
member of the aggregate of which the current subaggregate is a member. [ Example:
float y[4][3] = {
{ 1, 3, 5 },
{ 2, 4, 6 },
{ 3, 5, 7 },
};
is a completely-braced initialization: 1, 3, and 5 initialize the first row of the array y[0], namely y[0][0],
y[0][1], and y[0][2]. Likewise the next two lines initialize y[1] and y[2]. The initializer ends early and
therefore y[3]s elements are initialized as if explicitly initialized with an expression of the form float(),
that is, are initialized with 0.0. In the following example, braces in the initializer-list are elided; however
the initializer-list has the same effect as the completely-braced initializer-list of the above example,
float y[4][3] = {
1, 3, 5, 2, 4, 6, 3, 5, 7
};
The initializer for y begins with a left brace, but the one for y[0] does not, therefore three elements from
the list are used. Likewise the next three are taken successively for y[1] and y[2]. — end example ]
105) Braces cannot be elided in other uses of list-initialization.
§ 8.5.1 205

 c ISO/IEC N3242=11-0012
12 All implicit type conversions (Clause 4) are considered when initializing the aggregate member with an
assignment-expression. If the assignment-expression can initialize a member, the member is initialized.
Otherwise, if the member is itself a subaggregate, brace elision is assumed and the assignment-expression
is considered for the initialization of the first member of the subaggregate. [ Note: As specified above,
brace elision cannot apply to subaggregates with no members for purposes of aggregate initialization; an
initializer-clause for the entire subobject is required. — end note ]
[ Example:
struct A {
int i;
operator int();
};
struct B {
A a1, a2;
int z;
};
A a;
B b = { 4, a, a };
Braces are elided around the initializer-clause for b.a1.i. b.a1.i is initialized with 4, b.a2 is initialized
with a, b.z is initialized with whatever a.operator int() returns. — end example ]
13 [ Note: An aggregate array or an aggregate class may contain members of a class type with a user-provided
constructor (12.1). Initialization of these aggregate objects is described in 12.6.1. — end note ]
14 [ Note: Whether the initialization of aggregates with static storage duration is static or dynamic is specified
in 3.6.2 and 6.7. — end note ]
15 When a union is initialized with a brace-enclosed initializer, the braces shall only contain an initializer-clause
for the first non-static data member of the union. [ Example:
union u { int a; const char* b; };
u a = { 1 };
u b = a;
u c = 1; // error
u d = { 0, "asdf" }; // error
u e = { "asdf" }; // error
— end example ]
16 [ Note: As described above, the braces around the initializer-clause for a union member can be omitted if
the union is a member of another aggregate. — end note ]
17 The full-expressions in an initializer-clause are evaluated in the order in which they appear.
8.5.2 Character arrays [dcl.init.string]
1 A char array (whether plain char, signed char, or unsigned char), char16_t array, char32_t array, or
wchar_t array can be initialized by a narrow character literal, char16_t string literal, char32_t string
literal, or wide string literal, respectively, or by an appropriately-typed string literal enclosed in braces.
Successive characters of the value of the string literal initialize the elements of the array. [ Example:
char msg[] = "Syntax error on line %s\n";
shows a character array whose members are initialized with a string-literal. Note that because ’\n’ is a
single character and because a trailing ’\0’ is appended, sizeof(msg) is 25. — end example ]
§ 8.5.2 206

 c ISO/IEC N3242=11-0012
2 There shall not be more initializers than there are array elements. [ Example:
char cv[4] = "asdf"; // error
is ill-formed since there is no space for the implied trailing ’\0’. — end example ]
3 If there are fewer initializers than there are array elements, each element not explicitly initialized shall be
zero-initialized (8.5).
8.5.3 References [dcl.init.ref]
1 A variable declared to be a T& or T&&, that is, “reference to type T” (8.3.2), shall be initialized by an object,
or function, of type T or by an object that can be converted into a T. [ Example:
int g(int);
void f() {
int i;
int& r = i; // r refers to i
r = 1; // the value of i becomes 1
int* p = &r; // p points to i
int& rr = r; // rr refers to what r refers to, that is, to i
int (&rg)(int) = g; // rg refers to the function g
rg(i); // calls function g
int a[3];
int (&ra)[3] = a; // ra refers to the array a
ra[1] = i; // modifies a[1]
} —
end example ]
2 A reference cannot be changed to refer to another object after initialization. Note that initialization of a
reference is treated very differently from assignment to it. Argument passing (5.2.2) and function value
return (6.6.3) are initializations.
3 The initializer can be omitted for a reference only in a parameter declaration (8.3.5), in the declaration of
a function return type, in the declaration of a class member within its class definition (9.2), and where the
extern specifier is explicitly used. [ Example:
int& r1; // error: initializer missing
extern int& r2; // OK
— end example ]
4 Given types “cv1 T1” and “cv2 T2,” “cv1 T1” is reference-related to “cv2 T2” if T1 is the same type as T2, or
T1 is a base class of T2. “cv1 T1” is reference-compatible with “cv2 T2” if T1 is reference-related to T2 and cv1
is the same cv-qualification as, or greater cv-qualification than, cv2. For purposes of overload resolution,
cases for which cv1 is greater cv-qualification than cv2 are identified as reference-compatible with added
qualification (see 13.3.3.2). In all cases where the reference-related or reference-compatible relationship of
two types is used to establish the validity of a reference binding, and T1 is a base class of T2, a program
that necessitates such a binding is ill-formed if T1 is an inaccessible (Clause 11) or ambiguous (10.2) base
class of T2.
5 A reference to type “cv1 T1” is initialized by an expression of type “cv2 T2” as follows:
— If the reference is an lvalue reference and the initializer expression
— is an lvalue (but is not a bit-field), and “cv1 T1” is reference-compatible with “cv2 T2,” or
§ 8.5.3 207

 c ISO/IEC N3242=11-0012
— has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be
implicitly converted to an lvalue of type “cv3 T3,” where “cv1 T1” is reference-compatible with “cv3
T3”106 (this conversion is selected by enumerating the applicable conversion functions (13.3.1.6)
and choosing the best one through overload resolution (13.3)),
then the reference is bound to the initializer expression lvalue in the first case and to the lvalue result
of the conversion in the second case (or, in either case, to the appropriate base class subobject of
the object). [ Note: The usual lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer
(4.3) standard conversions are not needed, and therefore are suppressed, when such direct bindings to
lvalues are done. — end note ]
[ Example:
double d = 2.0;
double& rd = d; // rd refers to d
const double& rcd = d; // rcd refers to d
struct A { };
struct B : A { operator int&(); } b;
A& ra = b; // ra refers to A subobject in b
const A& rca = b; // rca refers to A subobject in b
int& ir = B(); // ir refers to the result of B::operator int&
— end example ]
— Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be
const), or the reference shall be an rvalue reference. [ Example:
double& rd2 = 2.0; // error: not an lvalue and reference not const
int i = 2;
double& rd3 = i; // error: type mismatch and reference not const
— end example ]
— If the initializer expression
— is an xvalue, class prvalue, array prvalue or function lvalue and “cv1 T1” is referencecompatible with “cv2 T2”, or
— has a class type (i.e., T2 is a class type), where T1 is not reference-related to T2, and can be
implicitly converted to an xvalue, class prvalue, or function lvalue of type “cv3 T3”, where
“cv1 T1” is reference-compatible with “cv3 T3”,
then the reference is bound to the value of the initializer expression in the first case and to
the result of the conversion in the second case (or, in either case, to an appropriate base class
subobject). In the second case, if the reference is an rvalue reference and the second standard conversion sequence of the user-defined conversion sequence includes an lvalue-to-rvalue conversion,
the program is ill-formed.
[ Example:
struct A { };
struct B : A { } b;
extern B f();
const A& rca = f(); // bound to the A subobject of the B rvalue.
A&& rra = f(); // same as above
106) This requires a conversion function (12.3.2) returning a reference type.
§ 8.5.3 208

 c ISO/IEC N3242=11-0012
struct X {
operator B();
operator int&();
} x;
const A& r = x; // bound to the A subobject of the result of the conversion
int&& rri = static_cast<int&&>(i); // bound directly to i
B&& rrb = x; // bound directly to the result of operator B
int&& rri2 = X(); // error: lvalue-to-rvalue conversion applied to the
// result of operator int&
— end example ]
— Otherwise, a temporary of type “cv1 T1” is created and initialized from the initializer expression
using the rules for a non-reference copy-initialization (8.5). The reference is then bound to the
temporary. If T1 is reference-related to T2, cv1 shall be the same cv-qualification as, or greater
cv-qualification than, cv2. If T1 is reference-related to T2 and the reference is an rvalue reference,
the initializer expression shall not be an lvalue. [ Example:
const double& rcd2 = 2; // rcd2 refers to temporary with value 2.0
double&& rrd = 2; // rrd refers to temporary with value 2.0
const volatile int cvi = 1;
const int& r = cvi; // error: type qualifiers dropped
double&& rrd2 = d; // error: copying lvalue of related type
double&& rrd3 = i; // rrd3 refers to temporary with value 2.0
— end example ]
In all cases except the last (i.e., creating and initializing a temporary from the initializer expression), the
reference is said to bind directly to the initializer expression.
6 [ Note: 12.2 describes the lifetime of temporaries bound to references. — end note ]
8.5.4 List-initialization [dcl.init.list]
1 List-initialization is initialization of an object or reference from a braced-init-list. Such an initializer is
called an initializer list, and the comma-separated initializer-clauses of the list are called the elements of the
initializer list. An initializer list may be empty. List-initialization can occur in direct-initialization or copyinitialization contexts; list-initialization in a direct-initialization context is called direct-list-initialization and
list-initialization in a copy-initialization context is called copy-list-initialization. [ Note: List-initialization
can be used
— as the initializer in a variable definition (8.5)
— as the initializer in a new expression (5.3.4)
— in a return statement (6.6.3)
— as a function argument (5.2.2)
— as a subscript (5.2.1)
— as an argument to a constructor invocation (8.5, 5.2.3)
— as an initializer for a non-static data member (9.2)
— in a mem-initializer (12.6.2)
— on the right-hand side of an assignment (5.17)
§ 8.5.4 209

 c ISO/IEC N3242=11-0012
[ Example:
int a = {1};
std::complex<double> z{1,2};
new std::vector<std::string>{"once", "upon", "a", "time"}; // 4 string elements
f( {"Nicholas","Annemarie"} ); // pass list of two elements
return { "Norah" }; // return list of one element
int* e {}; // initialization to zero / null pointer
x = double{1}; // explicitly construct a double
std::map<std::string,int> anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
— end example ] — end note ]
2 A constructor is an initializer-list constructor if its first parameter is of type std::initializer_list<E>
or reference to possibly cv-qualified std::initializer_list<E> for some type E, and either there are
no other parameters or else all other parameters have default arguments (8.3.6). [ Note: Initializer-list
constructors are favored over other constructors in list-initialization (13.3.1.7). — end note ] The template
std::initializer_list is not predefined; if the header <initializer_list> is not included prior to a use
of std::initializer_list — even an implicit use in which the type is not named (7.1.6.4) — the program
is ill-formed.
3 List-initialization of an object or reference of type T is defined as follows:
— If the initializer list has no elements and T is a class type with a default constructor, the object is
value-initialized.
— Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1).
[ Example:
double ad[] = { 1, 2.0 }; // OK
int ai[] = { 1, 2.0 }; // error: narrowing
struct S2 {
int m1;
double m2, m3;
};
S2 s21 = { 1, 2, 3.0 }; // OK
S2 s22 { 1.0, 2, 3 }; // error: narrowing
S2 s23 { }; // OK: default to 0,0,0
— end example ]
— Otherwise, if T is a specialization of std::initializer_list<E>, an initializer_list object is
constructed as described below and used to initialize the object according to the rules for initialization
of an object from a class of the same type (8.5).
— Otherwise, if T is a class type, constructors are considered. If T has an initializer-list constructor, the
argument list consists of the initializer list as a single argument; otherwise, the argument list consists
of the elements of the initializer list. The applicable constructors are enumerated (13.3.1.7) and the
best one is chosen through overload resolution (13.3). If a narrowing conversion (see below) is required
to convert any of the arguments, the program is ill-formed.
[ Example:
struct S {
S(std::initializer_list<double>); // #1
S(std::initializer_list<int>); // #2
§ 8.5.4 210

 c ISO/IEC N3242=11-0012
S(); // #3
// ...
};
S s1 = { 1.0, 2.0, 3.0 }; // invoke #1
S s2 = { 1, 2, 3 }; // invoke #2
S s3 = { }; // invoke #3
— end example ]
[ Example:
struct Map {
Map(std::initializer_list<std::pair<std::string,int>>);
};
Map ship = {{"Sophie",14}, {"Surprise",28}};
— end example ]
[ Example:
struct S {
// no initializer-list constructors
S(int, double, double); // #1
S(); // #2
// ...
};
S s1 = { 1, 2, 3.0 }; // OK: invoke #1
S s2 { 1.0, 2, 3 }; // error: narrowing
S s3 { }; // OK: invoke #2
— end example ]
— Otherwise, if T is a reference to class type or if T is any reference type and the initializer list has no
elements, a prvalue temporary of the type referenced by T is list-initialized, and the reference is bound
to that temporary. [ Note: As usual, the binding will fail and the program is ill-formed if the reference
type is an lvalue reference to a non-const type. — end note ]
[ Example:
struct S {
S(std::initializer_list<double>); // #1
S(const std::string&); // #2
// ...
};
const S& r1 = { 1, 2, 3.0 }; // OK: invoke #1
const S& r2 { "Spinach" }; // OK: invoke #2
S& r3 = { 1, 2, 3 }; // error: initializer is not an lvalue
— end example ]
— Otherwise, if the initializer list has a single element, the object is initialized from that element; if a
narrowing conversion (see below) is required to convert the element to T, the program is ill-formed.
[ Example:
int x1 {2}; // OK
int x2 {2.0}; // error: narrowing
— end example ]
§ 8.5.4 211

 c ISO/IEC N3242=11-0012
— Otherwise, if the initializer list has no elements, the object is value-initialized.
[ Example:
int** pp {}; // initialized to null pointer
— end example ]
— Otherwise, the program is ill-formed.
[ Example:
struct A { int i; int j; };
A a1 { 1, 2 }; // aggregate initialization
A a2 { 1.2 }; // error: narrowing
struct B {
B(std::initializer_list<int>);
};
B b1 { 1, 2 }; // creates initializer_list<int> and calls constructor
B b2 { 1, 2.0 }; // error: narrowing
struct C {
C(int i, double j);
};
C c1 = { 1, 2.2 }; // calls constructor with arguments (1, 2.2)
C c2 = { 1.1, 2 }; // error: narrowing
int j { 1 }; // initialize to 1
int k { }; // initialize to 0
— end example ]
4 An object of type std::initializer_list<E> is constructed from an initializer list as if the implementation
allocated an array of N elements of type E, where N is the number of elements in the initializer list.
Each element of that array is copy-initialized with the corresponding element of the initializer list, and
the std::initializer_list<E> object is constructed to refer to that array. If a narrowing conversion is
required to initialize any of the elements, the program is ill-formed.[ Example:
struct X {
X(std::initializer_list<double> v);
};
X x{ 1,2,3 };
The initialization will be implemented in a way roughly equivalent to this:
double __a[3] = {double{1}, double{2}, double{3}};
X x(std::initializer_list<double>(__a, __a+3));
assuming that the implementation can construct an initializer_list object with a pair of pointers. — end
example ]
5 The lifetime of the array is the same as that of the initializer_list object. [ Example:
typedef std::complex<double> cmplx;
std::vector<cmplx> v1 = { 1, 2, 3 };
void f() {
std::vector<cmplx> v2{ 1, 2, 3 };
std::initializer_list<int> i3 = { 1, 2, 3 };
}
§ 8.5.4 212

 c ISO/IEC N3242=11-0012
For v1 and v2, the initializer_list object and array created for { 1, 2, 3 } have full-expression lifetime.
For i3, the initializer_list object and array have automatic lifetime. — end example ] [ Note: The
implementation is free to allocate the array in read-only memory if an explicit array with the same initializer
could be so allocated. — end note ]
6 A narrowing conversion is an implicit conversion
— from a floating-point type to an integer type, or
— from long double to double or float, or from double to float, except where the source is a constant
expression and the actual value after conversion is within the range of values that can be represented
(even if it cannot be represented exactly), or
— from an integer type or unscoped enumeration type to a floating-point type, except where the source
is a constant expression and the actual value after conversion will fit into the target type and will
produce the original value when converted back to the original type, or
— from an integer type or unscoped enumeration type to an integer type that cannot represent all the
values of the original type, except where the source is a constant expression and the actual value after
conversion will fit into the target type and will produce the original value when converted back to the
original type.
[ Note: As indicated above, such conversions are not allowed at the top level in list-initializations. — end
note ] [ Example:
int x = 999; // x is not a constant expression
const int y = 999;
const int z = 99;
char c1 = x; // OK, though it might narrow (in this case, it does narrow)
char c2{x}; // error: might narrow
char c3{y}; // error: narrows (assuming char is 8 bits)
char c4{z}; // OK: no narrowing needed
unsigned char uc1 = {5}; // OK: no narrowing needed
unsigned char uc2 = {-1}; // error: narrows
unsigned int ui1 = {-1}; // error: narrows
signed int si1 =
{ (unsigned int)-1 }; // error: narrows
int ii = {2.0}; // error: narrows
float f1 { x }; // error: might narrow
float f2 { 7 }; // OK: 7 can be exactly represented as a float
int f(int);
int a[] =
{ 2, f(2), f(2.0) }; // OK: the double-to-int conversion is not at the top level
— end example ]
§ 8.5.4 213

 c ISO/IEC N3242=11-0012
9 Classes [class]
1 A class is a type. Its name becomes a class-name (9.1) within its scope.
class-name:
identifier
simple-template-id
Class-specifiers and elaborated-type-specifiers (7.1.6.3) are used to make class-names. An object of a class
consists of a (possibly empty) sequence of members and base class objects.
class-specifier:
class-head { member-specificationopt}
class-head:
class-key attribute-specifier-seqopt class-head-name class-virt-specifier-seqopt base-clauseopt
class-key attribute-specifier-seqopt base-clauseopt
class-head-name:
nested-name-specifieropt class-name
class-virt-specifier-seq:
class-virt-specifier
class-virt-specifier-seq class-virt-specifier
class-virt-specifier:
final
explicit
class-key:
class
struct
union
A class-virt-specifier-seq shall contain at most one of each class-virt-specifier. A class-specifier whose classhead omits the class-head-name defines an unnamed class. [ Note: An unnamed class thus can’t be final
or explicit. — end note ]
2 A class-name is inserted into the scope in which it is declared immediately after the class-name is seen.
The class-name is also inserted into the scope of the class itself; this is known as the injected-class-name.
For purposes of access checking, the injected-class-name is treated as if it were a public member name. A
class-specifier is commonly referred to as a class definition. A class is considered defined after the closing
brace of its class-specifier has been seen even though its member functions are in general not yet defined.
The optional attribute-specifier-seq appertains to the class; the attributes in the attribute-specifier-seq are
thereafter considered attributes of the class whenever it is named.
3 If a class is marked with the class-virt-specifier final and it appears as a base-type-specifier in a base-clause
(Clause 10), the program is ill-formed.
4 Complete objects and member subobjects of class type shall have nonzero size.107 [ Note: Class objects can
be assigned, passed as arguments to functions, and returned by functions (except objects of classes for which
copying or moving has been restricted; see 12.8). Other plausible operators, such as equality comparison,
can be defined by the user; see 13.5. — end note ]
107) Base class subobjects are not so constrained.
214

 c ISO/IEC N3242=11-0012
5 A union is a class defined with the class-key union; it holds only one data member at a time (9.5). [ Note:
Aggregates of class type are described in 8.5.1. — end note ]
6 A trivially copyable class is a class that:
— has no non-trivial copy constructors (12.8),
— has no non-trivial move constructors (12.8),
— has no non-trivial copy assignment operators (13.5.3, 12.8),
— has no non-trivial move assignment operators (13.5.3, 12.8), and
— has a trivial destructor (12.4).
A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.
[ Note: In particular, a trivially copyable or trivial class does not have virtual functions or virtual base
classes. — end note ]
7 A standard-layout class is a class that:
— has no non-static data members of type non-standard-layout class (or array of such types) or reference,
— has no virtual functions (10.3) and no virtual base classes (10.1),
— has the same access control (Clause 11) for all non-static data members,
— has no non-standard-layout base classes,
— either has no non-static data members in the most derived class and at most one base class with
non-static data members, or has no base classes with non-static data members, and
— has no base classes of the same type as the first non-static data member.108
8 A standard-layout struct is a standard-layout class defined with the class-key struct or the class-key class.
A standard-layout union is a standard-layout class defined with the class-key union.
9 [ Note: Standard-layout classes are useful for communicating with code written in other programming languages. Their layout is specified in 9.2. — end note ]
10 A POD struct109 is a class that is both a trivial class and a standard-layout class, and has no non-static
data members of type non-POD struct, non-POD union (or array of such types). Similarly, a POD union
is a union that is both a trivial class and a standard layout class, and has no non-static data members of
type non-POD struct, non-POD union (or array of such types). A POD class is a class that is either a POD
struct or a POD union.
[ Example:
struct N { // neither trivial nor standard-layout
int i;
int j;
virtual ~N();
};
struct T { // trivial but not standard-layout
int i;
private:
108) This ensures that two subobjects that have the same class type and that belong to the same most derived object are not
allocated at the same address (5.10).
109) The acronym POD stands for “plain old data”.
215

 c ISO/IEC N3242=11-0012
int j;
};
struct SL { // standard-layout but not trivial
int i;
int j;
~SL();
};
struct POD { // both trivial and standard-layout
int i;
int j;
};
— end example ]
11 If a class-head-name contains a nested-name-specifier, the class-specifier shall refer to a class that was
previously declared directly in the class or namespace to which the nested-name-specifier refers, or in an
element of the inline namespace set (7.3.1) of that namespace (i.e., not merely inherited or introduced by
a using-declaration), and the class-specifier shall appear in a namespace enclosing the previous declaration.
In such cases, the nested-name-specifier of the class-head-name of the definition shall not begin with a
decltype-specifier.
9.1 Class names [class.name]
1 A class definition introduces a new type. [ Example:
struct X { int a; };
struct Y { int a; };
X a1;
Y a2;
int a3;
declares three variables of three different types. This implies that
a1 = a2; // error: Y assigned to X
a1 = a3; // error: int assigned to X
are type mismatches, and that
int f(X);
int f(Y);
declare an overloaded (Clause 13) function f() and not simply a single function f() twice. For the same
reason,
struct S { int a; };
struct S { int a; }; // error, double definition
is ill-formed because it defines S twice. — end example ]
2 A class declaration introduces the class name into the scope where it is declared and hides any class, variable,
function, or other declaration of that name in an enclosing scope (3.3). If a class name is declared in a scope
where a variable, function, or enumerator of the same name is also declared, then when both declarations
are in scope, the class can be referred to only using an elaborated-type-specifier (3.4.4). [ Example:
§ 9.1 216

 c ISO/IEC N3242=11-0012
struct stat {
// ...
};
stat gstat; // use plain stat to
// define variable
int stat(struct stat*); // redeclare stat as function
void f() {
struct stat* ps; // struct prefix needed
// to name struct stat
stat(ps); // call stat()
} —
end example ] A declaration consisting solely of class-key identifier; is either a redeclaration of the name
in the current scope or a forward declaration of the identifier as a class name. It introduces the class name
into the current scope. [ Example:
struct s { int a; };
void g() {
struct s; // hide global struct s
// with a block-scope declaration
s* p; // refer to local struct s
struct s { char* p; }; // define local struct s
struct s; // redeclaration, has no effect
}
— end example ] [ Note: Such declarations allow definition of classes that refer to each other. [ Example:
class Vector;
class Matrix {
// ...
friend Vector operator*(const Matrix&, const Vector&);
};
class Vector {
// ...
friend Vector operator*(const Matrix&, const Vector&);
};
Declaration of friends is described in 11.3, operator functions in 13.5. — end example ] — end note ]
3 [ Note: An elaborated-type-specifier (7.1.6.3) can also be used as a type-specifier as part of a declaration. It
differs from a class declaration in that if a class of the elaborated name is in scope the elaborated name will
refer to it. — end note ] [ Example:
struct s { int a; };
void g(int s) {
struct s* p = new struct s; // global s
p->a = s; // parameter s
}
§ 9.1 217

 c ISO/IEC N3242=11-0012
— end example ]
4 [ Note: The declaration of a class name takes effect immediately after the identifier is seen in the class
definition or elaborated-type-specifier. For example,
class A * A;
first specifies A to be the name of a class and then redefines it as the name of a pointer to an object of that
class. This means that the elaborated form class A must be used to refer to the class. Such artistry with
names can be confusing and is best avoided. — end note ]
5 A typedef-name (7.1.3) that names a class type, or a cv-qualified version thereof, is also a class-name. If a
typedef-name that names a cv-qualified class type is used where a class-name is required, the cv-qualifiers
are ignored. A typedef-name shall not be used as the identifier in a class-head.
9.2 Class members [class.mem]
member-specification:
member-declaration member-specificationopt
access-specifier : member-specificationopt
member-declaration:
attribute-specifier-seqopt decl-specifier-seqopt
member-declarator-list
opt;
function-definition ;opt
using-declaration
static_assert-declaration
template-declaration
alias-declaration
member-declarator-list:
member-declarator
member-declarator-list , member-declarator
member-declarator:
declarator virt-specifier-seqopt pure-specifieropt
declarator virt-specifier-seqopt brace-or-equal-initializeropt
identifieropt attribute-specifier-seqopt virt-specifier-seqopt: constant-expression
virt-specifier-seq:
virt-specifier
virt-specifier-seq virt-specifier
virt-specifier:
override
final
new
pure-specifier:
= 0
1 The member-specification in a class definition declares the full set of members of the class; no member can
be added elsewhere. Members of a class are data members, member functions (9.3), nested types, and
enumerators. Data members and member functions are static or non-static; see 9.4. Nested types are
classes (9.1, 9.7) and enumerations (7.2) defined in the class, and arbitrary types declared as members by
use of a typedef declaration (7.1.3). The enumerators of an unscoped enumeration (7.2) defined in the class
are members of the class. Except when used to declare friends (11.3) or to introduce the name of a member
of a base class into a derived class (7.3.3), member-declarations declare members of the class, and each such
member-declaration shall declare at least one member name of the class. A member shall not be declared
twice in the member-specification, except that a nested class or member class template can be declared and
§ 9.2 218

 c ISO/IEC N3242=11-0012
then later defined, and except that an enumeration can be introduced with an opaque-enum-declaration and
later redeclared with an enum-specifier.
2 A class is considered a completely-defined object type (3.9) (or complete type) at the closing } of the
class-specifier. Within the class member-specification, the class is regarded as complete within function
bodies, default arguments, exception-specifications, and brace-or-equal-initializers for non-static data members (including such things in nested classes). Otherwise it is regarded as incomplete within its own class
member-specification.
3 [ Note: A single name can denote several function members provided their types are sufficiently different
(Clause 13). — end note ]
4 A member can be initialized using a constructor; see 12.1. [ Note: See Clause 12 for a description of
constructors and other special member functions. — end note ]
5 A member can be initialized using a brace-or-equal-initializer. (For static data members, see 9.4.2; for
non-static data members, see 12.6.2).
6 A member shall not be declared with the extern or register storage-class-specifier. Within a class definition,
a member shall not be declared with the thread_local storage-class-specifier unless also declared static.
7 The decl-specifier-seq is omitted in constructor, destructor, and conversion function declarations only. The
member-declarator-list can be omitted only after a class-specifier or an enum-specifier or in a friend declaration (11.3). A pure-specifier shall be used only in the declaration of a virtual function (10.3).
8 The optional attribute-specifier-seq in a member-declaration appertains to each of the entities declared by
the member-declarators; it shall not appear if the optional member-declarator-list is omitted.
9 A virt-specifier-seq shall contain at most one of each virt-specifier. The virt-specifiers override and final
shall only appear in the declaration of a virtual member function.
10 If a class member is marked new and its name does not hide (3.3.10, 10.2) a class member name in a base
class the program is ill-formed.
11 Non-static (9.4) data members shall not have incomplete types. In particular, a class C shall not contain
a non-static member of class C, but it can contain a pointer or reference to an object of class C.
12 [ Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions.
— end note ]
13 [ Note: The type of a non-static member function is an ordinary function type, and the type of a non-static
data member is an ordinary object type. There are no special member function types or data member types.
— end note ]
14 [ Example: A simple example of a class definition is
struct tnode {
char tword[20];
int count;
tnode *left;
tnode *right;
};
which contains an array of twenty characters, an integer, and two pointers to objects of the same type. Once
this definition has been given, the declaration
tnode s, *sp;
§ 9.2 219

 c ISO/IEC N3242=11-0012
declares s to be a tnode and sp to be a pointer to a tnode. With these declarations, sp->count refers to
the count member of the object to which sp points; s.left refers to the left subtree pointer of the object
s; and s.right->tword[0] refers to the initial character of the tword member of the right subtree of s.
— end example ]
15 Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so
that later members have higher addresses within a class object. The order of allocation of non-static data
members with different access control is unspecified (11). Implementation alignment requirements might
cause two adjacent members not to be allocated immediately after each other; so might requirements for
space for managing virtual functions (10.3) and virtual base classes (10.1).
16 If T is the name of a class, then each of the following shall have a name different from T:
— every static data member of class T;
— every member function of class T [ Note: This restriction does not apply to constructors, which do not
have names (12.1) — end note ];
— every member of class T that is itself a type;
— every enumerator of every member of class T that is an unscoped enumerated type; and
— every member of every anonymous union that is a member of class T.
17 In addition, if class T has a user-declared constructor (12.1), every non-static data member of class T shall
have a name different from T.
18 Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static
data members and corresponding non-static data members (in declaration order) have layout-compatible
types (3.9).
19 Two standard-layout union (Clause 9) types are layout-compatible if they have the same number of nonstatic data members and corresponding non-static data members (in any order) have layout-compatible
types (3.9).
20 If a standard-layout union contains two or more standard-layout structs that share a common initial sequence,
and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted
to inspect the common initial part of any of them. Two standard-layout structs share a common initial
sequence if corresponding members have layout-compatible types and either neither member is a bit-field or
both are bit-fields with the same width for a sequence of one or more initial members.
21 A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
as necessary to achieve appropriate alignment. — end note ]
9.3 Member functions [class.mfct]
1 Functions declared in the definition of a class, excluding those declared with a friend specifier (11.3), are
called member functions of that class. A member function may be declared static in which case it is a static
member function of its class (9.4); otherwise it is a non-static member function of its class (9.3.1, 9.3.2).
2 A member function may be defined (8.4) in its class definition, in which case it is an inline member function (7.1.2), or it may be defined outside of its class definition if it has already been declared but not defined
in its class definition. A member function definition that appears outside of the class definition shall appear
in a namespace scope enclosing the class definition. Except for member function definitions that appear
outside of a class definition, and except for explicit specializations of member functions of class templates
§ 9.3 220

 c ISO/IEC N3242=11-0012
and member function templates (14.7) appearing outside of the class definition, a member function shall not
be redeclared.
3 An inline member function (whether static or non-static) may also be defined outside of its class definition
provided either its declaration in the class definition or its definition outside of the class definition declares
the function as inline. [ Note: Member functions of a class in namespace scope have external linkage.
Member functions of a local class (9.8) have no linkage. See 3.5. — end note ]
4 There shall be at most one definition of a non-inline member function in a program; no diagnostic is required.
There may be more than one inline member function definition in a program. See 3.2 and 7.1.2.
5 If the definition of a member function is lexically outside its class definition, the member function name
shall be qualified by its class name using the :: operator. [ Note: A name used in a member function
definition (that is, in the parameter-declaration-clause including the default arguments (8.3.6) or in the
member function body) is looked up as described in 3.4. — end note ] [ Example:
struct X {
typedef int T;
static T count;
void f(T);
};
void X::f(T t = count) { }
The member function f of class X is defined in global scope; the notation X::f specifies that the function f
is a member of class X and in the scope of class X. In the function definition, the parameter type T refers to
the typedef member T declared in class X and the default argument count refers to the static data member
count declared in class X. — end example ]
6 A static local variable in a member function always refers to the same object, whether or not the member
function is inline.
7 Previously declared member functions may be mentioned in friend declarations.
8 Member functions of a local class shall be defined inline in their class definition, if they are defined at all.
9 [ Note: A member function can be declared (but not defined) using a typedef for a function type. The
resulting member function has exactly the same type as it would have if the function declarator were
provided explicitly, see 8.3.5. For example,
typedef void fv(void);
typedef void fvc(void) const;
struct S {
fv memfunc1; // equivalent to: void memfunc1(void);
void memfunc2();
fvc memfunc3; // equivalent to: void memfunc3(void) const;
};
fv S::* pmfv1 = &S::memfunc1;
fv S::* pmfv2 = &S::memfunc2;
fvc S::* pmfv3 = &S::memfunc3;
Also see 14.3. — end note ]
9.3.1 Nonstatic member functions [class.mfct.non-static]
1 A non-static member function may be called for an object of its class type, or for an object of a class derived
(Clause 10) from its class type, using the class member access syntax (5.2.5, 13.3.1.1). A non-static member
§ 9.3.1 221

 c ISO/IEC N3242=11-0012
function may also be called directly using the function call syntax (5.2.2, 13.3.1.1) from within the body of
a member function of its class or of a class derived from its class.
2 If a non-static member function of a class X is called for an object that is not of type X, or of a type derived
from X, the behavior is undefined.
3 When an id-expression (5.1) that is not part of a class member access syntax (5.2.5) and not used to form a
pointer to member (5.3.1) is used in the body of a non-static member function of class X, if name lookup (3.4)
resolves the name in the id-expression to a non-static non-type member of some class C, the id-expression is
transformed into a class member access expression (5.2.5) using (*this) (9.3.2) as the postfix-expression to
the left of the . operator. [ Note: If C is not X or a base class of X, the class member access expression is
ill-formed. — end note ] Similarly during name lookup, when an unqualified-id (5.1) used in the definition of
a member function for class X resolves to a static member, an enumerator or a nested type of class X or of a
base class of X, the unqualified-id is transformed into a qualified-id (5.1) in which the nested-name-specifier
names the class of the member function. [ Example:
struct tnode {
char tword[20];
int count;
tnode *left;
tnode *right;
void set(const char*, tnode* l, tnode* r);
};
void tnode::set(const char* w, tnode* l, tnode* r) {
count = strlen(w)+1;
if (sizeof(tword)<=count)
perror("tnode string too long");
strcpy(tword,w);
left = l;
right = r;
}
void f(tnode n1, tnode n2) {
n1.set("abc",&n2,0);
n2.set("def",0,0);
}
In the body of the member function tnode::set, the member names tword, count, left, and right refer to
members of the object for which the function is called. Thus, in the call n1.set("abc",&n2,0), tword refers
to n1.tword, and in the call n2.set("def",0,0), it refers to n2.tword. The functions strlen, perror,
and strcpy are not members of the class tnode and should be declared elsewhere.110 — end example ]
4 A non-static member function may be declared const, volatile, or const volatile. These cv-qualifiers
affect the type of the this pointer (9.3.2). They also affect the function type (8.3.5) of the member function;
a member function declared const is a const member function, a member function declared volatile is
a volatile member function and a member function declared const volatile is a const volatile member
function. [ Example:
struct X {
void g() const;
void h() const volatile;
};
110) See, for example, <cstring> (21.7).
§ 9.3.1 222

 c ISO/IEC N3242=11-0012
X::g is a const member function and X::h is a const volatile member function. — end example ]
5 A non-static member function may be declared with a ref-qualifier (8.3.5); see 13.3.1.
6 A non-static member function may be declared virtual (10.3) or pure virtual (10.4).
9.3.2 The this pointer [class.this]
1 In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value
is the address of the object for which the function is called. The type of this in a member function of
a class X is X*. If the member function is declared const, the type of this is const X*, if the member
function is declared volatile, the type of this is volatile X*, and if the member function is declared
const volatile, the type of this is const volatile X*.
2 In a const member function, the object for which the function is called is accessed through a const access
path; therefore, a const member function shall not modify the object and its non-static data members.
[ Example:
struct s {
int a;
int f() const;
int g() { return a++; }
int h() const { return a++; } // error
};
int s::f() const { return a; }
The a++ in the body of s::h is ill-formed because it tries to modify (a part of) the object for which s::h()
is called. This is not allowed in a const member function because this is a pointer to const; that is, *this
has const type. — end example ]
3 Similarly, volatile semantics (7.1.6.1) apply in volatile member functions when accessing the object and
its non-static data members.
4 A cv-qualified member function can be called on an object-expression (5.2.5) only if the object-expression is
as cv-qualified or less-cv-qualified than the member function. [ Example:
void k(s& x, const s& y) {
x.f();
x.g();
y.f();
y.g(); // error
}
The call y.g() is ill-formed because y is const and s::g() is a non-const member function, that is, s::g()
is less-qualified than the object-expression y. — end example ]
5 Constructors (12.1) and destructors (12.4) shall not be declared const, volatile or const volatile. [ Note:
However, these functions can be invoked to create and destroy objects with cv-qualified types, see (12.1)
and (12.4). — end note ]
9.4 Static members [class.static]
1 A data or function member of a class may be declared static in a class definition, in which case it is a
static member of the class.
§ 9.4 223

 c ISO/IEC N3242=11-0012
2 A static member s of class X may be referred to using the qualified-id expression X::s; it is not necessary to
use the class member access syntax (5.2.5) to refer to a static member. A static member may be referred
to using the class member access syntax, in which case the object-expression is evaluated. [ Example:
struct process {
static void reschedule();
};
process& g();
void f() {
process::reschedule(); // OK: no object necessary
g().reschedule(); // g() is called
}
— end example ]
3 A static member may be referred to directly in the scope of its class or in the scope of a class derived
(Clause 10) from its class; in this case, the static member is referred to as if a qualified-id expression was
used, with the nested-name-specifier of the qualified-id naming the class scope from which the static member
is referenced. [ Example:
int g();
struct X {
static int g();
};
struct Y : X {
static int i;
};
int Y::i = g(); // equivalent to Y::g();
— end example ]
4 If an unqualified-id (5.1) is used in the definition of a static member following the member’s declarator-id,
and name lookup (3.4.1) finds that the unqualified-id refers to a static member, enumerator, or nested
type of the member’s class (or of a base class of the member’s class), the unqualified-id is transformed into
a qualified-id expression in which the nested-name-specifier names the class scope from which the member
is referenced. [ Note: See 5.1 for restrictions on the use of non-static data members and non-static member
functions. — end note ]
5 Static members obey the usual class member access rules (Clause 11). When used in the declaration of
a class member, the static specifier shall only be used in the member declarations that appear within
the member-specification of the class definition. [ Note: It cannot be specified in member declarations that
appear in namespace scope. — end note ]
9.4.1 Static member functions [class.static.mfct]
1 [ Note: The rules described in 9.3 apply to static member functions. — end note ]
2 [ Note: A static member function does not have a this pointer (9.3.2). — end note ] A static member
function shall not be virtual. There shall not be a static and a non-static member function with the
same name and the same parameter types (13.1). A static member function shall not be declared const,
volatile, or const volatile.
9.4.2 Static data members [class.static.data]
1 A static data member is not part of the subobjects of a class. If a static data member is declared
§ 9.4.2 224

 c ISO/IEC N3242=11-0012
thread_local there is one copy of the member per thread. If a static data member is not declared
thread_local there is one copy of the data member that is shared by all the objects of the class.
2 The declaration of a static data member in its class definition is not a definition and may be of an incomplete
type other than cv-qualified void. The definition for a static data member shall appear in a namespace
scope enclosing the member’s class definition. In the definition at namespace scope, the name of the static
data member shall be qualified by its class name using the :: operator. The initializer expression in the
definition of a static data member is in the scope of its class (3.3.7). [ Example:
class process {
static process* run_chain;
static process* running;
};
process* process::running = get_main();
process* process::run_chain = running;
The static data member run_chain of class process is defined in global scope; the notation process::run_-
chain specifies that the member run_chain is a member of class process and in the scope of class process.
In the static data member definition, the initializer expression refers to the static data member running
of class process. — end example ]
[ Note: Once the static data member has been defined, it exists even if no objects of its class have been
created. [ Example: in the example above, run_chain and running exist even if no objects of class process
are created by the program. — end example ] — end note ]
3 If a static data member is of const literal type, its declaration in the class definition can specify a brace-orequal-initializer in which every initializer-clause that is an assignment-expression is a constant expression.
A static data member of literal type can be declared in the class definition with the constexpr specifier;
if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an
assignment-expression is a constant expression. [ Note: In both these cases, the member may appear in
constant expressions. — end note ] The member shall still be defined in a namespace scope if it is odrused (3.2) in the program and the namespace scope definition shall not contain an initializer.
4 [ Note: There shall be exactly one definition of a static data member that is odr-used (3.2) in a program;
no diagnostic is required. — end note ] Unnamed classes and classes contained directly or indirectly within
unnamed classes shall not contain static data members.
5 Static data members of a class in namespace scope have external linkage (3.5). A local class shall not have
static data members.
6 Static data members are initialized and destroyed exactly like non-local variables (3.6.2, 3.6.3).
7 A static data member shall not be mutable (7.1.1).
9.5 Unions [class.union]
1 In a union, at most one of the non-static data members can be active at any time, that is, the value of at
most one of the non-static data members can be stored in a union at any time. [ Note: One special guarantee
is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout
structs that share a common initial sequence (9.2), and if an object of this standard-layout union type
contains one of the standard-layout structs, it is permitted to inspect the common initial sequence of any of
standard-layout struct members; see 9.2. — end note ] The size of a union is sufficient to contain the largest
of its non-static data members. Each non-static data member is allocated as if it were the sole member of a
struct.
§ 9.5 225

 c ISO/IEC N3242=11-0012
2 A union can have member functions (including constructors and destructors), but not virtual (10.3) functions.
A union shall not have base classes. A union shall not be used as a base class. If a union contains a non-static
data member of reference type the program is ill-formed. At most one non-static data member of a union may
have a brace-or-equal-initializer. [ Note: If any non-static data member of a union has a non-trivial default
constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move
assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be
user-provided or it will be implicitly deleted (8.4.3) for the union. — end note ]
3 [ Example: Consider the following union:
union U {
int i;
float f;
std::string s;
};
Since std::string (21.3) declares non-trivial versions of all of the special member functions, U will have
an implicitly deleted default constructor, copy/move constructor, copy/move assignment operator, and destructor. To use U, some or all of these member functions must be user-provided. — end example ]
4 [ Note: In general, one must use explicit destructor calls and placement new operators to change the active
member of a union. — end note ] [ Example: Consider an object u of a union type U having non-static data
members m of type M and n of type N. If M has a non-trivial destructor and N has a non-trivial constructor
(for instance, if they declare or inherit virtual functions), the active member of u can be safely switched
from m to n using the destructor and placement new operator as follows:
u.m.~M();
new (&u.n) N;
— end example ]
5 A union of the form
union { member-specification } ;
is called an anonymous union; it defines an unnamed object of unnamed type. The member-specification of
an anonymous union shall only define non-static data members. [ Note: Nested types and functions cannot
be declared within an anonymous union. — end note ] The names of the members of an anonymous union
shall be distinct from the names of any other entity in the scope in which the anonymous union is declared.
For the purpose of name lookup, after the anonymous union definition, the members of the anonymous union
are considered to have been defined in the scope in which the anonymous union is declared. [ Example:
void f() {
union { int a; const char* p; };
a = 1;
p = "Jennifer";
}
Here a and p are used like ordinary (nonmember) variables, but since they are union members they have
the same address. — end example ]
6 Anonymous unions declared in a named namespace or in the global namespace shall be declared static.
Anonymous unions declared at block scope shall be declared with any storage class allowed for a block-scope
variable, or with no storage class. A storage class is not allowed in a declaration of an anonymous union
in a class scope. An anonymous union shall not have private or protected members (Clause 11). An
anonymous union shall not have function members.
§ 9.5 226

 c ISO/IEC N3242=11-0012
7 A union for which objects or pointers are declared is not an anonymous union. [ Example:
union { int aa; char* p; } obj, *ptr = &obj;
aa = 1; // error
ptr->aa = 1; // OK
The assignment to plain aa is ill-formed since the member name is not visible outside the union, and even
if it were visible, it is not associated with any particular object. — end example ] [ Note: Initialization of
unions with no user-declared constructors is described in (8.5.1). — end note ]
8 A union-like class is a union or a class that has an anonymous union as a direct member. A union-like
class X has a set of variant members. If X is a union its variant members are the non-static data members;
otherwise, its variant members are the non-static data members of all anonymous unions that are members
of X.
9.6 Bit-fields [class.bit]
1 A member-declarator of the form
identifieropt attribute-specifier-seqopt: constant-expression
specifies a bit-field; its length is set off from the bit-field name by a colon. The optional attribute-specifierseq appertains to the entity being declared. The bit-field attribute is not part of the type of the class
member. The constant-expression shall be an integral constant expression with a value greater than or equal
to zero. The value of the integral constant expression may be larger than the number of bits in the object
representation (3.9) of the bit-field’s type; in such cases the extra bits are used as padding bits and do not
participate in the value representation (3.9) of the bit-field. Allocation of bit-fields within a class object is
implementation-defined. Alignment of bit-fields is implementation-defined. Bit-fields are packed into some
addressable allocation unit. [ Note: Bit-fields straddle allocation units on some machines and not on others.
Bit-fields are assigned right-to-left on some machines, left-to-right on others. — end note ]
2 A declaration for a bit-field that omits the identifier declares an unnamed bit-field. Unnamed bit-fields
are not members and cannot be initialized. [ Note: An unnamed bit-field is useful for padding to conform
to externally-imposed layouts. — end note ] As a special case, an unnamed bit-field with a width of zero
specifies alignment of the next bit-field at an allocation unit boundary. Only when declaring an unnamed
bit-field may the value of the constant-expression be equal to zero.
3 A bit-field shall not be a static member. A bit-field shall have integral or enumeration type (3.9.1). It is
implementation-defined whether a plain (neither explicitly signed nor unsigned) char, short, int, long,
or long long bit-field is signed or unsigned. A bool value can successfully be stored in a bit-field of any
nonzero size. The address-of operator & shall not be applied to a bit-field, so there are no pointers to bitfields. A non-const reference shall not be bound to a bit-field (8.5.3). [ Note: If the initializer for a reference
of type const T& is an lvalue that refers to a bit-field, the reference is bound to a temporary initialized to
hold the value of the bit-field; the reference is not bound to the bit-field directly. See 8.5.3. — end note ]
4 If the value true or false is stored into a bit-field of type bool of any size (including a one bit bit-field),
the original bool value and the value of the bit-field shall compare equal. If the value of an enumerator is
stored into a bit-field of the same enumeration type and the number of bits in the bit-field is large enough
to hold all the values of that enumeration type (7.2), the original enumerator value and the value of the
bit-field shall compare equal. [ Example:
enum BOOL { FALSE=0, TRUE=1 };
struct A {
BOOL b:1;
};
A a;
§ 9.6 227

 c ISO/IEC N3242=11-0012
void f() {
a.b = TRUE;
if (a.b == TRUE) // yields true
{ /∗ ... ∗/ }
} —
end example ]
9.7 Nested class declarations [class.nest]
1 A class can be declared within another class. A class declared within another is called a nested class. The
name of a nested class is local to its enclosing class. The nested class is in the scope of its enclosing class.
[ Note: See 5.1 for restrictions on the use of non-static data members and non-static member functions.
— end note ]
[ Example:
int x;
int y;
struct enclose {
int x;
static int s;
struct inner {
void f(int i) {
int a = sizeof(x); // OK: operand of sizeof is an unevaluated operand
x = i; // error: assign to enclose::x
s = i; // OK: assign to enclose::s
::x = i; // OK: assign to global x
y = i; // OK: assign to global y
}
void g(enclose* p, int i) {
p->x = i; // OK: assign to enclose::x
}
};
};
inner* p = 0; // error: inner not in scope
— end example ]
2 Member functions and static data members of a nested class can be defined in a namespace scope enclosing
the definition of their class. [ Example:
struct enclose {
struct inner {
static int x;
void f(int i);
};
};
int enclose::inner::x = 1;
void enclose::inner::f(int i) { /∗ ... ∗/ }
§ 9.7 228

 c ISO/IEC N3242=11-0012
— end example ]
3 If class X is defined in a namespace scope, a nested class Y may be declared in class X and later defined in the
definition of class X or be later defined in a namespace scope enclosing the definition of class X. [ Example:
class E {
class I1; // forward declaration of nested class
class I2;
class I1 { }; // definition of nested class
};
class E::I2 { }; // definition of nested class
— end example ]
4 Like a member function, a friend function (11.3) defined within a nested class is in the lexical scope of that
class; it obeys the same rules for name binding as a static member function of that class (9.4), but it has no
special access rights to members of an enclosing class.
9.8 Local class declarations [class.local]
1 A class can be declared within a function definition; such a class is called a local class. The name of a
local class is local to its enclosing scope. The local class is in the scope of the enclosing scope, and has the
same access to names outside the function as does the enclosing function. Declarations in a local class can
use only type names, static variables, extern variables and functions, and enumerators from the enclosing
scope. [ Example:
int x;
void f() {
static int s ;
int x;
extern int g();
struct local {
int g() { return x; } // error: x has automatic storage duration
int h() { return s; } // OK
int k() { return ::x; } // OK
int l() { return g(); } // OK
};
}
local* p = 0; // error: local not in scope
— end example ]
2 An enclosing function has no special access to members of the local class; it obeys the usual access rules
(Clause 11). Member functions of a local class shall be defined within their class definition, if they are
defined at all.
3 If class X is a local class a nested class Y may be declared in class X and later defined in the definition of
class X or be later defined in the same scope as the definition of class X. A class nested within a local class
is a local class.
4 A local class shall not have static data members.
9.9 Nested type names [class.nested.type]
1 Type names obey exactly the same scope rules as other names. In particular, type names defined within a
class definition cannot be used outside their class without qualification. [ Example:
§ 9.9 229

 c ISO/IEC N3242=11-0012
struct X {
typedef int I;
class Y { /∗ ... ∗/ };
I a;
};
I b; // error
Y c; // error
X::Y d; // OK
X::I e; // OK
— end example ]
§ 9.9 230

 c ISO/IEC N3242=11-0012
10 Derived classes [class.derived]
1 A list of base classes can be specified in a class definition using the notation:
base-clause:
: base-specifier-list
base-specifier-list:
base-specifier ...opt
base-specifier-list , base-specifier ...opt
base-specifier:
attribute-specifier-seqopt base-type-specifier
attribute-specifier-seqoptvirtual access-specifieropt base-type-specifier
attribute-specifier-seqopt access-specifier virtualopt base-type-specifier
class-or-decltype:
::opt nested-name-specifieropt class-name
decltype-specifier
base-type-specifier:
class-or-decltype
access-specifier:
private
protected
public
The optional attribute-specifier-seq appertains to the base-specifier.
2 The type denoted by a base-type-specifier shall be a class type that is not an incompletely defined class
(Clause 9); this class is called a direct base class for the class being defined. During the lookup for a base
class name, non-type names are ignored (3.3.10). If the name found is not a class-name, the program is
ill-formed. A class B is a base class of a class D if it is a direct base class of D or a direct base class of one of
D’s base classes. A class is an indirect base class of another if it is a base class but not a direct base class.
A class is said to be (directly or indirectly) derived from its (direct or indirect) base classes. [ Note: See
Clause 11 for the meaning of access-specifier. — end note ] Unless redeclared in the derived class, members
of a base class are also considered to be members of the derived class. The base class members are said to
be inherited by the derived class. Inherited members can be referred to in expressions in the same manner
as other members of the derived class, unless their names are hidden or ambiguous (10.2). [ Note: The scope
resolution operator :: (5.1) can be used to refer to a direct or indirect base member explicitly. This allows
access to a name that has been redeclared in the derived class. A derived class can itself serve as a base class
subject to access control; see 11.2. A pointer to a derived class can be implicitly converted to a pointer to
an accessible unambiguous base class (4.10). An lvalue of a derived class type can be bound to a reference
to an accessible unambiguous base class (8.5.3). — end note ]
3 The base-specifier-list specifies the type of the base class subobjects contained in an object of the derived
class type. [ Example:
struct Base {
int a, b, c;
};
struct Derived : Base {
int b;
231

 c ISO/IEC N3242=11-0012
};
struct Derived2 : Derived {
int c;
};
Here, an object of class Derived2 will have a subobject of class Derived which in turn will have a subobject
of class Base. — end example ]
4 A base-specifier followed by an ellipsis is a pack expansion (14.5.3).
5 The order in which the base class subobjects are allocated in the most derived object (1.8) is unspecified.
[ Note: a derived class and its base class subobjects can be represented by a directed acyclic graph (DAG)
where an arrow means “directly derived from.” A DAG of subobjects is often referred to as a “subobject
lattice.”
Base
Derived1
Derived2
Figure 2 — Directed acyclic graph
6 The arrows need not have a physical representation in memory. — end note ]
7 [ Note: Initialization of objects representing base classes can be specified in constructors; see 12.6.2. — end
note ]
8 [ Note: A base class subobject might have a layout (3.7) different from the layout of a most derived object
of the same type. A base class subobject might have a polymorphic behavior (12.7) different from the
polymorphic behavior of a most derived object of the same type. A base class subobject may be of zero
size (Clause 9); however, two subobjects that have the same class type and that belong to the same most
derived object must not be allocated at the same address (5.10). — end note ]
9 In a class definition marked with the class-virt-specifier explicit, if a virtual member function that is neither
implicitly declared nor a destructor overrides (10.3) a member function of a base class and it is not marked
with the virt-specifier override, the program is ill-formed. Similarly, in such a class definition, if a class
member name other than that of an implicitly-declared special member function hides (3.3.10, 10.2) a class
member name in a base class and it is not marked new, the program is ill-formed, unless the class member is
a member function that overrides the corresponding member in the base class. [ Note: A using-declaration
makes the potentially hidden name visible, avoiding the need for the new marker. — end note ]
[ Example:
class B {
virtual void some_func();
virtual void f(int);
virtual void h(int);
void j(int);
void k();
typedef B self;
232

 c ISO/IEC N3242=11-0012
};
class D explicit : public B {
void sone_func() override; // error: misspelled name
void f(int) override; // OK: f implicitly virtual, overrides B::f
virtual void f(long) override; // error: non-matching argument type
virtual void f(int) const override; // error: non-matching cv-qualification
virtual int f(int) override; // error: non-matching return type
virtual void g(long); // OK: new virtual function introduced
void h(int); // error: h implicitly virtual, but overriding without marker
virtual void h(double); // error: hides B::h without marker
virtual void h(char *) new; // OK
using B::j;
int j(double); // OK: not hiding due to “using”
void j(int); // OK, despite ‘obscuring’ B::j(int)
virtual int j(void) new; // error: not hiding due to “using”
int k; // error: hides B::k without marker
int m(int) new; // error: no hiding despite marker
typedef D self; // error: hides B::self without marker
};
— end example ]
10.1 Multiple base classes [class.mi]
1 A class can be derived from any number of base classes. [ Note: The use of more than one direct base class
is often called multiple inheritance. — end note ] [ Example:
class A { /∗ ... ∗/ };
class B { /∗ ... ∗/ };
class C { /∗ ... ∗/ };
class D : public A, public B, public C { /∗ ... ∗/ };
— end example ]
2 [ Note: The order of derivation is not significant except as specified by the semantics of initialization by
constructor (12.6.2), cleanup (12.4), and storage layout (9.2, 11.1). — end note ]
3 A class shall not be specified as a direct base class of a derived class more than once. [ Note: A class can
be an indirect base class more than once and can be a direct and an indirect base class. There are limited
things that can be done with such a class. The non-static data members and member functions of the direct
base class cannot be referred to in the scope of the derived class. However, the static members, enumerations
and types can be unambiguously referred to. — end note ] [ Example:
class X { /∗ ... ∗/ };
class Y : public X, public X { /∗ ... ∗/ }; // ill-formed
class L { public: int next; /∗ ... ∗/ };
class A : public L { /∗ ... ∗/ };
class B : public L { /∗ ... ∗/ };
class C : public A, public B { void f(); /∗ ... ∗/ }; // well-formed
class D : public A, public L { void f(); /∗ ... ∗/ }; // well-formed
— end example ]
§ 10.1 233

 c ISO/IEC N3242=11-0012
4 A base class specifier that does not contain the keyword virtual, specifies a non-virtual base class. A base
class specifier that contains the keyword virtual, specifies a virtual base class. For each distinct occurrence
of a non-virtual base class in the class lattice of the most derived class, the most derived object (1.8) shall
contain a corresponding distinct base class subobject of that type. For each distinct base class that is
specified virtual, the most derived object shall contain a single base class subobject of that type. [ Example:
for an object of class type C, each distinct occurrence of a (non-virtual) base class L in the class lattice of
C corresponds one-to-one with a distinct L subobject within the object of type C. Given the class C defined
above, an object of class C will have two subobjects of class L as shown below.
L L
A B
C
Figure 3 — Non-virtual base
5 In such lattices, explicit qualification can be used to specify which subobject is meant. The body of function
C::f could refer to the member next of each L subobject:
void C::f() { A::next = B::next; } // well-formed
Without the A:: or B:: qualifiers, the definition of C::f above would be ill-formed because of ambiguity (10.2).
6 For another example,
class V { /∗ ... ∗/ };
class A : virtual public V { /∗ ... ∗/ };
class B : virtual public V { /∗ ... ∗/ };
class C : public A, public B { /∗ ... ∗/ };
for an object c of class type C, a single subobject of type V is shared by every base subobject of c that has
a virtual base class of type V. Given the class C defined above, an object of class C will have one subobject
of class V, as shown below.
V
A B
C
Figure 4 — Virtual base
7 A class can have both virtual and non-virtual base classes of a given type.
class B { /∗ ... ∗/ };
class X : virtual public B { /∗ ... ∗/ };
§ 10.1 234

 c ISO/IEC N3242=11-0012
class Y : virtual public B { /∗ ... ∗/ };
class Z : public B { /∗ ... ∗/ };
class AA : public X, public Y, public Z { /∗ ... ∗/ };
For an object of class AA, all virtual occurrences of base class B in the class lattice of AA correspond to a
single B subobject within the object of type AA, and every other occurrence of a (non-virtual) base class B
in the class lattice of AA corresponds one-to-one with a distinct B subobject within the object of type AA.
Given the class AA defined above, class AA has two subobjects of class B: Z’s B and the virtual B shared by X
and Y, as shown below.
B B
AA
X Y Z
Figure 5 — Virtual and non-virtual base
— end example ]
10.2 Member name lookup [class.member.lookup]
1 Member name lookup determines the meaning of a name (id-expression) in a class scope (3.3.7). Name
lookup can result in an ambiguity, in which case the program is ill-formed. For an id-expression, name
lookup begins in the class scope of this; for a qualified-id, name lookup begins in the scope of the nestedname-specifier. Name lookup takes place before access control (3.4, Clause 11).
2 The following steps define the result of name lookup for a member name f in a class scope C.
3 The lookup set for f in C, called S(f, C), consists of two component sets: the declaration set, a set of members
named f; and the subobject set, a set of subobjects where declarations of these members (possibly including
using-declarations) were found. In the declaration set, using-declarations are replaced by the members they
designate, and type declarations (including injected-class-names) are replaced by the types they designate.
S(f, C) is calculated as follows:
4 If C contains a declaration of the name f, the declaration set contains every declaration of f declared in
C that satisfies the requirements of the language construct in which the lookup occurs. [ Note: Looking
up a name in an elaborated-type-specifier (3.4.4) or base-specifier (Clause 10), for instance, ignores all nontype declarations, while looking up a name in a nested-name-specifier (3.4.3) ignores function, variable, and
enumerator declarations. As another example, looking up a name in a using-declaration (7.3.3) includes the
declaration of a class or enumeration that would ordinarily be hidden by another declaration of that name
in the same scope. — end note ] If the resulting declaration set is not empty, the subobject set contains C
itself, and calculation is complete.
5 Otherwise (i.e., C does not contain a declaration of f or the resulting declaration set is empty), S(f, C) is
initially empty. If C has base classes, calculate the lookup set for f in each direct base class subobject Bi,
and merge each such lookup set S(f, Bi) in turn into S(f, C).
6 The following steps define the result of merging lookup set S(f, Bi) into the intermediate S(f, C):
§ 10.2 235

 c ISO/IEC N3242=11-0012
— If each of the subobject members of S(f, Bi) is a base class subobject of at least one of the subobject
members of S(f, C), or if S(f, Bi) is empty, S(f, C) is unchanged and the merge is complete. Conversely, if each of the subobject members of S(f, C) is a base class subobject of at least one of the
subobject members of S(f, Bi), or if S(f, C) is empty, the new S(f, C) is a copy of S(f, Bi).
— Otherwise, if the declaration sets of S(f, Bi) and S(f, C) differ, the merge is ambiguous: the new
S(f, C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent
merges, an invalid declaration set is considered different from any other.
— Otherwise, the new S(f, C) is a lookup set with the shared set of declarations and the union of the
subobject sets.
7 The result of name lookup for f in C is the declaration set of S(f, C). If it is an invalid set, the program is
ill-formed. [ Example:
struct A { int x; }; // S(x,A) = { { A::x }, { A } }
struct B { float x; }; // S(x,B) = { { B::x }, { B } }
struct C: public A, public B { }; // S(x,C) = { invalid, { A in C, B in C } }
struct D: public virtual C { }; // S(x,D) = S(x,C)
struct E: public virtual C { char x; }; // S(x,E) = { { E::x }, { E } }
struct F: public D, public E { }; // S(x,F) = S(x,E)
int main() {
F f;
f.x = 0; // OK, lookup finds E::x
}
S(x, F) is unambiguous because the A and B base subobjects of D are also base subobjects of E, so S(x, D)
is discarded in the first merge step. — end example ]
8 If the name of an overloaded function is unambiguously found, overloading resolution (13.3) also takes
place before access control. Ambiguities can often be resolved by qualifying a name with its class name.
[ Example:
struct A {
int f();
};
struct B {
int f();
};
struct C : A, B {
int f() { return A::f() + B::f(); }
};
— end example ]
9 [ Note: A static member, a nested type or an enumerator defined in a base class T can unambiguously be
found even if an object has more than one base class subobject of type T. Two base class subobjects share
the non-static member subobjects of their common virtual base classes. — end note ] [ Example:
struct V {
int v;
};
struct A {
int a;
static int s;
§ 10.2 236

 c ISO/IEC N3242=11-0012
enum { e };
};
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void f(D* pd) {
pd->v++; // OK: only one v (virtual)
pd->s++; // OK: only one s (static)
int i = pd->e; // OK: only one e (enumerator)
pd->a++; // error, ambiguous: two as in D
}
— end example ]
10 [ Note: When virtual base classes are used, a hidden declaration can be reached along a path through the
subobject lattice that does not pass through the hiding declaration. This is not an ambiguity. The identical
use with non-virtual base classes is an ambiguity; in that case there is no unique instance of the name that
hides all the others. — end note ] [ Example:
struct V { int f(); int x; };
struct W { int g(); int y; };
struct B : virtual V, W {
int f(); int x;
int g(); int y;
};
struct C : virtual V, W { };
struct D : B, C { void glorp(); };
W V W
B C
D
Figure 6 — Name lookup
11 [ Note: The names declared in V and the left-hand instance of W are hidden by those in B, but the names
declared in the right-hand instance of W are not hidden at all. — end note ]
void D::glorp() {
x++; // OK: B::x hides V::x
f(); // OK: B::f() hides V::f()
y++; // error: B::y and C’s W::y
g(); // error: B::g() and C’s W::g()
}
— end example ]
§ 10.2 237

 c ISO/IEC N3242=11-0012
12 An explicit or implicit conversion from a pointer to or an expression designating an object of a derived class
to a pointer or reference to one of its base classes shall unambiguously refer to a unique object representing
the base class. [ Example:
struct V { };
struct A { };
struct B : A, virtual V { };
struct C : A, virtual V { };
struct D : B, C { };
void g() {
D d;
B* pb = &d;
A* pa = &d; // error, ambiguous: C’s A or B’s A?
V* pv = &d; // OK: only one V subobject
}
— end example ]
13 [ Note: Even if the result of name lookup is unambiguous, use of a name found in multiple subobjects might
still be ambiguous (4.11, 5.2.5, 11.2). — end note ] [ Example:
struct B1 {
void f();
static void f(int);
int i;
};
struct B2 {
void f(double);
};
struct I1: B1 { };
struct I2: B1 { };
struct D: I1, I2, B2 {
using B1::f;
using B2::f;
void g() {
f(); // Ambiguous conversion of this
f(0); // Unambiguous (static)
f(0.0); // Unambiguous (only one B2)
int B1::* mpB1 = &D::i; // Unambiguous
int D::* mpD = &D::i; // Ambiguous conversion
}
};
— end example ]
10.3 Virtual functions [class.virtual]
1 Virtual functions support dynamic binding and object-oriented programming. A class that declares or
inherits a virtual function is called a polymorphic class.
2 If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly
from Base, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualification, and refqualifier (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is
§ 10.3 238

 c ISO/IEC N3242=11-0012
so declared) and it overrides111 Base::vf. For convenience we say that any virtual function overrides itself.
A virtual member function C::vf of a class object S is a final overrider unless the most derived class (1.8)
of which S is a base class subobject (if any) declares or inherits another member function that overrides vf.
In a derived class, if a virtual member function of a base class subobject has more than one final overrider
the program is ill-formed. [ Example:
struct A {
virtual void f();
};
struct B : virtual A {
virtual void f();
};
struct C : B , virtual A {
using A::f;
};
void foo() {
C c;
c.f(); // calls B::f, the final overrider
c.C::f(); // calls A::f because of the using-declaration
}
— end example ]
[ Example:
struct A { virtual void f(); };
struct B : A { };
struct C : A { void f(); };
struct D : B, C { }; // OK: A::f and C::f are the final overriders
// for the B and C subobjects, respectively
— end example ]
3 [ Note: A virtual member function does not have to be visible to be overridden, for example,
struct B {
virtual void f();
};
struct D : B {
void f(int);
};
struct D2 : D {
void f();
};
the function f(int) in class D hides the virtual function f() in its base class B; D::f(int) is not a virtual
function. However, f() declared in class D2 has the same name and the same parameter list as B::f(), and
therefore is a virtual function that overrides the function B::f() even though B::f() is not visible in class
D2. — end note ]
4 If a virtual function f in some class B is marked with the virt-specifier final and in a class D derived from
B a function D::f overrides B::f, the program is ill-formed. [ Example:
111) A function with the same name but a different parameter list (Clause 13) as a virtual function is not necessarily virtual
and does not override. The use of the virtual specifier in the declaration of an overriding function is legal but redundant (has
empty semantics). Access control (Clause 11) is not considered in determining overriding.
§ 10.3 239

 c ISO/IEC N3242=11-0012
struct B {
virtual void f() const final;
};
struct D : B {
void f() const; // error: D::f attempts to override final B::f
};
— end example ]
5 If a virtual function is marked with the virt-specifier override and does not override a member function of
a base class, the program is ill-formed. [ Example:
struct B {
virtual void f();
};
struct D : B {
void f(long) override; // error: wrong signature overriding B::f
void f(int) override; // OK
};
— end example ]
6 Even though destructors are not inherited, a destructor in a derived class overrides a base class destructor
declared virtual; see 12.4 and 12.5.
7 The return type of an overriding function shall be either identical to the return type of the overridden
function or covariant with the classes of the functions. If a function D::f overrides a function B::f, the
return types of the functions are covariant if they satisfy the following criteria:
— both are pointers to classes, both are lvalue references to classes, or both are rvalue references to
classes112
— the class in the return type of B::f is the same class as the class in the return type of D::f, or is an
unambiguous and accessible direct or indirect base class of the class in the return type of D::f
— both pointers or references have the same cv-qualification and the class type in the return type of D::f
has the same cv-qualification as or less cv-qualification than the class type in the return type of B::f.
8 If the return type of D::f differs from the return type of B::f, the class type in the return type of D::f shall
be complete at the point of declaration of D::f or shall be the class type D. When the overriding function
is called as the final overrider of the overridden function, its result is converted to the type returned by the
(statically chosen) overridden function (5.2.2). [ Example:
class B { };
class D : private B { friend class Derived; };
struct Base {
virtual void vf1();
virtual void vf2();
virtual void vf3();
virtual B* vf4();
virtual B* vf5();
void f();
};
112) Multi-level pointers to classes or references to multi-level pointers to classes are not allowed.
§ 10.3 240

 c ISO/IEC N3242=11-0012
struct No_good : public Base {
D* vf4(); // error: B (base class of D) inaccessible
};
class A;
struct Derived : public Base {
void vf1(); // virtual and overrides Base::vf1()
void vf2(int); // not virtual, hides Base::vf2()
char vf3(); // error: invalid difference in return type only
D* vf4(); // OK: returns pointer to derived class
A* vf5(); // error: returns pointer to incomplete class
void f();
};
void g() {
Derived d;
Base* bp = &d; // standard conversion:
// Derived* to Base*
bp->vf1(); // calls Derived::vf1()
bp->vf2(); // calls Base::vf2()
bp->f(); // calls Base::f() (not virtual)
B* p = bp->vf4(); // calls Derived::pf() and converts the
// result to B*
Derived* dp = &d;
D* q = dp->vf4(); // calls Derived::pf() and does not
// convert the result to B*
dp->vf2(); // ill-formed: argument mismatch
} —
end example ]
9 [ Note: The interpretation of the call of a virtual function depends on the type of the object for which it is
called (the dynamic type), whereas the interpretation of a call of a non-virtual member function depends
only on the type of the pointer or reference denoting that object (the static type) (5.2.2). — end note ]
10 [ Note: The virtual specifier implies membership, so a virtual function cannot be a nonmember (7.1.2)
function. Nor can a virtual function be a static member, since a virtual function call relies on a specific
object for determining which function to invoke. A virtual function declared in one class can be declared a
friend in another class. — end note ]
11 A virtual function declared in a class shall be defined, or declared pure (10.4) in that class, or both; but no
diagnostic is required (3.2).
12 [ Example: here are some uses of virtual functions with multiple base classes:
struct A {
virtual void f();
};
struct B1 : A { // note non-virtual derivation
void f();
};
struct B2 : A {
void f();
};
§ 10.3 241

 c ISO/IEC N3242=11-0012
struct D : B1, B2 { // D has two separate A subobjects
};
void foo() {
D d;
// A* ap = &d; // would be ill-formed: ambiguous
B1* b1p = &d;
A* ap = b1p;
D* dp = &d;
ap->f(); // calls D::B1::f
dp->f(); // ill-formed: ambiguous
}
In class D above there are two occurrences of class A and hence two occurrences of the virtual member
function A::f. The final overrider of B1::A::f is B1::f and the final overrider of B2::A::f is B2::f.
13 The following example shows a function that does not have a unique final overrider:
struct A {
virtual void f();
};
struct VB1 : virtual A { // note virtual derivation
void f();
};
struct VB2 : virtual A {
void f();
};
struct Error : VB1, VB2 { // ill-formed
};
struct Okay : VB1, VB2 {
void f();
};
Both VB1::f and VB2::f override A::f but there is no overrider of both of them in class Error. This
example is therefore ill-formed. Class Okay is well formed, however, because Okay::f is a final overrider.
14 The following example uses the well-formed classes from above.
struct VB1a : virtual A { // does not declare f
};
struct Da : VB1a, VB2 {
};
void foe() {
VB1a* vb1ap = new Da;
vb1ap->f(); // calls VB2::f
} —
end example ]
15 Explicit qualification with the scope operator (5.1) suppresses the virtual call mechanism. [ Example:
§ 10.3 242

 c ISO/IEC N3242=11-0012
class B { public: virtual void f(); };
class D : public B { public: void f(); };
void D::f() { /∗ ... ∗/ B::f(); }
Here, the function call in D::f really does call B::f and not D::f. — end example ]
16 A function with a deleted definition (8.4) shall not override a function that does not have a deleted definition.
Likewise, a function that does not have a deleted definition shall not override a function with a deleted
definition.
10.4 Abstract classes [class.abstract]
1 The abstract class mechanism supports the notion of a general concept, such as a shape, of which only more
concrete variants, such as circle and square, can actually be used. An abstract class can also be used to
define an interface for which derived classes provide a variety of implementations.
2 An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract
class can be created except as subobjects of a class derived from it. A class is abstract if it has at least
one pure virtual function. [ Note: Such a function might be inherited: see below. — end note ] A virtual
function is specified pure by using a pure-specifier (9.2) in the function declaration in the class definition. A
pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1).
[ Example:
class point { /∗ ... ∗/ };
class shape { // abstract class
point center;
public:
point where() { return center; }
void move(point p) { center=p; draw(); }
virtual void rotate(int) = 0; // pure virtual
virtual void draw() = 0; // pure virtual
};
— end example ] [ Note: A function declaration cannot provide both a pure-specifier and a definition — end
note ] [ Example:
struct C {
virtual void f() = 0 { }; // ill-formed
};
— end example ]
3 An abstract class shall not be used as a parameter type, as a function return type, or as the type of an
explicit conversion. Pointers and references to an abstract class can be declared. [ Example:
shape x; // error: object of abstract class
shape* p; // OK
shape f(); // error
void g(shape); // error
shape& h(shape&); // OK
— end example ]
4 A class is abstract if it contains or inherits at least one pure virtual function for which the final overrider is
pure virtual. [ Example:
§ 10.4 243

 c ISO/IEC N3242=11-0012
class ab_circle : public shape {
int radius;
public:
void rotate(int) { }
// ab_circle::draw() is a pure virtual
};
Since shape::draw() is a pure virtual function ab_circle::draw() is a pure virtual by default. The
alternative declaration,
class circle : public shape {
int radius;
public:
void rotate(int) { }
void draw(); // a definition is required somewhere
};
would make class circle nonabstract and a definition of circle::draw() must be provided. — end example ]
5 [ Note: An abstract class can be derived from a class that is not abstract, and a pure virtual function may
override a virtual function which is not pure. — end note ]
6 Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a
virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed)
from such a constructor (or destructor) is undefined.
§ 10.4 244

 c ISO/IEC N3242=11-0012
11 Member access control [class.access]
1 A member of a class can be
— private; that is, its name can be used only by members and friends of the class in which it is declared.
— protected; that is, its name can be used only by members and friends of the class in which it is
declared, by classes derived from that class, and by their friends (see 11.4).
— public; that is, its name can be used anywhere without access restriction.
2 A member of a class can also access all the names to which the class has access. A local class of a member
function may access the same names that the member function itself may access.113
3 Members of a class defined with the keyword class are private by default. Members of a class defined
with the keywords struct or union are public by default. [ Example:
class X {
int a; // X::a is private by default
};
struct S {
int a; // S::a is public by default
};
— end example ]
4 Access control is applied uniformly to all names, whether the names are referred to from declarations or
expressions. [ Note: Access control applies to names nominated by friend declarations (11.3) and usingdeclarations (7.3.3). — end note ] In the case of overloaded function names, access control is applied to the
function selected by overload resolution. [ Note: Because access control applies to names, if access control is
applied to a typedef name, only the accessibility of the typedef name itself is considered. The accessibility
of the entity referred to by the typedef is not considered. For example,
class A {
class B { };
public:
typedef B BB;
};
void f() {
A::BB x; // OK, typedef name A::BB is public
A::B y; // access error, A::B is private
}
— end note ]
5 It should be noted that it is access to members and base classes that is controlled, not their visibility. Names
of members are still visible, and implicit conversions to base classes are still considered, when those members
and base classes are inaccessible. The interpretation of a given construct is established without regard to
113) Access permissions are thus transitive and cumulative to nested and local classes.
245

 c ISO/IEC N3242=11-0012
access control. If the interpretation established makes use of inaccessible member names or base classes, the
construct is ill-formed.
6 All access controls in Clause 11 affect the ability to access a class member name from a particular scope.
For purposes of access control, the base-specifiers of a class and the definitions of class members that appear
outside of the class definition are considered to be within the scope of that class. In particular, access
controls apply as usual to member names accessed as part of a function return type, even though it is not
possible to determine the access privileges of that use without first parsing the rest of the function declarator.
Similarly, access control for implicit calls to the constructors, the conversion functions, or the destructor
called to create and destroy a static data member is performed as if these calls appeared in the scope of the
member’s class. [ Example:
class A {
typedef int I; // private member
I f();
friend I g(I);
static I x;
protected:
struct B { };
};
A::I A::f() { return 0; }
A::I g(A::I p = A::x);
A::I g(A::I p) { return 0; }
A::I A::x = 0;
struct D: A::B, A { };
7 Here, all the uses of A::I are well-formed because A::f and A::x are members of class A and g is a friend
of class A. This implies, for example, that access checking on the first use of A::I must be deferred until it
is determined that this use of A::I is as the return type of a member of class A. Similarly, the use of A::B
as a base-specifier is well-formed because D is derived from A, so checking of base-specifiers must be deferred
until the entire base-specifier-list has been seen. — end example ]
8 The names in a default argument (8.3.6) are bound at the point of declaration, and access is checked at that
point rather than at any points of use of the default argument. Access checking for default arguments in
function templates and in member functions of class templates is performed as described in 14.7.1.
9 The names in a default template-argument (14.1) have their access checked in the context in which they
appear rather than at any points of use of the default template-argument. [ Example:
class B { };
template <class T> class C {
protected:
typedef T TT;
};
template <class U, class V = typename U::TT>
class D : public U { };
D <C<B> >* d; // access error, C::TT is protected
— end example ]
246

 c ISO/IEC N3242=11-0012
11.1 Access specifiers [class.access.spec]
1 Member declarations can be labeled by an access-specifier (Clause 10):
access-specifier : member-specificationopt
An access-specifier specifies the access rules for members following it until the end of the class or until
another access-specifier is encountered. [ Example:
class X {
int a; // X::a is private by default: class used
public:
int b; // X::b is public
int c; // X::c is public
};
— end example ]
2 Any number of access specifiers is allowed and no particular order is required. [ Example:
struct S {
int a; // S::a is public by default: struct used
protected:
int b; // S::b is protected
private:
int c; // S::c is private
public:
int d; // S::d is public
};
— end example ]
3 [ Note: The effect of access control on the order of allocation of data members is described in 9.2. — end
note ]
4 When a member is redeclared within its class definition, the access specified at its redeclaration shall be the
same as at its initial declaration. [ Example:
struct S {
class A;
enum E : int;
private:
class A { }; // error: cannot change access
enum E: int { e0 }; // error: cannot change access
};
— end example ]
5 [ Note: In a derived class, the lookup of a base class name will find the injected-class-name instead of the
name of the base class in the scope in which it was declared. The injected-class-name might be less accessible
than the name of the base class in the scope in which it was declared. — end note ]
[ Example:
class A { };
class B : private A { };
class C : public B {
A *p; // error: injected-class-name A is inaccessible
::A *q; // OK
};
§ 11.1 247

 c ISO/IEC N3242=11-0012
— end example ]
11.2 Accessibility of base classes and base class members [class.access.base]
1 If a class is declared to be a base class (Clause 10) for another class using the public access specifier, the
public members of the base class are accessible as public members of the derived class and protected
members of the base class are accessible as protected members of the derived class. If a class is declared to
be a base class for another class using the protected access specifier, the public and protected members
of the base class are accessible as protected members of the derived class. If a class is declared to be a base
class for another class using the private access specifier, the public and protected members of the base
class are accessible as private members of the derived class114.
2 In the absence of an access-specifier for a base class, public is assumed when the derived class is defined with
the class-key struct and private is assumed when the class is defined with the class-key class. [ Example:
class B { /∗ ... ∗/ };
class D1 : private B { /∗ ... ∗/ };
class D2 : public B { /∗ ... ∗/ };
class D3 : B { /∗ ... ∗/ }; // B private by default
struct D4 : public B { /∗ ... ∗/ };
struct D5 : private B { /∗ ... ∗/ };
struct D6 : B { /∗ ... ∗/ }; // B public by default
class D7 : protected B { /∗ ... ∗/ };
struct D8 : protected B { /∗ ... ∗/ };
Here B is a public base of D2, D4, and D6, a private base of D1, D3, and D5, and a protected base of D7 and
D8. — end example ]
3 [ Note: A member of a private base class might be inaccessible as an inherited member name, but accessible
directly. Because of the rules on pointer conversions (4.10) and explicit casts (5.4), a conversion from
a pointer to a derived class to a pointer to an inaccessible base class might be ill-formed if an implicit
conversion is used, but well-formed if an explicit cast is used. For example,
class B {
public:
int mi; // non-static member
static int si; // static member
};
class D : private B {
};
class DD : public D {
void f();
};
void DD::f() {
mi = 3; // error: mi is private in D
si = 3; // error: si is private in D
::B b;
b.mi = 3; // OK ( b.mi is different from this->mi)
b.si = 3; // OK ( b.si is different from this->si)
::B::si = 3; // OK
::B* bp1 = this; // error: B is a private base class
::B* bp2 = (::B*)this; // OK with cast
114) As specified previously in Clause 11, private members of a base class remain inaccessible even to derived classes unless
friend declarations within the base class definition are used to grant access explicitly.
§ 11.2 248

 c ISO/IEC N3242=11-0012
bp2->mi = 3; // OK: access through a pointer to B.
} —
end note ]
4 A base class B of N is accessible at R, if
— an invented public member of B would be a public member of N, or
— R occurs in a member or friend of class N, and an invented public member of B would be a private or
protected member of N, or
— R occurs in a member or friend of a class P derived from N, and an invented public member of B would
be a private or protected member of P, or
— there exists a class S such that B is a base class of S accessible at R and S is a base class of N accessible
at R.
[ Example:
class B {
public:
int m;
};
class S: private B {
friend class N;
};
class N: private S {
void f() {
B* p = this; // OK because class S satisfies the fourth condition
// above: B is a base class of N accessible in f() because
// B is an accessible base class of S and S is an accessible
// base class of N.
}
};
— end example ]
5 If a base class is accessible, one can implicitly convert a pointer to a derived class to a pointer to that base
class (4.10, 4.11). [ Note: It follows that members and friends of a class X can implicitly convert an X* to a
pointer to a private or protected immediate base class of X. — end note ] The access to a member is affected
by the class in which the member is named. This naming class is the class in which the member name was
looked up and found. [ Note: This class can be explicit, e.g., when a qualified-id is used, or implicit, e.g.,
when a class member access operator (5.2.5) is used (including cases where an implicit “this->” is added).
If both a class member access operator and a qualified-id are used to name the member (as in p->T::m), the
class naming the member is the class denoted by the nested-name-specifier of the qualified-id (that is, T).
— end note ] A member m is accessible at the point R when named in class N if
— m as a member of N is public, or
— m as a member of N is private, and R occurs in a member or friend of class N, or
— m as a member of N is protected, and R occurs in a member or friend of class N, or in a member or
friend of a class P derived from N, where m as a member of P is public, private, or protected, or
§ 11.2 249

 c ISO/IEC N3242=11-0012
— there exists a base class B of N that is accessible at R, and m is accessible at R when named in class B.
[ Example:
class B;
class A {
private:
int i;
friend void f(B*);
};
class B : public A { };
void f(B* p) {
p->i = 1; // OK: B* can be implicitly converted to A*,
// and f has access to i in A
} —
end example ]
6 If a class member access operator, including an implicit “this->,” is used to access a non-static data member
or non-static member function, the reference is ill-formed if the left operand (considered as a pointer in the
“.” operator case) cannot be implicitly converted to a pointer to the naming class of the right operand.
[ Note: This requirement is in addition to the requirement that the member be accessible as named. — end
note ]
11.3 Friends [class.friend]
1 A friend of a class is a function or class that is given permission to use the private and protected member
names from the class. A class specifies its friends, if any, by way of friend declarations. Such declarations give
special access rights to the friends, but they do not make the nominated friends members of the befriending
class. [ Example: the following example illustrates the differences between members and friends:
class X {
int a;
friend void friend_set(X*, int);
public:
void member_set(int);
};
void friend_set(X* p, int i) { p->a = i; }
void X::member_set(int i) { a = i; }
void f() {
X obj;
friend_set(&obj,10);
obj.member_set(10);
}
— end example ]
2 Declaring a class to be a friend implies that the names of private and protected members from the class
granting friendship can be accessed in the base-specifiers and member declarations of the befriended class.
[ Example:
class A {
class B { };
friend class X;
};
§ 11.3 250

 c ISO/IEC N3242=11-0012
struct X : A::B { // OK: A::B accessible to friend
A::B mx; // OK: A::B accessible to member of friend
class Y {
A::B my; // OK: A::B accessible to nested member of friend
};
};
— end example ] [ Example:
class X {
enum { a=100 };
friend class Y;
};
class Y {
int v[X::a]; // OK, Y is a friend of X
};
class Z {
int v[X::a]; // error: X::a is private
};
— end example ]
A class shall not be defined in a friend declaration. [ Example:
class A {
friend class B { }; // error: cannot define class in friend declaration
};
— end example ]
3 A friend declaration that does not declare a function shall have one of the following forms:
friend elaborated-type-specifier ;
friend simple-type-specifier ;
friend typename-specifier ;
[ Note: A friend declaration may be the declaration in a template-declaration (Clause 14, 14.5.4). — end
note ] If the type specifier in a friend declaration designates a (possibly cv-qualified) class type, that class
is declared as a friend; otherwise, the friend declaration is ignored. [ Example:
class C;
typedef C Ct;
class X1 {
friend C; // OK: class C is a friend
};
class X2 {
friend Ct; // OK: class C is a friend
friend D; // error: no type-name D in scope
friend class D; // OK: elaborated-type-specifier declares new class
};
template <typename T> class R {
friend T;
§ 11.3 251

 c ISO/IEC N3242=11-0012
};
R<C> rc; // class C is a friend of R<C>
R<int> Ri; // OK: "friend int;" is ignored
— end example ]
4 A function first declared in a friend declaration has external linkage (3.5). Otherwise, the function retains
its previous linkage (7.1.1).
5 When a friend declaration refers to an overloaded name or operator, only the function specified by the
parameter types becomes a friend. A member function of a class X can be a friend of a class Y. [ Example:
class Y {
friend char* X::foo(int);
friend X::X(char); // constructors can be friends
friend X::~X(); // destructors can be friends
};
— end example ]
6 A function can be defined in a friend declaration of a class if and only if the class is a non-local class (9.8),
the function name is unqualified, and the function has namespace scope. [ Example:
class M {
friend void f() { } // definition of global f, a friend of M,
// not the definition of a member function
};
— end example ]
7 Such a function is implicitly inline. A friend function defined in a class is in the (lexical) scope of the
class in which it is defined. A friend function defined outside the class is not (3.4.1).
8 No storage-class-specifier shall appear in the decl-specifier-seq of a friend declaration.
9 A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend
declaration. The meaning of the friend declaration is the same whether the friend declaration appears in
the private, protected or public (9.2) portion of the class member-specification.
10 Friendship is neither inherited nor transitive. [ Example:
class A {
friend class B;
int a;
};
class B {
friend class C;
};
class C {
void f(A* p) {
p->a++; // error: C is not a friend of A
// despite being a friend of a friend
}
};
§ 11.3 252

 c ISO/IEC N3242=11-0012
class D : public B {
void f(A* p) {
p->a++; // error: D is not a friend of A
// despite being derived from a friend
}
};
— end example ]
11 If a friend declaration appears in a local class (9.8) and the name specified is an unqualified name, a prior
declaration is looked up without considering scopes that are outside the innermost enclosing non-class scope.
For a friend function declaration, if there is no prior declaration, the program is ill-formed. For a friend class
declaration, if there is no prior declaration, the class that is specified belongs to the innermost enclosing
non-class scope, but if it is subsequently referenced, its name is not found by name lookup until a matching
declaration is provided in the innermost enclosing nonclass scope. [ Example:
class X;
void a();
void f() {
class Y;
extern void b();
class A {
friend class X; // OK, but X is a local class, not ::X
friend class Y; // OK
friend class Z; // OK, introduces local class Z
friend void a(); // error, ::a is not considered
friend void b(); // OK
friend void c(); // error
};
X *px; // OK, but ::X is found
Z *pz; // error, no Z is found
} —
end example ]
11.4 Protected member access [class.protected]
1 An additional access check beyond those described earlier in Clause 11 is applied when a non-static data
member or non-static member function is a protected member of its naming class (11.2)115 As described
earlier, access to a protected member is granted because the reference occurs in a friend or member of some
class C. If the access is to form a pointer to member (5.3.1), the nested-name-specifier shall denote C or a
class derived from C. All other accesses involve a (possibly implicit) object expression (5.2.5). In this case,
the class of the object expression shall be C or a class derived from C. [ Example:
class B {
protected:
int i;
static int j;
};
class D1 : public B {
};
class D2 : public B {
115) This additional check does not apply to other members, e.g., static data members or enumerator member constants.
§ 11.4 253

 c ISO/IEC N3242=11-0012
friend void fr(B*,D1*,D2*);
void mem(B*,D1*);
};
void fr(B* pb, D1* p1, D2* p2) {
pb->i = 1; // ill-formed
p1->i = 2; // ill-formed
p2->i = 3; // OK (access through a D2)
p2->B::i = 4; // OK (access through a D2, even though
// naming class is B)
int B::* pmi_B = &B::i; // ill-formed
int B::* pmi_B2 = &D2::i; // OK (type of &D2::i is int B::*)
B::j = 5; // OK (because refers to static member)
D2::j = 6; // OK (because refers to static member)
}
void D2::mem(B* pb, D1* p1) {
pb->i = 1; // ill-formed
p1->i = 2; // ill-formed
i = 3; // OK (access through this)
B::i = 4; // OK (access through this, qualification ignored)
int B::* pmi_B = &B::i; // ill-formed
int B::* pmi_B2 = &D2::i; // OK
j = 5; // OK (because j refers to static member)
B::j = 6; // OK (because B::j refers to static member)
}
void g(B* pb, D1* p1, D2* p2) {
pb->i = 1; // ill-formed
p1->i = 2; // ill-formed
p2->i = 3; // ill-formed
}
— end example ]
11.5 Access to virtual functions [class.access.virt]
1 The access rules (Clause 11) for a virtual function are determined by its declaration and are not affected by
the rules for a function that later overrides it. [ Example:
class B {
public:
virtual int f();
};
class D : public B {
private:
int f();
};
void f() {
D d;
B* pb = &d;
D* pd = &d;
pb->f(); // OK: B::f() is public,
§ 11.5 254

 c ISO/IEC N3242=11-0012
// D::f() is invoked
pd->f(); // error: D::f() is private
}
— end example ]
2 Access is checked at the call point using the type of the expression used to denote the object for which the
member function is called (B* in the example above). The access of the member function in the class in
which it was defined (D in the example above) is in general not known.
11.6 Multiple access [class.paths]
1 If a name can be reached by several paths through a multiple inheritance graph, the access is that of the
path that gives most access. [ Example:
class W { public: void f(); };
class A : private virtual W { };
class B : public virtual W { };
class C : public A, public B {
void f() { W::f(); } // OK
};
2 Since W::f() is available to C::f() along the public path through B, access is allowed. — end example ]
11.7 Nested classes [class.access.nest]
1 A nested class is a member and as such has the same access rights as any other member. The members of
an enclosing class have no special access to members of a nested class; the usual access rules (Clause 11)
shall be obeyed. [ Example:
class E {
int x;
class B { };
class I {
B b; // OK: E::I can access E::B
int y;
void f(E* p, int i) {
p->x = i; // OK: E::I can access E::x
}
};
int g(I* p) {
return p->y; // error: I::y is private
}
};
— end example ]
§ 11.7 255

 c ISO/IEC N3242=11-0012
12 Special member functions [special]
1 The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor
and move assignment operator (12.8), and destructor (12.4) are special member functions. [ Note: The
implementation will implicitly declare these member functions for some class types when the program does
not explicitly declare them. The implementation will implicitly define them if they are odr-used (3.2).
See 12.1, 12.4 and 12.8. — end note ] Programs shall not define implicitly-declared special member functions.
2 Programs may explicitly refer to implicitly-declared special member functions. [ Example: a program may
explicitly call, take the address of or form a pointer to member to an implicitly-declared special member
function.
struct A { }; // implicitly declared A::operator=
struct B : A {
B& operator=(const B &);
};
B& B::operator=(const B& s) {
this->A::operator=(s); // well formed
return *this;
} —
end example ]
3 [ Note: The special member functions affect the way objects of class type are created, copied, moved, and
destroyed, and how values can be converted to values of other types. Often such special member functions
are called implicitly. — end note ]
4 Special member functions obey the usual access rules (Clause 11). [ Example: declaring a constructor
protected ensures that only derived classes and friends can create objects using it. — end example ]
12.1 Constructors [class.ctor]
1 Constructors do not have names. A special declarator syntax is used to declare or define the constructor.
The syntax uses:
— an optional decl-specifier-seq in which each decl-specifier is either a function-specifier or constexpr,
— the constructor’s class name, and
— a parameter list
in that order. In such a declaration, optional parentheses around the constructor class name are ignored.
[ Example:
struct S {
S(); // declares the constructor
};
S::S() { } // defines the constructor
— end example ]
§ 12.1 256

 c ISO/IEC N3242=11-0012
2 A constructor is used to initialize objects of its class type. Because constructors do not have names, they are
never found during name lookup; however an explicit type conversion using the functional notation (5.2.3)
will cause a constructor to be called to initialize an object. [ Note: For initialization of objects of class type
see 12.6. — end note ]
3 A typedef-name shall not be used as the class-name in the declarator-id for a constructor declaration.
4 A constructor shall not be virtual (10.3) or static (9.4). A constructor can be invoked for a const,
volatile or const volatile object. A constructor shall not be declared const, volatile, or const
volatile (9.3.2). const and volatile semantics (7.1.6.1) are not applied on an object under construction.
They come into effect when the constructor for the most derived object (1.8) ends. A constructor shall not
be declared with a ref-qualifier.
5 A default constructor for a class X is a constructor of class X that can be called without an argument. If
there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared
as defaulted (8.4). An implicitly-declared default constructor is an inline public member of its class. A
defaulted default constructor for class X is defined as deleted if:
— X is a union-like class that has a variant member with a non-trivial default constructor,
— any non-static data member with no brace-or-equal-initializer is of reference type,
— any non-variant non-static data member of const-qualified type (or array thereof) with no brace-orequal-initializer does not have a user-provided default constructor,
— X is a union and all of its variant members are of const-qualified type (or array thereof),
— X is a non-union class and all members of any anonymous union member are of const-qualified type
(or array thereof), or
— any direct or virtual base class, or non-static data member with no brace-or-equal-initializer, has class
type M (or array thereof) and either M has no default constructor or overload resolution (13.3) as applied
to M’s default constructor results in an ambiguity or in a function that is deleted or inaccessible from
the defaulted default constructor.
A default constructor is trivial if it is neither user-provided nor deleted and if:
— its class has no virtual functions (10.3) and no virtual base classes (10.1), and
— no non-static data member of its class has a brace-or-equal-initializer, and
— all the direct base classes of its class have trivial default constructors, and
— for all the non-static data members of its class that are of class type (or array thereof), each such class
has a trivial default constructor.
Otherwise, the default constructor is non-trivial.
6 A default constructor that is defaulted and not defined as deleted is implicitly defined when it is odrused (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its first declaration.
The implicitly-defined default constructor performs the set of initializations of the class that would be
performed by a user-written default constructor for that class with no ctor-initializer (12.6.2) and an empty
compound-statement. If that user-written default constructor would be ill-formed, the program is ill-formed.
If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),
the implicitly-defined default constructor is constexpr. Before the defaulted default constructor for a
class is implicitly defined, all the non-user-provided default constructors for its base classes and its nonstatic data members shall have been implicitly defined. [ Note: An implicitly-declared default constructor
has an exception-specification (15.4). An explicitly-defaulted definition might have an implicit exceptionspecification, see 8.4. — end note ]
§ 12.1 257

 c ISO/IEC N3242=11-0012
7 Default constructors are called implicitly to create class objects of static, thread, or automatic storage
duration (3.7.1, 3.7.2, 3.7.3) defined without an initializer (8.5), are called to create class objects of dynamic
storage duration (3.7.4) created by a new-expression in which the new-initializer is omitted (5.3.4), or
are called when the explicit type conversion syntax (5.2.3) is used. A program is ill-formed if the default
constructor for an object is implicitly used and the constructor is not accessible (Clause 11).
8 [ Note: 12.6.2 describes the order in which constructors for base classes and non-static data members are
called and describes how arguments can be specified for the calls to these constructors. — end note ]
9 A copy constructor (12.8) is used to copy objects of class type. A move constructor (12.8) is used to move
the contents of objects of class type.
10 No return type (not even void) shall be specified for a constructor. A return statement in the body of a
constructor shall not specify a return value. The address of a constructor shall not be taken.
11 A functional notation type conversion (5.2.3) can be used to create new objects of its type. [ Note: The
syntax looks like an explicit call of the constructor. — end note ] [ Example:
complex zz = complex(1,2.3);
cprint( complex(7.8,1.2) );
— end example ]
12 An object created in this way is unnamed. [ Note: 12.2 describes the lifetime of temporary objects. — end
note ] [ Note: Explicit constructor calls do not yield lvalues, see 3.10. — end note ]
13 [ Note: some language constructs have special semantics when used during construction; see 12.6.2 and 12.7.
— end note ]
14 During the construction of a const object, if the value of the object or any of its subobjects is accessed
through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value
of the object or subobject thus obtained is unspecified. [ Example:
struct C;
void no_opt(C*);
struct C {
int c;
C() : c(0) { no_opt(this); }
};
const C cobj;
void no_opt(C* cptr) {
int i = cobj.c * 100; // value of cobj.c is unspecified
cptr->c = 1;
cout << cobj.c * 100 // value of cobj.c is unspecified
<< ’\n’;
}
— end example ]
12.2 Temporary objects [class.temporary]
1 Temporaries of class type are created in various contexts: binding a reference to a prvalue (8.5.3), returning
a prvalue (6.6.3), a conversion that creates a prvalue (4.1, 5.2.9, 5.2.11, 5.4), throwing an exception (15.1),
entering a handler (15.3), and in some initializations (8.5). [ Note: The lifetime of exception objects is
§ 12.2 258

 c ISO/IEC N3242=11-0012
described in 15.1. — end note ] Even when the creation of the temporary object is avoided (12.8), all the
semantic restrictions shall be respected as if the temporary object had been created. [ Note: Even if the
copy/move constructor is not called, all the semantic restrictions, such as accessibility (Clause 11), shall be
satisfied. — end note ]
2 [ Example: Consider the following code:
class X {
public:
X(int);
X(const X&);
~X();
};
class Y {
public:
Y(int);
Y(Y&&);
~Y();
};
X f(X);
Y g(Y);
void h() {
X a(1);
X b = f(X(2));
Y c = g(Y(3));
a = f(a);
}
An implementation might use a temporary in which to construct X(2) before passing it to f() using X’s copy
constructor; alternatively, X(2) might be constructed in the space used to hold the argument. Likewise, an
implementation might use a temporary in which to construct Y(3) before passing it to g() using Y’s move
constructor; alternatively, Y(3) might be constructed in the space used to hold the argument. Also, a
temporary might be used to hold the result of f(X(2)) before copying it to b using X’s copy constructor;
alternatively, f()’s result might be constructed in b. Likewise, a temporary might be used to hold the result
of g(Y(3)) before moving it to c using Y’s move constructor; alternatively, g()’s result might be constructed
in c. On the other hand, the expression a=f(a) requires a temporary for the result of f(a), which is then
assigned to a. — end example ]
3 When an implementation introduces a temporary object of a class that has a non-trivial constructor (12.1,
12.8), it shall ensure that a constructor is called for the temporary object. Similarly, the destructor shall be
called for a temporary with a non-trivial destructor (12.4). Temporary objects are destroyed as the last step
in evaluating the full-expression (1.9) that (lexically) contains the point where they were created. This is true
even if that evaluation ends in throwing an exception. The value computations and side effects of destroying
a temporary object are associated only with the full-expression, not with any specific subexpression.
4 There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when a default constructor is called to initialize an element of an array. If
the constructor has one or more default arguments, the destruction of every temporary created in a default
argument is sequenced before the construction of the next array element, if any.
5 The second context is when a reference is bound to a temporary. The temporary to which the reference is
bound or the temporary that is the complete object of a subobject to which the reference is bound persists
§ 12.2 259

 c ISO/IEC N3242=11-0012
for the lifetime of the reference except:
— A temporary bound to a reference member in a constructor’s ctor-initializer (12.6.2) persists until the
constructor exits.
— A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of
the full-expression containing the call.
— The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not
extended; the temporary is destroyed at the end of the full-expression in the return statement.
— A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the
full-expression containing the new-initializer. [ Example:
struct S { int mi; const std::pair<int,int>& mp; };
S a { 1, {2,3} };
S* p = new S{ 1, {2,3} }; // Creates dangling reference
— end example ] [ Note: This may introduce a dangling reference, and implementations are encouraged
to issue a warning in such a case. — end note ]
The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced
before the destruction of every temporary which is constructed earlier in the same full-expression. If the
lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries
are destroyed at that point in the reverse order of the completion of their construction. In addition, the
destruction of temporaries bound to references shall take into account the ordering of destruction of objects
with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if obj1 is an object with the
same storage duration as the temporary and created before the temporary is created the temporary shall be
destroyed before obj1 is destroyed; if obj2 is an object with the same storage duration as the temporary and
created after the temporary is created the temporary shall be destroyed after obj2 is destroyed. [ Example:
struct S {
S();
S(int);
friend S operator+(const S&, const S&);
~S();
};
S obj1;
const S& cr = S(16)+S(23);
S obj2;
the expression S(16) + S(23) creates three temporaries: a first temporary T1 to hold the result of the
expression S(16), a second temporary T2 to hold the result of the expression S(23), and a third temporary
T3 to hold the result of the addition of these two expressions. The temporary T3 is then bound to the reference
cr. It is unspecified whether T1 or T2 is created first. On an implementation where T1 is created before
T2, it is guaranteed that T2 is destroyed before T1. The temporaries T1 and T2 are bound to the reference
parameters of operator+; these temporaries are destroyed at the end of the full-expression containing the
call to operator+. The temporary T3 bound to the reference cr is destroyed at the end of cr’s lifetime,
that is, at the end of the program. In addition, the order in which T3 is destroyed takes into account the
destruction order of other objects with static storage duration. That is, because obj1 is constructed before
T3, and T3 is constructed before obj2, it is guaranteed that obj2 is destroyed before T3, and that T3 is
destroyed before obj1. — end example ]
§ 12.2 260

 c ISO/IEC N3242=11-0012
12.3 Conversions [class.conv]
1 Type conversions of class objects can be specified by constructors and by conversion functions. These
conversions are called user-defined conversions and are used for implicit type conversions (Clause 4), for
initialization (8.5), and for explicit type conversions (5.4, 5.2.9).
2 User-defined conversions are applied only where they are unambiguous (10.2, 12.3.2). Conversions obey the
access control rules (Clause 11). Access control is applied after ambiguity resolution (3.4).
3 [ Note: See 13.3 for a discussion of the use of conversions in function calls as well as examples below. — end
note ]
4 At most one user-defined conversion (constructor or conversion function) is implicitly applied to a single
value.
[ Example:
struct X {
operator int();
};
struct Y {
operator X();
};
Y a;
int b = a; // error
// a.operator X().operator int() not tried
int c = X(a); // OK: a.operator X().operator int()
— end example ]
5 User-defined conversions are used implicitly only if they are unambiguous. A conversion function in a
derived class does not hide a conversion function in a base class unless the two functions convert to the same
type. Function overload resolution (13.3.3) selects the best conversion function to perform the conversion.
[ Example:
struct X {
operator int();
};
struct Y : X {
operator char();
};
void f(Y& a) {
if (a) { // ill-formed:
// X::operator int() or Y::operator char()
}
} —
end example ]
12.3.1 Conversion by constructor [class.conv.ctor]
1 A constructor declared without the function-specifier explicit specifies a conversion from the types of its
parameters to the type of its class. Such a constructor is called a converting constructor. [ Example:
§ 12.3.1 261

 c ISO/IEC N3242=11-0012
struct X {
X(int);
X(const char*, int =0);
};
void f(X arg) {
X a = 1; // a = X(1)
X b = "Jessie"; // b = X("Jessie",0)
a = 2; // a = X(2)
f(3); // f(X(3))
} —
end example ]
2 An explicit constructor constructs objects just like non-explicit constructors, but does so only where the
direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor
may be an explicit constructor; such a constructor will be used to perform default-initialization or valueinitialization (8.5). [ Example:
struct Z {
explicit Z();
explicit Z(int);
};
Z a; // OK: default-initialization performed
Z a1 = 1; // error: no implicit conversion
Z a3 = Z(1); // OK: direct initialization syntax used
Z a2(1); // OK: direct initialization syntax used
Z* p = new Z(1); // OK: direct initialization syntax used
Z a4 = (Z)1; // OK: explicit cast used
Z a5 = static_cast<Z>(1); // OK: explicit cast used
— end example ]
3 A non-explicit copy/move constructor (12.8) is a converting constructor. An implicitly-declared copy/move
constructor is not an explicit constructor; it may be called for implicit type conversions.
12.3.2 Conversion functions [class.conv.fct]
1 A member function of a class X having no parameters with a name of the form
conversion-function-id:
operator conversion-type-id
conversion-type-id:
type-specifier-seq conversion-declaratoropt
conversion-declarator:
ptr-operator conversion-declaratoropt
specifies a conversion from X to the type specified by the conversion-type-id. Such functions are called
conversion functions. No return type can be specified. If a conversion function is a member function, the
type of the conversion function (8.3.5) is “function taking no parameter returning conversion-type-id”. A
conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified)
§ 12.3.2 262

 c ISO/IEC N3242=11-0012
same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to
it), or to (possibly cv-qualified) void.116
[ Example:
struct X {
operator int();
};
void f(X a) {
int i = int(a);
i = (int)a;
i = a;
}
In all three cases the value assigned will be converted by X::operator int(). — end example ]
2 A conversion function may be explicit (7.1.2), in which case it is only considered as a user-defined conversion
for direct-initialization (8.5). Otherwise, user-defined conversions are not restricted to use in assignments
and initializations. [ Example:
class Y { };
struct Z {
explicit operator Y() const;
};
void h(Z z) {
Y y1(z); // OK: direct-initialization
Y y2 = z; // ill-formed: copy-initialization
Y y3 = (Y)z; // OK: cast notation
}
void g(X a, X b) {
int i = (a) ? 1+a : 0;
int j = (a&&b) ? a+b : i;
if (a) {
}
} —
end example ]
3 The conversion-type-id shall not represent a function type nor an array type. The conversion-type-id in
a conversion-function-id is the longest possible sequence of conversion-declarators. [ Note: This prevents
ambiguities between the declarator operator * and its expression counterparts. [ Example:
&ac.operator int*i; // syntax error:
// parsed as: &(ac.operator int *)i
// not as: &(ac.operator int)*i
The * is the pointer declarator and not the multiplication operator. — end example ] — end note ]
4 Conversion functions are inherited.
116) These conversions are considered as standard conversions for the purposes of overload resolution (13.3.3.1, 13.3.3.1.4) and
therefore initialization (8.5) and explicit casts (5.2.9). A conversion to void does not invoke any conversion function (5.2.9).
Even though never directly called to perform a conversion, such conversion functions can be declared and can potentially be
reached through a call to a virtual conversion function in a base class.
§ 12.3.2 263

 c ISO/IEC N3242=11-0012
5 Conversion functions can be virtual.
6 Conversion functions cannot be declared static.
12.4 Destructors [class.dtor]
1 A special declarator syntax using an optional function-specifier (7.1.2) followed by ˜ followed by the destructor’s class name followed by an empty parameter list is used to declare the destructor in a class definition.
In such a declaration, the ˜ followed by the destructor’s class name can be enclosed in optional parentheses;
such parentheses are ignored. A typedef-name shall not be used as the class-name following the ∼ in the
declarator for a destructor declaration.
2 A destructor is used to destroy objects of its class type. A destructor takes no parameters, and no return type
can be specified for it (not even void). The address of a destructor shall not be taken. A destructor shall
not be static. A destructor can be invoked for a const, volatile or const volatile object. A destructor
shall not be declared const, volatile or const volatile (9.3.2). const and volatile semantics (7.1.6.1)
are not applied on an object under destruction. They stop being in effect when the destructor for the most
derived object (1.8) starts. A destructor shall not be declared with a ref-qualifier.
3 A declaration of a destructor that does not have an exception-specification is implicitly considered to have
the same exception-specification as an implicit declaration (15.4).
4 If a class has no user-declared destructor, a destructor is implicitly declared as defaulted (8.4). An implicitlydeclared destructor is an inline public member of its class.
A defaulted destructor for a class X is defined as deleted if:
— X is a union-like class that has a variant member with a non-trivial destructor,
— any of the non-static data members has class type M (or array thereof) and M has a deleted destructor
or a destructor that is inaccessible from the defaulted destructor, or
— any direct or virtual base class has a deleted destructor or a destructor that is inaccessible from the
defaulted destructor.
A destructor is trivial if it is neither user-provided nor deleted and if:
— the destructor is not virtual,
— all of the direct base classes of its class have trivial destructors, and
— for all of the non-static data members of its class that are of class type (or array thereof), each such
class has a trivial destructor.
Otherwise, the destructor is non-trivial.
5 A destructor that is defaulted and not defined as deleted is implicitly defined when it is odr-used (3.2) to
destroy an object of its class type (3.7) or when it is explicitly defaulted after its first declaration.
6 Before the defaulted destructor for a class is implicitly defined, all the non-user-provided destructors for its
base classes and its non-static data members shall have been implicitly defined.
7 After executing the body of the destructor and destroying any automatic objects allocated within the body,
a destructor for class X calls the destructors for X’s direct non-variant members, the destructors for X’s direct
base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for
X’s virtual base classes. All destructors are called as if they were referenced with a qualified name, that is,
ignoring any possible virtual overriding destructors in more derived classes. Bases and members are destroyed
in the reverse order of the completion of their constructor (see 12.6.2). A return statement (6.6.3) in a
destructor might not directly return to the caller; before transferring control to the caller, the destructors
§ 12.4 264

 c ISO/IEC N3242=11-0012
for the members and bases are called. Destructors for elements of an array are called in reverse order of
their construction (see 12.6).
8 A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any
derived class are created in the program, the destructor shall be defined. If a class has a base class with a
virtual destructor, its destructor (whether user- or implicitly-declared) is virtual.
9 [ Note: some language constructs have special semantics when used during destruction; see 12.7. — end
note ]
10 Destructors are invoked implicitly
— for constructed objects with static storage duration (3.7.1) at program termination (3.6.3),
— for constructed objects with thread storage duration (3.7.2) at thread exit,
— for constructed objects with automatic storage duration (3.7.3) when the block in which an object is
created exits (6.7),
— for constructed temporary objects when the lifetime of a temporary object ends (12.2),
— for constructed objects allocated by a new-expression (5.3.4), through use of a delete-expression (5.3.5),
— in several situations due to the handling of exceptions (15.3).
A program is ill-formed if an object of class type or array thereof is declared and the destructor for the class
is not accessible at the point of the declaration. Destructors can also be invoked explicitly.
11 At the point of definition of a virtual destructor (including an implicit definition (12.8)), the non-array
deallocation function is looked up in the scope of the destructor’s class (10.2), and, if no declaration is
found, the function is looked up in the global scope. If the result of this lookup is ambiguous or inaccessible,
or if the lookup selects a placement deallocation function or a function with a deleted definition (8.4), the
program is ill-formed. [ Note: This assures that a deallocation function corresponding to the dynamic type
of an object is available for the delete-expression (12.5). — end note ]
12 In an explicit destructor call, the destructor name appears as a ˜ followed by a type-name or decltypespecifier that denotes the destructor’s class type. The invocation of a destructor is subject to the usual
rules for member functions (9.3), that is, if the object is not of the destructor’s class type and not of a class
derived from the destructor’s class type, the program has undefined behavior (except that invoking delete
on a null pointer has no effect). [ Example:
struct B {
virtual ~B() { }
};
struct D : B {
~D() { }
};
D D_object;
typedef B B_alias;
B* B_ptr = &D_object;
void f() {
D_object.B::~B(); // calls B’s destructor
B_ptr->~B(); // calls D’s destructor
B_ptr->~B_alias(); // calls D’s destructor
B_ptr->B_alias::~B(); // calls B’s destructor
B_ptr->B_alias::~B_alias(); // calls B’s destructor
}
§ 12.4 265

 c ISO/IEC N3242=11-0012
— end example ] [ Note: An explicit destructor call must always be written using a member access operator (5.2.5) or a qualified-id (5.1); in particular, the unary-expression ˜X() in a member function is not an
explicit destructor call (5.3.1). — end note ]
13 [ Note: explicit calls of destructors are rarely needed. One use of such calls is for objects placed at specific
addresses using a new-expression with the placement option. Such use of explicit placement and destruction
of objects can be necessary to cope with dedicated hardware resources and for writing memory management
facilities. For example,
void* operator new(std::size_t, void* p) { return p; }
struct X {
X(int);
~X();
};
void f(X* p);
void g() { // rare, specialized use:
char* buf = new char[sizeof(X)];
X* p = new(buf) X(222); // use buf[] and initialize
f(p);
p->X::~X(); // cleanup
} —
end note ]
14 Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the
destructor is invoked for an object whose lifetime has ended (3.8). [ Example: if the destructor for an
automatic object is explicitly invoked, and the block is subsequently left in a manner that would ordinarily
invoke implicit destruction of the object, the behavior is undefined. — end example ]
15 [ Note: the notation for explicit call of a destructor can be used for any scalar type name (5.2.4). Allowing
this makes it possible to write code without having to know if a destructor exists for a given type. For
example,
typedef int I;
I* p;
p->I::~I();
— end note ]
12.5 Free store [class.free]
1 Any allocation function for a class T is a static member (even if not explicitly declared static).
2 [ Example:
class Arena;
struct B {
void* operator new(std::size_t, Arena*);
};
struct D1 : B {
};
Arena* ap;
void foo(int i) {
new (ap) D1; // calls B::operator new(std::size_t, Arena*)
§ 12.5 266

 c ISO/IEC N3242=11-0012
new D1[i]; // calls ::operator new[](std::size_t)
new D1; // ill-formed: ::operator new(std::size_t) hidden
}
— end example ]
3 When an object is deleted with a delete-expression (5.3.5), a deallocation function (operator delete() for
non-array objects or operator delete[]() for arrays) is (implicitly) called to reclaim the storage occupied
by the object (3.7.4.2).
4 If a delete-expression begins with a unary :: operator, the deallocation function’s name is looked up in
global scope. Otherwise, if the delete-expression is used to deallocate a class object whose static type has
a virtual destructor, the deallocation function is the one selected at the point of definition of the dynamic
type’s virtual destructor (12.4).117 Otherwise, if the delete-expression is used to deallocate an object of
class T or array thereof, the static and dynamic types of the object shall be identical and the deallocation
function’s name is looked up in the scope of T. If this lookup fails to find the name, the name is looked up in
the global scope. If the result of the lookup is ambiguous or inaccessible, or if the lookup selects a placement
deallocation function, the program is ill-formed.
5 When a delete-expression is executed, the selected deallocation function shall be called with the address of
the block of storage to be reclaimed as its first argument and (if the two-parameter style is used) the size of
the block as its second argument.118
6 Any deallocation function for a class X is a static member (even if not explicitly declared static). [ Example:
class X {
void operator delete(void*);
void operator delete[](void*, std::size_t);
};
class Y {
void operator delete(void*, std::size_t);
void operator delete[](void*);
};
— end example ]
7 Since member allocation and deallocation functions are static they cannot be virtual. [ Note: however,
when the cast-expression of a delete-expression refers to an object of class type, because the deallocation
function actually called is looked up in the scope of the class that is the dynamic type of the object, if the
destructor is virtual, the effect is the same. For example,
struct B {
virtual ~B();
void operator delete(void*, std::size_t);
};
struct D : B {
void operator delete(void*);
};
void f() {
117) A similar provision is not needed for the array version of operator delete because 5.3.5 requires that in this situation,
the static type of the object to be deleted be the same as its dynamic type.
118) If the static type of the object to be deleted is different from the dynamic type and the destructor is not virtual the size
might be incorrect, but that case is already undefined; see 5.3.5.
§ 12.5 267

 c ISO/IEC N3242=11-0012
B* bp = new D;
delete bp; // uses D::operator delete(void*)
}
Here, storage for the non-array object of class D is deallocated by D::operator delete(), due to the
virtual destructor. — end note ] [ Note: Virtual destructors have no effect on the deallocation function
actually called when the cast-expression of a delete-expression refers to an array of objects of class type. For
example,
struct B {
virtual ~B();
void operator delete[](void*, std::size_t);
};
struct D : B {
void operator delete[](void*, std::size_t);
};
void f(int i) {
D* dp = new D[i];
delete [] dp; // uses D::operator delete[](void*, std::size_t)
B* bp = new D[i];
delete[] bp; // undefined behavior
} —
end note ]
8 Access to the deallocation function is checked statically. Hence, even though a different one might actually
be executed, the statically visible deallocation function is required to be accessible. [ Example: for the call
on line //1 above, if B::operator delete() had been private, the delete expression would have been
ill-formed. — end example ]
9 [ Note: If a deallocation function has no explicit exception-specification, it is treated as if it were specified
with noexcept(true) (15.4). — end note ]
12.6 Initialization [class.init]
1 When no initializer is specified for an object of (possibly cv-qualified) class type (or array thereof), or the
initializer has the form (), the object is initialized as specified in 8.5.
2 An object of class type (or array thereof) can be explicitly initialized; see 12.6.1 and 12.6.2.
3 When an array of class objects is initialized (either explicitly or implicitly) and the elements are initialized
by constructor, the constructor shall be called for each element of the array, following the subscript order;
see 8.3.4. [ Note: Destructors for the array elements are called in reverse order of their construction. — end
note ]
12.6.1 Explicit initialization [class.expl.init]
1 An object of class type can be initialized with a parenthesized expression-list, where the expression-list
is construed as an argument list for a constructor that is called to initialize the object. Alternatively, a
single assignment-expression can be specified as an initializer using the = form of initialization. Either
direct-initialization semantics or copy-initialization semantics apply; see 8.5. [ Example:
struct complex {
complex();
complex(double);
§ 12.6.1 268

 c ISO/IEC N3242=11-0012
complex(double,double);
};
complex sqrt(complex,complex);
complex a(1); // initialize by a call of
// complex(double)
complex b = a; // initialize by a copy of a
complex c = complex(1,2); // construct complex(1,2)
// using complex(double,double)
// copy/move it into c
complex d = sqrt(b,c); // call sqrt(complex,complex)
// and copy/move the result into d
complex e; // initialize by a call of
// complex()
complex f = 3; // construct complex(3) using
// complex(double)
// copy/move it into f
complex g = { 1, 2 }; // construct complex(1, 2)
// using complex(double, double)
// and copy/move it into g
— end example ] [ Note: overloading of the assignment operator (13.5.3) has no effect on initialization. — end
note ]
2 An object of class type can also be initialized by a braced-init-list. List-initialization semantics apply; see 8.5
and 8.5.4. [ Example:
complex v[6] = { 1, complex(1,2), complex(), 2 };
Here, complex::complex(double) is called for the initialization of v[0] and v[3], complex::complex(double,
double) is called for the initialization of v[1], complex::complex() is called for the initialization v[2],
v[4], and v[5]. For another example,
struct X {
int i;
float f;
complex c;
} x = { 99, 88.8, 77.7 };
Here, x.i is initialized with 99, x.f is initialized with 88.8, and complex::complex(double) is called for the
initialization of x.c. — end example ] [ Note: Braces can be elided in the initializer-list for any aggregate,
even if the aggregate has members of a class type with user-defined type conversions; see 8.5.1. — end note ]
3 [ Note: If T is a class type with no default constructor, any declaration of an object of type T (or array
thereof) is ill-formed if no initializer is explicitly specified (see 12.6 and 8.5). — end note ]
4 [ Note: the order in which objects with static or thread storage duration are initialized is described in 3.6.2
and 6.7. — end note ]
12.6.2 Initializing bases and members [class.base.init]
1 In the definition of a constructor for a class, initializers for direct and virtual base subobjects and non-static
data members can be specified by a ctor-initializer, which has the form
ctor-initializer:
: mem-initializer-list
§ 12.6.2 269

 c ISO/IEC N3242=11-0012
mem-initializer-list:
mem-initializer ...
opt
mem-initializer , mem-initializer-list ...opt
mem-initializer:
mem-initializer-id ( expression-listopt)
mem-initializer-id braced-init-list
mem-initializer-id:
class-or-decltype
identifier
2 In a mem-initializer-id an initial unqualified identifier is looked up in the scope of the constructor’s class
and, if not found in that scope, it is looked up in the scope containing the constructor’s definition. [ Note:
If the constructor’s class contains a member with the same name as a direct or virtual base class of the
class, a mem-initializer-id naming the member or base class and composed of a single identifier refers to
the class member. A mem-initializer-id for the hidden base class may be specified using a qualified name.
— end note ] Unless the mem-initializer-id names the constructor’s class, a non-static data member of the
constructor’s class, or a direct or virtual base of that class, the mem-initializer is ill-formed.
3 A mem-initializer-list can initialize a base class using any class-or-decltype that denotes that base class type.
[ Example:
struct A { A(); };
typedef A global_A;
struct B { };
struct C: public A, public B { C(); };
C::C(): global_A() { } // mem-initializer for base A
— end example ]
4 If a mem-initializer-id is ambiguous because it designates both a direct non-virtual base class and an inherited
virtual base class, the mem-initializer is ill-formed. [ Example:
struct A { A(); };
struct B: public virtual A { };
struct C: public A, public B { C(); };
C::C(): A() { } // ill-formed: which A?
— end example ]
5 A ctor-initializer may initialize the member of an anonymous union that is a member of the constructor’s
class. If a ctor-initializer specifies more than one mem-initializer for the same member or for the same base
class, the ctor-initializer is ill-formed.
6 A mem-initializer-list can delegate to another constructor of the constructor’s class using any class-ordecltype that denotes the constructor’s class itself. If a mem-initializer-id designates the constructor’s class,
it shall be the only mem-initializer; the constructor is a delegating constructor, and the constructor selected
by the mem-initializer is the target constructor. The principal constructor is the first constructor invoked
in the construction of an object (that is, not a target constructor for that object’s construction). The
target constructor is selected by overload resolution. Once the target constructor returns, the body of the
delegating constructor is executed. If a constructor delegates to itself directly or indirectly, the program is
ill-formed; no diagnostic is required. [ Example:
struct C {
C( int ) { } // #1: non-delegating constructor
C(): C(42) { } // #2: delegates to #1
C( char c ) : C(42.0) { } // #3: ill-formed due to recursion with #4
C( double d ) : C(’a’) { } // #4: ill-formed due to recursion with #3
§ 12.6.2 270

 c ISO/IEC N3242=11-0012
};
— end example ]
7 The expression-list or braced-init-list in a mem-initializer is used to initialize the designated subobject (or,
in the case of a delegating constructor, the complete class object) according to the initialization rules of 8.5
for direct-initialization.
[ Example:
struct B1 { B1(int); /∗ ... ∗/ };
struct B2 { B2(int); /∗ ... ∗/ };
struct D : B1, B2 {
D(int);
B1 b;
const int c;
};
D::D(int a) : B2(a+1), B1(a+2), c(a+3), b(a+4)
{ /∗ ... ∗/ }
D d(10);
— end example ] The initialization performed by each mem-initializer constitutes a full-expression. Any
expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization.
A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a
constructor of any class that is not the most derived class.
8 In a non-delegating constructor, if a given non-static data member or base class is not designated by a
mem-initializer-id (including the case where there is no mem-initializer-list because the constructor has no
ctor-initializer) and the entity is not a virtual base class of an abstract class (10.4), then
— if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized
as specified in 8.5;
— otherwise, if the entity is a variant member (9.5), no initialization is performed;
— otherwise, the entity is default-initialized (8.5).
[ Note: An abstract class (10.4) is never a most derived class, thus its constructors never initialize virtual
base classes, therefore the corresponding mem-initializers may be omitted. — end note ] An attempt to
initialize more than one non-static data member of a union renders the program ill-formed. After the call
to a constructor for class X has completed, if a member of X is neither initialized nor given a value during
execution of the compound-statement of the body of the constructor, the member has indeterminate value.
[ Example:
struct A {
A();
};
struct B {
B(int);
};
struct C {
C() { } // initializes members as follows:
A a; // OK: calls A::A()
const B b; // error: B has no default constructor
§ 12.6.2 271

 c ISO/IEC N3242=11-0012
int i; // OK: i has indeterminate value
int j = 5; // OK: j has the value 5
};
— end example ]
9 If a given non-static data member has both a brace-or-equal-initializer and a mem-initializer, the initialization specified by the mem-initializer is performed, and the non-static data member’s brace-or-equal-initializer
is ignored. [ Example: Given
struct A {
int i = /∗ some integer expression with side effects ∗/ ;
A(int arg) : i(arg) { }
// ...
};
the A(int) constructor will simply initialize i to the value of arg, and the side effects in i’s brace-or-equalinitializer will not take place. — end example ]
10 In a non-delegating constructor, initialization proceeds in the following order:
— First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in
the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,
where “left-to-right” is the order of appearance of the base classes in the derived class base-specifier-list.
— Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list
(regardless of the order of the mem-initializers).
— Then, non-static data members are initialized in the order they were declared in the class definition
(again regardless of the order of the mem-initializers).
— Finally, the compound-statement of the constructor body is executed.
[ Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the
reverse order of initialization. — end note ]
11 [ Example:
struct V {
V();
V(int);
};
struct A : virtual V {
A();
A(int);
};
struct B : virtual V {
B();
B(int);
};
struct C : A, B, virtual V {
C();
C(int);
};
§ 12.6.2 272

 c ISO/IEC N3242=11-0012
A::A(int i) : V(i) { /∗ ... ∗/ }
B::B(int i) { /∗ ... ∗/ }
C::C(int i) { /∗ ... ∗/ }
V v(1); // use V(int)
A a(2); // use V(int)
B b(3); // use V()
C c(4); // use V()
— end example ]
12 Names in the expression-list or braced-init-list of a mem-initializer are evaluated in the scope of the constructor for which the mem-initializer is specified. [ Example:
class X {
int a;
int b;
int i;
int j;
public:
const int& r;
X(int i): r(a), b(i), i(i), j(this->i) { }
};
initializes X::r to refer to X::a, initializes X::b with the value of the constructor parameter i, initializes X::i
with the value of the constructor parameter i, and initializes X::j with the value of X::i; this takes place
each time an object of class X is created. — end example ] [ Note: Because the mem-initializer are evaluated
in the scope of the constructor, the this pointer can be used in the expression-list of a mem-initializer to
refer to the object being initialized. — end note ]
13 Member functions (including virtual member functions, 10.3) can be called for an object under construction.
Similarly, an object under construction can be the operand of the typeid operator (5.2.8) or of a dynamic_-
cast (5.2.7). However, if these operations are performed in a ctor-initializer (or in a function called directly
or indirectly from a ctor-initializer) before all the mem-initializers for base classes have completed, the result
of the operation is undefined. [ Example:
class A {
public:
A(int);
};
class B : public A {
int j;
public:
int f();
B() : A(f()), // undefined: calls member function
// but base A not yet initialized
j(f()) { } // well-defined: bases are all initialized
};
class C {
public:
C(int);
};
class D : public B, C {
§ 12.6.2 273

 c ISO/IEC N3242=11-0012
int i;
public:
D() : C(f()), // undefined: calls member function
// but base C not yet initialized
i(f()) { } // well-defined: bases are all initialized
};
— end example ]
14 [ Note: 12.7 describes the result of virtual function calls, typeid and dynamic_casts during construction for
the well-defined cases; that is, describes the polymorphic behavior of an object under construction. — end
note ]
15 A mem-initializer followed by an ellipsis is a pack expansion (14.5.3) that initializes the base classes specified
by a pack expansion in the base-specifier-list for the class. [ Example:
template<class... Mixins>
class X : public Mixins... {
public:
X(const Mixins&... mixins) : Mixins(mixins)... { }
};
— end example ]
12.7 Construction and destruction [class.cdtor]
1 For an object with a non-trivial constructor, referring to any non-static member or base class of the object
before the constructor begins execution results in undefined behavior. For an object with a non-trivial
destructor, referring to any non-static member or base class of the object after the destructor finishes
execution results in undefined behavior. [ Example:
struct X { int i; };
struct Y : X { Y(); }; // non-trivial
struct A { int a; };
struct B : public A { int j; Y y; }; // non-trivial
extern B bobj;
B* pb = &bobj; // OK
int* p1 = &bobj.a; // undefined, refers to base class member
int* p2 = &bobj.y.i; // undefined, refers to member’s member
A* pa = &bobj; // undefined, upcast to a base class type
B bobj; // definition of bobj
extern X xobj;
int* p3 = &xobj.i; //OK, X is a trivial class
X xobj;
2 For another example,
struct W { int j; };
struct X : public virtual W { };
struct Y {
int *p;
X x;
Y() : p(&x.j) { // undefined, x is not yet constructed
§ 12.7 274

 c ISO/IEC N3242=11-0012
}
};
— end example ]
3 To explicitly or implicitly convert a pointer (a glvalue) referring to an object of class X to a pointer (reference)
to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or
indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes
shall not have completed, otherwise the conversion results in undefined behavior. To form a pointer to (or
access the value of) a direct non-static member of an object obj, the construction of obj shall have started
and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing
the member value) results in undefined behavior. [ Example:
struct A { };
struct B : virtual A { };
struct C : B { };
struct D : virtual A { D(A*); };
struct X { X(A*); };
struct E : C, D, X {
E() : D(this), // undefined: upcast from E* to A*
// might use path E* → D* → A*
// but D is not constructed
// D((C*)this), // defined:
// E* → C* defined because E() has started
// and C* → A* defined because
// C fully constructed
X(this) { // defined: upon construction of X,
// C/B/D/A sublattice is fully constructed
}
};
— end example ]
4 Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2).
When a virtual function is called directly or indirectly from a constructor (including the mem-initializer or
brace-or-equal-initializer for a non-static data member) or from a destructor, and the object to which the
call applies is the object under construction or destruction, the function called is the one defined in the
constructor or destructor’s own class or in one of its bases, but not a function overriding it in a class derived
from the constructor or destructor’s class, or overriding it in one of the other base classes of the most derived
object (1.8). If the virtual function call uses an explicit class member access (5.2.5) and the object-expression
refers to the object under construction or destruction but its type is neither the constructor or destructor’s
own class or one of its bases, the result of the call is undefined. [ Example:
struct V {
virtual void f();
virtual void g();
};
struct A : virtual V {
virtual void f();
};
struct B : virtual V {
virtual void g();
§ 12.7 275

 c ISO/IEC N3242=11-0012
B(V*, A*);
};
struct D : A, B {
virtual void f();
virtual void g();
D() : B((A*)this, this) { }
};
B::B(V* v, A* a) {
f(); // calls V::f, not A::f
g(); // calls B::g, not D::g
v->g(); // v is base of B, the call is well-defined, calls B::g
a->f(); // undefined behavior, a’s type not a base of B
} —
end example ]
5 The typeid operator (5.2.8) can be used during construction or destruction (12.6.2). When typeid is used
in a constructor (including the mem-initializer or brace-or-equal-initializer for a non-static data member) or
in a destructor, or used in a function called (directly or indirectly) from a constructor or destructor, if the
operand of typeid refers to the object under construction or destruction, typeid yields the std::type_info
object representing the constructor or destructor’s class. If the operand of typeid refers to the object under
construction or destruction and the static type of the operand is neither the constructor or destructor’s class
nor one of its bases, the result of typeid is undefined.
6 dynamic_casts (5.2.7) can be used during construction or destruction (12.6.2). When a dynamic_cast
is used in a constructor (including the mem-initializer or brace-or-equal-initializer for a non-static data
member) or in a destructor, or used in a function called (directly or indirectly) from a constructor or
destructor, if the operand of the dynamic_cast refers to the object under construction or destruction, this
object is considered to be a most derived object that has the type of the constructor or destructor’s class. If
the operand of the dynamic_cast refers to the object under construction or destruction and the static type
of the operand is not a pointer to or object of the constructor or destructor’s own class or one of its bases,
the dynamic_cast results in undefined behavior.
[ Example:
struct V {
virtual void f();
};
struct A : virtual V { };
struct B : virtual V {
B(V*, A*);
};
struct D : A, B {
D() : B((A*)this, this) { }
};
B::B(V* v, A* a) {
typeid(*this); // type_info for B
typeid(*v); // well-defined: *v has type V, a base of B
// yields type_info for B
§ 12.7 276

 c ISO/IEC N3242=11-0012
typeid(*a); // undefined behavior: type A not a base of B
dynamic_cast<B*>(v); // well-defined: v of type V*, V base of B
// results in B*
dynamic_cast<B*>(a); // undefined behavior,
// a has type A*, A not a base of B
} —
end example ]
12.8 Copying and moving class objects [class.copy]
1 A class object can be copied or moved in two ways: by initialization (12.1, 8.5), including for function argument passing (5.2.2) and for function value return (6.6.3); and by assignment (5.17). Conceptually, these two
operations are implemented by a copy/move constructor (12.1) and copy/move assignment operator (13.5.3).
2 A non-template constructor for class X is a copy constructor if its first parameter is of type X&, const X&,
volatile X& or const volatile X&, and either there are no other parameters or else all other parameters
have default arguments (8.3.6). [ Example: X::X(const X&) and X::X(X&,int=1) are copy constructors.
struct X {
X(int);
X(const X&, int = 1);
};
X a(1); // calls X(int);
X b(a, 0); // calls X(const X&, int);
X c = b; // calls X(const X&, int);
— end example ]
3 A non-template constructor for class X is a move constructor if its first parameter is of type X&&, const
X&&, volatile X&&, or const volatile X&&, and either there are no other parameters or else all other
parameters have default arguments (8.3.6). [ Example: Y::Y(Y&&) is a move constructor.
struct Y {
Y(const Y&);
Y(Y&&);
};
extern Y f(int);
Y d(f(1)); // calls Y(Y&&)
Y e = d; // calls Y(const Y&)
— end example ]
4 [ Note: All forms of copy/move constructor may be declared for a class. [ Example:
struct X {
X(const X&);
X(X&); // OK
X(X&&);
X(const X&&); // OK, but possibly not sensible
};
— end example ] — end note ]
5 [ Note: If a class X only has a copy constructor with a parameter of type X&, an initializer of type const X
or volatile X cannot initialize an object of type (possibly cv-qualified) X. [ Example:
§ 12.8 277

 c ISO/IEC N3242=11-0012
struct X {
X(); // default constructor
X(X&); // copy constructor with a nonconst parameter
};
const X cx;
X x = cx; // error: X::X(X&) cannot copy cx into x
— end example ] — end note ]
6 A declaration of a constructor for a class X is ill-formed if its first parameter is of type (optionally cv-qualified)
X and either there are no other parameters or else all other parameters have default arguments.
7 A member function template is never instantiated to perform the copy of a class object to an object of its
class type. [ Example:
struct S {
template<typename T> S(T);
template<typename T> S(T&&);
S();
};
S f();
const S g;
void h() {
S a( f() ); // does not instantiate member template;
// uses the implicitly generated move constructor
S b(g); // does not instantiate the member template;
// uses the implicitly generated copy constructor
}
— end example ]
8 If the class definition does not explicitly declare a copy constructor, there is no user-declared move constructor, and there is no user-declared move assignment operator, a copy constructor is implicitly declared as
defaulted (8.4.2). Such an implicit declaration is deprecated if the class has a user-declared copy assignment
operator or a user-declared destructor. Thus, for the class definition
struct X {
X(const X&, int);
};
a copy constructor is implicitly-declared. If the user-declared constructor is later defined as
X::X(const X& x, int i =0) { /∗ ... ∗/ }
then any use of X’s copy constructor is ill-formed because of the ambiguity; no diagnostic is required.
9 The implicitly-declared copy constructor for a class X will have the form
X::X(const X&)
if
— each direct or virtual base class B of X has a copy constructor whose first parameter is of type const
B& or const volatile B&, and
§ 12.8 278

 c ISO/IEC N3242=11-0012
— for all the non-static data members of X that are of a class type M (or array thereof), each such class
type has a copy constructor whose first parameter is of type const M& or const volatile M&.119
Otherwise, the implicitly-declared copy constructor will have the form
X::X(X&)
10 If the definition of a class X does not explicitly declare a move constructor, one will be implicitly declared
as defaulted if and only if
— X does not have a user-declared copy constructor,
— X does not have a user-declared copy assignment operator,
— X does not have a user-declared move assignment operator,
— X does not have a user-declared destructor, and
— the move constructor would not be implicitly defined as deleted.
[ Note: When the move constructor is not implicitly declared or explicitly supplied, expressions that otherwise
would have invoked the move constructor may instead invoke a copy constructor. — end note ]
11 The implicitly-declared move constructor for class X will have the form
X::X(X&&)
12 An implicitly-declared copy/move constructor is an inline public member of its class. A defaulted copy-
/move constructor for a class X is defined as deleted (8.4.3) if X has:
— a variant member with a non-trivial corresponding constructor and X is a union-like class,
— a non-static data member of class type M (or array thereof) that cannot be copied/moved because
overload resolution (13.3), as applied to M’s corresponding constructor, results in an ambiguity or a
function that is deleted or inaccessible from the defaulted constructor, or
— a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as
applied to B’s corresponding constructor, results in an ambiguity or a function that is deleted or
inaccessible from the defaulted constructor, or
— for the copy constructor, a non-static data member of rvalue reference type, or
— for the move constructor, a non-static data member or direct or virtual base class with a type that
does not have a move constructor and is not trivially copyable.
13 A copy/move constructor for class X is trivial if it is neither user-provided nor deleted and if
— class X has no virtual functions (10.3) and no virtual base classes (10.1), and
— the constructor selected to copy/move each direct base class subobject is trivial, and
— for each non-static data member of X that is of class type (or array thereof), the constructor selected
to copy/move that member is trivial;
otherwise the copy/move constructor is non-trivial.
14 A copy/move constructor that is defaulted and not defined as deleted is implicitly defined if it is odr-used (3.2)
to initialize an object of its class type from a copy of an object of its class type or of a class type derived
119) This implies that the reference parameter of the implicitly-declared copy constructor cannot bind to a volatile lvalue;
see C.1.9.
§ 12.8 279

 c ISO/IEC N3242=11-0012
from its class type120 or when it is explicitly defaulted after its first declaration. [ Note: The copy/move
constructor is implicitly defined even if the implementation elided its odr-use (3.2, 12.2). — end note ]
15 Before the defaulted copy/move constructor for a class is implicitly defined, all non-user-provided copy/move
constructors for its direct and virtual base classes and its non-static data members shall have been implicitly
defined. [ Note: An implicitly-declared copy/move constructor has an exception-specification (15.4). — end
note ]
16 The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move
of its bases and members. [ Note: brace-or-equal-initializers of non-static data members are ignored. See
also the example in 12.6.2. — end note ] The order of initialization is the same as the order of initialization
of bases and members in a user-defined constructor (see 12.6.2). Let x be either the parameter of the
constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data
member is copied/moved in the manner appropriate to its type:
— if the member is an array, each element is direct-initialized with the corresponding subobject of x;
— if a member m has rvalue reference type T&&, it is direct-initialized with static_cast<T&&>(x.m);
— otherwise, the base or member is direct-initialized with the corresponding base or member of x.
Virtual base class subobjects shall be initialized only once by the implicitly-defined copy/move constructor
(see 12.6.2).
17 The implicitly-defined copy/move constructor for a union X copies the object representation (3.9) of X.
18 A user-declared copy assignment operator X::operator= is a non-static non-template member function of
class X with exactly one parameter of type X, X&, const X&, volatile X& or const volatile X&.121 [ Note:
An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ]
[ Note: More than one form of copy assignment operator may be declared for a class. — end note ] [ Note:
If a class X only has a copy assignment operator with a parameter of type X&, an expression of type const X
cannot be assigned to an object of type X. [ Example:
struct X {
X();
X& operator=(X&);
};
const X cx;
X x;
void f() {
x = cx; // error: X::operator=(X&) cannot assign cx into x
} —
end example ] — end note ]
19 If the class definition does not explicitly declare a copy assignment operator, there is no user-declared move
constructor, and there is no user-declared move assignment operator, a copy assignment operator is implicitly
declared as defaulted (8.4.2). Such implicit declaration is deprecated if the class has a user-declared copy
constructor or a user-declared destructor. The implicitly-declared copy assignment operator for a class X
will have the form
X& X::operator=(const X&)
120) See 8.5 for more details on direct and copy initialization.
121) Because a template assignment operator or an assignment operator taking an rvalue reference parameter is never a
copy assignment operator, the presence of such an assignment operator does not suppress the implicit declaration of a copy
assignment operator. Such assignment operators participate in overload resolution with other assignment operators, including
copy assignment operators, and, if selected, will be used to assign an object.
§ 12.8 280

 c ISO/IEC N3242=11-0012
if
— each direct base class B of X has a copy assignment operator whose parameter is of type const B&,
const volatile B& or B, and
— for all the non-static data members of X that are of a class type M (or array thereof), each such class
type has a copy assignment operator whose parameter is of type const M&, const volatile M& or M.122
Otherwise, the implicitly-declared copy assignment operator will have the form
X& X::operator=(X&)
20 A user-declared move assignment operator X::operator= is a non-static non-template member function of
class X with exactly one parameter of type X&&, const X&&, volatile X&&, or const volatile X&&. [ Note:
An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ]
[ Note: More than one form of move assignment operator may be declared for a class. — end note ]
21 If the definition of a class X does not explicitly declare a move assignment operator, one will be implicitly
declared as defaulted if and only if
— X does not have a user-declared copy constructor,
— X does not have a user-declared move constructor,
— X does not have a user-declared copy assignment operator,
— X does not have a user-declared destructor, and
— the move assignment operator would not be implicitly defined as deleted.
[ Example: The class definition
struct S {
int a;
S& operator=(const S&) = default;
};
will not have a default move assignment operator implicitly declared because the copy assignment operator
has been user-declared. The move assignment operator may be explicitly defaulted.
struct S {
int a;
S& operator=(const S&) = default;
S& operator=(S&&) = default;
};
— end example ]
22 The implicitly-declared move assignment operator for a class X will have the form
X& X::operator=(X&&);
23 The implicitly-declared copy/move assignment operator for class X has the return type X&; it returns the
object for which the assignment operator is invoked, that is, the object assigned to. An implicitly-declared
copy/move assignment operator is an inline public member of its class.
24 A defaulted copy/move assignment operator for class X is defined as deleted if X has:
122) This implies that the reference parameter of the implicitly-declared copy assignment operator cannot bind to a volatile
lvalue; see C.1.9.
§ 12.8 281

 c ISO/IEC N3242=11-0012
— a variant member with a non-trivial corresponding assignment operator and X is a union-like class, or
— a non-static data member of const non-class type (or array thereof), or
— a non-static data member of reference type, or
— a non-static data member of class type M (or array thereof) that cannot be copied/moved because
overload resolution (13.3), as applied to M’s corresponding assignment operator, results in an ambiguity
or a function that is deleted or inaccessible from the defaulted assignment operator, or
— a direct or virtual base class B that cannot be copied/moved because overload resolution (13.3), as
applied to B’s corresponding assignment operator, results in an ambiguity or a function that is deleted
or inaccessible from the defaulted assignment operator, or
— for the move assignment operator, a non-static data member or direct base class with a type that does
not have a move assignment operator and is not trivially copyable, or any direct or indirect virtual
base class.
25 Because a copy/move assignment operator is implicitly declared for a class if not declared by the user, a
base class copy/move assignment operator is always hidden by the corresponding assignment operator of a
derived class (13.5.3). A using-declaration (7.3.3) that brings in from a base class an assignment operator
with a parameter type that could be that of a copy/move assignment operator for the derived class is not
considered an explicit declaration of such an operator and does not suppress the implicit declaration of the
derived class operator; the operator introduced by the using-declaration is hidden by the implicitly-declared
operator in the derived class.
26 A copy/move assignment operator for class X is trivial if it is neither user-provided nor deleted and if
— class X has no virtual functions (10.3) and no virtual base classes (10.1), and
— the assignment operator selected to copy/move each direct base class subobject is trivial, and
— for each non-static data member of X that is of class type (or array thereof), the assignment operator
selected to copy/move that member is trivial;
otherwise the copy/move assignment operator is non-trivial.
27 A copy/move assignment operator that is defaulted and not defined as deleted is implicitly defined when it
is odr-used (3.2) (e.g., when it is selected by overload resolution to assign to an object of its class type) or
when it is explicitly defaulted after its first declaration.
28 Before the defaulted copy/move assignment operator for a class is implicitly defined, all non-user-provided
copy/move assignment operators for its direct base classes and its non-static data members shall have
been implicitly defined. [ Note: An implicitly-declared copy/move assignment operator has an exceptionspecification (15.4). — end note ]
29 The implicitly-defined copy/move assignment operator for a non-union class X performs memberwise copy-
/move assignment of its subobjects. The direct base classes of X are assigned first, in the order of their
declaration in the base-specifier-list, and then the immediate non-static data members of X are assigned, in
the order in which they were declared in the class definition. Let x be either the parameter of the function
or, for the move operator, an xvalue referring to the parameter. Each subobject is assigned in the manner
appropriate to its type:
— if the subobject is of class type, as if by a call to operator= with the subobject as the object expression
and the corresponding subobject of x as a single function argument (as if by explicit qualification; that
is, ignoring any possible virtual overriding functions in more derived classes);
— if the subobject is an array, each element is assigned, in the manner appropriate to the element type;
§ 12.8 282

 c ISO/IEC N3242=11-0012
— if the subobject is of scalar type, the built-in assignment operator is used.
It is unspecified whether subobjects representing virtual base classes are assigned more than once by the
implicitly-defined copy assignment operator. [ Example:
struct V { };
struct A : virtual V { };
struct B : virtual V { };
struct C : B, A { };
It is unspecified whether the virtual base class subobject V is assigned twice by the implicitly-defined copy
assignment operator for C. — end example ] [ Note: This does not apply to move assignment, as a defaulted
move assignment operator is deleted if the class has virtual bases. — end note ]
30 The implicitly-defined copy assignment operator for a union X copies the object representation (3.9) of X.
31 A program is ill-formed if the copy/move constructor or the copy/move assignment operator for an object is
implicitly odr-used and the special member function is not accessible (Clause 11). [ Note: Copying/moving
one object into another using the copy/move constructor or the copy/move assignment operator does not
change the layout or size of either object. — end note ]
32 When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class
object, even if the copy/move constructor and/or destructor for the object have side effects. In such cases,
the implementation treats the source and target of the omitted copy/move operation as simply two different
ways of referring to the same object, and the destruction of that object occurs at the later of the times
when the two objects would have been destroyed without the optimization.123 This elision of copy/move
operations, called copy elision, is permitted in the following circumstances (which may be combined to
eliminate multiple copies):
— in a return statement in a function with a class return type, when the expression is the name of a
non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing
the automatic object directly into the function’s return value
— in a throw-expression, when the operand is the name of a non-volatile automatic object (other than
a function or catch-clause parameter) whose scope does not extend beyond the end of the innermost
enclosing try-block (if there is one), the copy/move operation from the operand to the exception
object (15.1) can be omitted by constructing the automatic object directly into the exception object
— when a temporary class object that has not been bound to a reference (12.2) would be copied/moved
to a class object with the same cv-unqualified type, the copy/move operation can be omitted by
constructing the temporary object directly into the target of the omitted copy/move
— when the exception-declaration of an exception handler (Clause 15) declares an object of the same type
(except for cv-qualification) as the exception object (15.1), the copy/move operation can be omitted
by treating the exception-declaration as an alias for the exception object if the meaning of the program
will be unchanged except for the execution of constructors and destructors for the object declared by
the exception-declaration.
[ Example:
class Thing {
public:
Thing();
123) Because only one object is destroyed instead of two, and one copy/move constructor is not executed, there is still one
object destroyed for each one constructed.
§ 12.8 283

 c ISO/IEC N3242=11-0012
~Thing();
Thing(const Thing&);
};
Thing f() {
Thing t;
return t;
}
Thing t2 = f();
Here the criteria for elision can be combined to eliminate two calls to the copy constructor of class Thing:
the copying of the local automatic object t into the temporary object for the return value of function f()
and the copying of that temporary object into object t2. Effectively, the construction of the local object
t can be viewed as directly initializing the global object t2, and that object’s destruction will occur at
program exit. Adding a move constructor to Thing has the same effect, but it is the move construction from
the temporary object to t2 that is elided. — end example ]
33 When the criteria for elision of a copy operation are met or would be met save for the fact that the source
object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to
select the constructor for the copy is first performed as if the object were designated by an rvalue. If overload
resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to
the object’s type (possibly cv-qualified), overload resolution is performed again, considering the object as an
lvalue. [ Note: This two-stage overload resolution must be performed regardless of whether copy elision will
occur. It determines the constructor to be called if elision is not performed, and the selected constructor
must be accessible even if the call is elided. — end note ]
[ Example:
class Thing {
public:
Thing();
~Thing();
Thing(Thing&&);
private:
Thing(const Thing&);
};
Thing f(bool b) {
Thing t;
if (b)
throw t; // OK: Thing(Thing&&) used (or elided) to throw t
return t; // OK: Thing(Thing&&) used (or elided) to return t
}
Thing t2 = f(false); // OK: Thing(Thing&&) used (or elided) to construct t2
— end example ]
12.9 Inheriting constructors [class.inhctor]
1 A using-declaration (7.3.3) that names a constructor implicitly declares a set of inheriting constructors. The
candidate set of inherited constructors from the class X named in the using-declaration consists of actual
constructors and notional constructors that result from the transformation of defaulted parameters as follows:
§ 12.9 284

 c ISO/IEC N3242=11-0012
— all non-template constructors of X, and
— for each non-template constructor of X that has at least one parameter with a default argument, the set
of constructors that results from omitting any ellipsis parameter specification and successively omitting
parameters with a default argument from the end of the parameter-type-list, and
— all constructor templates of X, and
— for each constructor template of X that has at least one parameter with a default argument, the set of
constructor templates that results from omitting any ellipsis parameter specification and successively
omitting parameters with a default argument from the end of the parameter-type-list.
2 The constructor characteristics of a constructor or constructor template are
— the template parameter list (14.1), if any,
— the parameter-type-list (8.3.5),
— the exception-specification (15.4),
— absence or presence of explicit (12.3.1), and
— absence or presence of constexpr (7.1.5).
3 For each non-template constructor in the candidate set of inherited constructors other than a constructor
having no parameters or a copy/move constructor having a single parameter, a constructor is implicitly
declared with the same constructor characteristics unless there is a user-declared constructor with the same
signature in the class where the using-declaration appears. Similarly, for each constructor template in
the candidate set of inherited constructors, a constructor template is implicitly declared with the same
constructor characteristics unless there is an equivalent user-declared constructor template (14.5.6.1) in the
class where the using-declaration appears. [ Note: Default arguments are not inherited. — end note ]
4 A constructor so declared has the same access as the corresponding constructor in X. It is deleted if the
corresponding constructor in X is deleted (8.4).
5 [ Note: Default and copy/move constructors may be implicitly declared as specified in 12.1 and 12.8. — end
note ]
6 [ Example:
struct B1 {
B1(int);
};
struct B2 {
B2(int = 13, int = 42);
};
struct D1 : B1 {
using B1::B1;
};
struct D2 : B2 {
using B2::B2;
};
The candidate set of inherited constructors in D1 for B1 is
— B1(const B1&)
§ 12.9 285

 c ISO/IEC N3242=11-0012
— B1(B1&&)
— B1(int)
The set of constructors present in D1 is
— D1(), implicitly-declared default constructor, ill-formed if odr-used
— D1(const D1&), implicitly-declared copy constructor, not inherited
— D1(D1&&), implicitly-declared move constructor, not inherited
— D1(int), implicitly-declared inheriting constructor
The candidate set of inherited constructors in D2 for B2 is
— B2(const B2&)
— B2(B2&&)
— B2(int = 13, int = 42)
— B2(int = 13)
— B2()
The set of constructors present in D2 is
— D2(), implicitly-declared default constructor, not inherited
— D2(const D2&), implicitly-declared copy constructor, not inherited
— D2(D2&&), implicitly-declared move constructor, not inherited
— D2(int, int), implicitly-declared inheriting constructor
— D2(int), implicitly-declared inheriting constructor
— end example ]
7 [ Note: If two using-declarations declare inheriting constructors with the same signatures, the program is
ill-formed (9.2, 13.1), because an implicitly-declared constructor introduced by the first using-declaration is
not a user-declared constructor and thus does not preclude another declaration of a constructor with the
same signature by a subsequent using-declaration. [ Example:
struct B1 {
B1(int);
};
struct B2 {
B2(int);
};
struct D1 : B1, B2 {
using B1::B1;
using B2::B2;
}; // ill-formed: attempts to declare D1(int) twice
struct D2 : B1, B2 {
using B1::B1;
using B2::B2;
D2(int); // OK: user declaration supersedes both implicit declarations
};
§ 12.9 286

 c ISO/IEC N3242=11-0012
— end example ] — end note ]
8 An inheriting constructor for a class is implicitly defined when it is odr-used (3.2) to create an object of its
class type (1.8). An implicitly-defined inheriting constructor performs the set of initializations of the class
that would be performed by a user-written inline constructor for that class with a mem-initializer-list whose
only mem-initializer has a mem-initializer-id that names the base class denoted in the nested-name-specifier
of the using-declaration and an expression-list as specified below, and where the compound-statement in
its function body is empty (12.6.2). If that user-written constructor would be ill-formed, the program is
ill-formed. Each expression in the expression-list is of the form static_cast<T&&>(p), where p is the name
of the corresponding constructor parameter and T is the declared type of p.
9 [ Example:
struct B1 {
B1(int) { }
};
struct B2 {
B2(double) { }
};
struct D1 : B1 {
using B1::B1; // implicitly declares D1(int)
int x;
};
void test() {
D1 d(6); // OK: d.x is not initialized
D1 e; // error: D1 has no default constructor
}
struct D2 : B2 {
using B2::B2; // OK: implicitly declares D2(double)
B1 b;
};
D2 f(1.0); // error: B1 has no default constructor
template< class T >
struct D : T {
using T::T; // declares all constructors from class T
~D() { std::clog << "Destroying wrapper" << std::endl; }
};
Class template D wraps any class and forwards all of its constructors, while writing a message to the standard
log whenever an object of class D is destroyed. — end example ]
§ 12.9 287

 c ISO/IEC N3242=11-0012
13 Overloading [over]
1 When two or more different declarations are specified for a single name in the same scope, that name is said
to be overloaded. By extension, two declarations in the same scope that declare the same name but with
different types are called overloaded declarations. Only function and function template declarations can be
overloaded; variable and type declarations cannot be overloaded.
2 When an overloaded function name is used in a call, which overloaded function declaration is being referenced
is determined by comparing the types of the arguments at the point of use with the types of the parameters
in the overloaded declarations that are visible at the point of use. This function selection process is called
overload resolution and is defined in 13.3. [ Example:
double abs(double);
int abs(int);
abs(1); // calls abs(int);
abs(1.0); // calls abs(double);
— end example ]
13.1 Overloadable declarations [over.load]
1 Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A
program is ill-formed if it contains two such non-overloadable declarations in the same scope. [ Note: This
restriction applies to explicit declarations in a scope, and between such declarations and declarations made
through a using-declaration (7.3.3). It does not apply to sets of functions fabricated as a result of name
lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). — end note ]
2 Certain function declarations cannot be overloaded:
— Function declarations that differ only in the return type cannot be overloaded.
— Member function declarations with the same name and the same parameter-type-list cannot be overloaded if any of them is a static member function declaration (9.4). Likewise, member function
template declarations with the same name, the same parameter-type-list, and the same template parameter lists cannot be overloaded if any of them is a static member function template declaration.
The types of the implicit object parameters constructed for the member functions for the purpose of
overload resolution (13.3.1) are not considered when comparing parameter-type-lists for enforcement of
this rule. In contrast, if there is no static member function declaration among a set of member function declarations with the same name and the same parameter-type-list, then these member function
declarations can be overloaded if they differ in the type of their implicit object parameter. [ Example:
the following illustrates this distinction:
class X {
static void f();
void f(); // ill-formed
void f() const; // ill-formed
void f() const volatile; // ill-formed
void g();
void g() const; // OK: no static g
void g() const volatile; // OK: no static g
};
§ 13.1 288

 c ISO/IEC N3242=11-0012
— end example ]
— Member function declarations with the same name and the same parameter-type-list as well as member function template declarations with the same name, the same parameter-type-list, and the same
template parameter lists cannot be overloaded if any of them, but not all, have a ref-qualifier (8.3.5).
[ Example:
class Y {
void h() &;
void h() const &; // OK
void h() &&; // OK, all declarations have a ref-qualifier
void i() &;
void i() const; // ill-formed, prior declaration of i
// has a ref-qualifier
};
— end example ]
3 [ Note: As specified in 8.3.5, function declarations that have equivalent parameter declarations declare the
same function and therefore cannot be overloaded:
— Parameter declarations that differ only in the use of equivalent typedef “types” are equivalent. A
typedef is not a separate type, but only a synonym for another type (7.1.3). [ Example:
typedef int Int;
void f(int i);
void f(Int i); // OK: redeclaration of f(int)
void f(int i) { /* ... */ }
void f(Int i) { /* ... */ } // error: redefinition of f(int)
— end example ]
Enumerations, on the other hand, are distinct types and can be used to distinguish overloaded function
declarations. [ Example:
enum E { a };
void f(int i) { /* ... */ }
void f(E i) { /* ... */ }
— end example ]
— Parameter declarations that differ only in a pointer * versus an array [] are equivalent. That is, the
array declaration is adjusted to become a pointer declaration (8.3.5). Only the second and subsequent
array dimensions are significant in parameter types (8.3.4). [ Example:
int f(char*);
int f(char[]); // same as f(char*);
int f(char[7]); // same as f(char*);
int f(char[9]); // same as f(char*);
int g(char(*)[10]);
int g(char[5][10]); // same as g(char(*)[10]);
int g(char[7][10]); // same as g(char(*)[10]);
int g(char(*)[20]); // different from g(char(*)[10]);
— end example ]
§ 13.1 289

 c ISO/IEC N3242=11-0012
— Parameter declarations that differ only in that one is a function type and the other is a pointer to
the same function type are equivalent. That is, the function type is adjusted to become a pointer to
function type (8.3.5). [ Example:
void h(int());
void h(int (*)()); // redeclaration of h(int())
void h(int x()) { } // definition of h(int())
void h(int (*x)()) { } // ill-formed: redefinition of h(int())
— end example ]
— Parameter declarations that differ only in the presence or absence of const and/or volatile are
equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when
determining which function is being declared, defined, or called. [ Example:
typedef const int cInt;
int f (int);
int f (const int); // redeclaration of f(int)
int f (int) { /* ... */ } // definition of f(int)
int f (cInt) { /* ... */ } // error: redefinition of f(int)
— end example ]
Only the const and volatile type-specifiers at the outermost level of the parameter type specification are ignored in this fashion; const and volatile type-specifiers buried within a parameter type
specification are significant and can be used to distinguish overloaded function declarations.124 In
particular, for any type T, “pointer to T,” “pointer to const T,” and “pointer to volatile T” are
considered distinct parameter types, as are “reference to T,” “reference to const T,” and “reference to
volatile T.”
— Two parameter declarations that differ only in their default arguments are equivalent. [ Example:
consider the following:
void f (int i, int j);
void f (int i, int j = 99); // OK: redeclaration of f(int, int)
void f (int i = 88, int j); // OK: redeclaration of f(int, int)
void f (); // OK: overloaded declaration of f
void prog () {
f (1, 2); // OK: call f(int, int)
f (1); // OK: call f(int, int)
f (); // Error: f(int, int) or f()?
}
— end example ] — end note ]
13.2 Declaration matching [over.dcl]
1 Two function declarations of the same name refer to the same function if they are in the same scope and
have equivalent parameter declarations (13.1). A function member of a derived class is not in the same scope
as a function member of the same name in a base class. [ Example:
124) When a parameter type includes a function type, such as in the case of a parameter type that is a pointer to function, the
const and volatile type-specifiers at the outermost level of the parameter type specifications for the inner function type are
also ignored.
§ 13.2 290

 c ISO/IEC N3242=11-0012
struct B {
int f(int);
};
struct D : B {
int f(const char*);
};
Here D::f(const char*) hides B::f(int) rather than overloading it.
void h(D* pd) {
pd->f(1); // error:
// D::f(const char*) hides B::f(int)
pd->B::f(1); // OK
pd->f("Ben"); // OK, calls D::f
}
— end example ]
2 A locally declared function is not in the same scope as a function in a containing scope. [ Example:
void f(const char*);
void g() {
extern void f(int);
f("asdf"); // error: f(int) hides f(const char*)
// so there is no f(const char*) in this scope
}
void caller () {
extern void callee(int, int);
{
extern void callee(int); // hides callee(int, int)
callee(88, 99); // error: only callee(int) in scope
}
}
— end example ]
3 Different versions of an overloaded member function can be given different access rules. [ Example:
class buffer {
private:
char* p;
int size;
protected:
buffer(int s, char* store) { size = s; p = store; }
public:
buffer(int s) { p = new char[size = s]; }
};
— end example ]
13.3 Overload resolution [over.match]
1 Overload resolution is a mechanism for selecting the best function to call given a list of expressions that are
to be the arguments of the call and a set of candidate functions that can be called based on the context of
the call. The selection criteria for the best function are the number of arguments, how well the arguments
§ 13.3 291

 c ISO/IEC N3242=11-0012
match the parameter-type-list of the candidate function, how well (for non-static member functions) the
object matches the implicit object parameter, and certain other properties of the candidate function. [ Note:
The function selected by overload resolution is not guaranteed to be appropriate for the context. Other
restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed.
— end note ]
2 Overload resolution selects the function to call in seven distinct contexts within the language:
— invocation of a function named in the function call syntax (13.3.1.1.1);
— invocation of a function call operator, a pointer-to-function conversion function, a reference-to-pointerto-function conversion function, or a reference-to-function conversion function on a class object named
in the function call syntax (13.3.1.1.2);
— invocation of the operator referenced in an expression (13.3.1.2);
— invocation of a constructor for direct-initialization (8.5) of a class object (13.3.1.3);
— invocation of a user-defined conversion for copy-initialization (8.5) of a class object (13.3.1.4);
— invocation of a conversion function for initialization of an object of a nonclass type from an expression
of class type (13.3.1.5); and
— invocation of a conversion function for conversion to a glvalue or class prvalue to which a reference (8.5.3) will be directly bound (13.3.1.6).
Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way.
But, once the candidate functions and argument lists have been identified, the selection of the best function
is the same in all cases:
— First, a subset of the candidate functions (those that have the proper number of arguments and meet
certain other conditions) is selected to form a set of viable functions (13.3.2).
— Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed
to match each argument to the corresponding parameter of each viable function.
3 If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.
Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and
the best viable function is not accessible (Clause 11) in the context in which it is used, the program is
ill-formed.
13.3.1 Candidate functions and argument lists [over.match.funcs]
1 The subclauses of 13.3.1 describe the set of candidate functions and the argument list submitted to overload
resolution in each of the seven contexts in which overload resolution is used. The source transformations
and constructions defined in these subclauses are only for the purpose of describing the overload resolution
process. An implementation is not required to use such transformations and constructions.
2 The set of candidate functions can contain both member and non-member functions to be resolved against
the same argument list. So that argument and parameter lists are comparable within this heterogeneous
set, a member function is considered to have an extra parameter, called the implicit object parameter, which
represents the object for which the member function has been called. For the purposes of overload resolution,
both static and non-static member functions have an implicit object parameter, but constructors do not.
3 Similarly, when appropriate, the context can construct an argument list that contains an implied object
argument to denote the object to be operated on. Since arguments and parameters are associated by
§ 13.3.1 292

 c ISO/IEC N3242=11-0012
position within their respective lists, the convention is that the implicit object parameter, if present, is
always the first parameter and the implied object argument, if present, is always the first argument.
4 For non-static member functions, the type of the implicit object parameter is
— “lvalue reference to cv X” for functions declared without a ref-qualifier or with the & ref-qualifier
— “rvalue reference to cv X” for functions declared with the && ref-qualifier
where X is the class of which the function is a member and cv is the cv-qualification on the member function
declaration. [ Example: for a const member function of class X, the extra parameter is assumed to have
type “reference to const X”. — end example ] For conversion functions, the function is considered to be
a member of the class of the implied object argument for the purpose of defining the type of the implicit
object parameter. For non-conversion functions introduced by a using-declaration into a derived class, the
function is considered to be a member of the derived class for the purpose of defining the type of the implicit
object parameter. For static member functions, the implicit object parameter is considered to match any
object (since if the function is selected, the object is discarded). [ Note: No actual type is established for
the implicit object parameter of a static member function, and no attempt will be made to determine a
conversion sequence for that parameter (13.3.3). — end note ]
5 During overload resolution, the implied object argument is indistinguishable from other arguments. The
implicit object parameter, however, retains its identity since conversions on the corresponding argument
shall obey these additional rules:
— no temporary object can be introduced to hold the argument for the implicit object parameter; and
— no user-defined conversions can be applied to achieve a type match with it.
For non-static member functions declared without a ref-qualifier, an additional rule applies:
— even if the implicit object parameter is not const-qualified, an rvalue can be bound to the parameter as
long as in all other respects the argument can be converted to the type of the implicit object parameter.
[ Note: The fact that such an argument is an rvalue does not affect the ranking of implicit conversion
sequences (13.3.3.2). — end note ]
6 Because other than in list-initialization only one user-defined conversion is allowed in an implicit conversion
sequence, special rules apply when selecting the best user-defined conversion (13.3.3, 13.3.3.1). [ Example:
class T {
public:
T();
};
class C : T {
public:
C(int);
};
T a = 1; // ill-formed: T(C(1)) not tried
— end example ]
7 In each case where a candidate is a function template, candidate function template specializations are generated using template argument deduction (14.8.3, 14.8.2). Those candidates are then handled as candidate
functions in the usual way.125 A given name can refer to one or more function templates and also to a set
125) The process of argument deduction fully determines the parameter types of the function template specializations, i.e.,
the parameters of function template specializations contain no template parameter types. Therefore the function template
specializations can be treated as normal (non-template) functions for the remainder of overload resolution.
§ 13.3.1 293

 c ISO/IEC N3242=11-0012
of overloaded non-template functions. In such a case, the candidate functions generated from each function
template are combined with the set of non-template candidate functions.
13.3.1.1 Function call syntax [over.match.call]
1 In a function call (5.2.2)
postfix-expression ( expression-listopt)
if the postfix-expression denotes a set of overloaded functions and/or function templates, overload resolution
is applied as specified in 13.3.1.1.1. If the postfix-expression denotes an object of class type, overload
resolution is applied as specified in 13.3.1.1.2.
2 If the postfix-expression denotes the address of a set of overloaded functions and/or function templates,
overload resolution is applied using that set as described above. If the function selected by overload resolution
is a non-static member function, the program is ill-formed. [ Note: The resolution of the address of an
overload set in other contexts is described in 13.4. — end note ]
13.3.1.1.1 Call to named function [over.call.func]
1 Of interest in 13.3.1.1.1 are only those function calls in which the postfix-expression ultimately contains a
name that denotes one or more functions that might be called. Such a postfix-expression, perhaps nested
arbitrarily deep in parentheses, has one of the following forms:
postfix-expression:
postfix-expression . id-expression
postfix-expression -> id-expression
primary-expression
These represent two syntactic subcategories of function calls: qualified function calls and unqualified function
calls.
2 In qualified function calls, the name to be resolved is an id-expression and is preceded by an -> or . operator.
Since the construct A->B is generally equivalent to (*A).B, the rest of Clause 13 assumes, without loss of
generality, that all member function calls have been normalized to the form that uses an object and the
. operator. Furthermore, Clause 13 assumes that the postfix-expression that is the left operand of the .
operator has type “cv T” where T denotes a class126. Under this assumption, the id-expression in the call
is looked up as a member function of T following the rules for looking up names in classes (10.2). The
function declarations found by that lookup constitute the set of candidate functions. The argument list
is the expression-list in the call augmented by the addition of the left operand of the . operator in the
normalized member function call as the implied object argument (13.3.1).
3 In unqualified function calls, the name is not qualified by an -> or . operator and has the more general form
of a primary-expression. The name is looked up in the context of the function call following the normal rules
for name lookup in function calls (3.4). The function declarations found by that lookup constitute the set of
candidate functions. Because of the rules for name lookup, the set of candidate functions consists (1) entirely
of non-member functions or (2) entirely of member functions of some class T. In case (1), the argument list
is the same as the expression-list in the call. In case (2), the argument list is the expression-list in the call
augmented by the addition of an implied object argument as in a qualified function call. If the keyword
this (9.3.2) is in scope and refers to class T, or a derived class of T, then the implied object argument is
(*this). If the keyword this is not in scope or refers to another class, then a contrived object of type
126) Note that cv-qualifiers on the type of objects are significant in overload resolution for both glvalue and class prvalue
objects.
§ 13.3.1.1.1 294

 c ISO/IEC N3242=11-0012
T becomes the implied object argument127. If the argument list is augmented by a contrived object and
overload resolution selects one of the non-static member functions of T, the call is ill-formed.
13.3.1.1.2 Call to object of class type [over.call.object]
1 If the primary-expression E in the function call syntax evaluates to a class object of type “cv T”, then the
set of candidate functions includes at least the function call operators of T. The function call operators of T
are obtained by ordinary lookup of the name operator() in the context of (E).operator().
2 In addition, for each non-explicit conversion function declared in T of the form
operator conversion-type-id ( ) attribute-specifier-seqopt cv-qualifier ;
where cv-qualifier is the same cv-qualification as, or a greater cv-qualification than, cv, and where conversiontype-id denotes the type “pointer to function of (P1,...,Pn) returning R”, or the type “reference to pointer to
function of (P1,...,Pn) returning R”, or the type “reference to function of (P1,...,Pn) returning R”, a surrogate
call function with the unique name call-function and having the form
R call-function ( conversion-type-id F, P1 a1, ... ,Pn an) { return F (a1,... ,an); }
is also considered as a candidate function. Similarly, surrogate call functions are added to the set of candidate
functions for each non-explicit conversion function declared in a base class of T provided the function is not
hidden within T by another intervening declaration128.
3 If such a surrogate call function is selected by overload resolution, the corresponding conversion function will
be called to convert E to the appropriate function pointer or reference, and the function will then be invoked
with the arguments of the call. If the conversion function cannot be called (e.g., because of an ambiguity),
the program is ill-formed.
4 The argument list submitted to overload resolution consists of the argument expressions present in the
function call syntax preceded by the implied object argument (E). [ Note: When comparing the call against
the function call operators, the implied object argument is compared against the implicit object parameter
of the function call operator. When comparing the call against a surrogate call function, the implied object
argument is compared against the first parameter of the surrogate call function. The conversion function
from which the surrogate call function was derived will be used in the conversion sequence for that parameter
since it converts the implied object argument to the appropriate function pointer or reference required by
that first parameter. — end note ] [ Example:
int f1(int);
int f2(float);
typedef int (*fp1)(int);
typedef int (*fp2)(float);
struct A {
operator fp1() { return f1; }
operator fp2() { return f2; }
} a;
int i = a(1); // calls f1 via pointer returned from
// conversion function
127) An implied object argument must be contrived to correspond to the implicit object parameter attributed to member
functions during overload resolution. It is not used in the call to the selected function. Since the member functions all have
the same implicit object parameter, the contrived object will not be the cause to select or reject a function.
128) Note that this construction can yield candidate call functions that cannot be differentiated one from the other by overload
resolution because they have identical declarations or differ only in their return type. The call will be ambiguous if overload
resolution cannot select a match to the call that is uniquely better than such undifferentiable functions.
§ 13.3.1.1.2 295

 c ISO/IEC N3242=11-0012
— end example ]
13.3.1.2 Operators in expressions [over.match.oper]
1 If no operand of an operator in an expression has a type that is a class or an enumeration, the operator
is assumed to be a built-in operator and interpreted according to Clause 5. [ Note: Because ., .*, and ::
cannot be overloaded, these operators are always built-in operators interpreted according to Clause 5. ?:
cannot be overloaded, but the rules in this subclause are used to determine the conversions to be applied to
the second and third operands when they have class or enumeration type (5.16). — end note ] [ Example:
struct String {
String (const String&);
String (const char*);
operator const char* ();
};
String operator + (const String&, const String&);
void f(void) {
const char* p= "one" + "two"; // ill-formed because neither
// operand has user-defined type
int I = 1 + 1; // Always evaluates to 2 even if
// user-defined types exist which
// would perform the operation.
}
— end example ]
2 If either operand has a type that is a class or an enumeration, a user-defined operator function might be
declared that implements this operator or a user-defined conversion can be necessary to convert the operand
to a type that is appropriate for a built-in operator. In this case, overload resolution is used to determine
which operator function or built-in operator is to be invoked to implement the operator. Therefore, the
operator notation is first transformed to the equivalent function-call notation as summarized in Table 11
(where @ denotes one of the operators covered in the specified subclause).
Table 11 — Relationship between operator and function call notation
Subclause Expression As member function As non-member function
13.5.1 @a (a).operator@ ( ) operator@ (a)
13.5.2 a@b (a).operator@ (b) operator@ (a, b)
13.5.3 a=b (a).operator= (b)
13.5.5 a[b] (a).operator[](b)
13.5.6 a-> (a).operator-> ( )
13.5.7 a@ (a).operator@ (0) operator@ (a, 0)
3 For a unary operator @ with an operand of a type whose cv-unqualified version is T1, and for a binary
operator @ with a left operand of a type whose cv-unqualified version is T1 and a right operand of a type
whose cv-unqualified version is T2, three sets of candidate functions, designated member candidates, nonmember candidates and built-in candidates, are constructed as follows:
— If T1 is a complete class type, the set of member candidates is the result of the qualified lookup of
T1::operator@ (13.3.1.1.1); otherwise, the set of member candidates is empty.
— The set of non-member candidates is the result of the unqualified lookup of operator@ in the context
of the expression according to the usual rules for name lookup in unqualified function calls (3.4.2)
except that all member functions are ignored. However, if no operand has a class type, only those
§ 13.3.1.2 296

 c ISO/IEC N3242=11-0012
non-member functions in the lookup set that have a first parameter of type T1 or “reference to (possibly
cv-qualified) T1”, when T1 is an enumeration type, or (if there is a right operand) a second parameter
of type T2 or “reference to (possibly cv-qualified) T2”, when T2 is an enumeration type, are candidate
functions.
— For the operator ,, the unary operator &, or the operator ->, the built-in candidates set is empty.
For all other operators, the built-in candidates include all of the candidate operator functions defined
in 13.6 that, compared to the given operator,
— have the same operator name, and
— accept the same number of operands, and
— accept operand types to which the given operand or operands can be converted according to 13.3.3.1,
and
— do not have the same parameter-type-list as any non-template non-member candidate.
4 For the built-in assignment operators, conversions of the left operand are restricted as follows:
— no temporaries are introduced to hold the left operand, and
— no user-defined conversions are applied to the left operand to achieve a type match with the left-most
parameter of a built-in candidate.
5 For all other operators, no such restrictions apply.
6 The set of candidate functions for overload resolution is the union of the member candidates, the non-member
candidates, and the built-in candidates. The argument list contains all of the operands of the operator. The
best function from the set of candidate functions is selected according to 13.3.2 and 13.3.3.129 [ Example:
struct A {
operator int();
};
A operator+(const A&, const A&);
void m() {
A a, b;
a + b; // operator+(a,b) chosen over int(a) + int(b)
}
— end example ]
7 If a built-in candidate is selected by overload resolution, the operands are converted to the types of the corresponding parameters of the selected operation function. Then the operator is treated as the corresponding
built-in operator and interpreted according to Clause 5.
8 The second operand of operator -> is ignored in selecting an operator-> function, and is not an argument
when the operator-> function is called. When operator-> returns, the operator -> is applied to the value
returned, with the original second operand.130
9 If the operator is the operator ,, the unary operator &, or the operator ->, and there are no viable functions,
then the operator is assumed to be the built-in operator and interpreted according to Clause 5.
10 [ Note: The lookup rules for operators in expressions are different than the lookup rules for operator function
names in a function call, as shown in the following example:
129) If the set of candidate functions is empty, overload resolution is unsuccessful.
130) If the value returned by the operator-> function has class type, this may result in selecting and calling another operator->
function. The process repeats until an operator-> function returns a value of non-class type.
§ 13.3.1.2 297

 c ISO/IEC N3242=11-0012
struct A { };
void operator + (A, A);
struct B {
void operator + (B);
void f ();
};
A a;
void B::f() {
operator+ (a,a); // error: global operator hidden by member
a + a; // OK: calls global operator+
} —
end note ]
13.3.1.3 Initialization by constructor [over.match.ctor]
1 When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or
a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate
functions are all the constructors of the class of the object being initialized. For copy-initialization, the
candidate functions are all the converting constructors (12.3.1) of that class. The argument list is the
expression-list or assignment-expression of the initializer.
13.3.1.4 Copy-initialization of class by user-defined conversion [over.match.copy]
1 Under the conditions specified in 8.5, as part of a copy-initialization of an object of class type, a user-defined
conversion can be invoked to convert an initializer expression to the type of the object being initialized.
Overload resolution is used to select the user-defined conversion to be invoked. Assuming that “cv1 T” is
the type of the object being initialized, with T a class type, the candidate functions are selected as follows:
— The converting constructors (12.3.1) of T are candidate functions.
— When the type of the initializer expression is a class type “cv S”, the non-explicit conversion functions of
S and its base classes are considered. When initializing a temporary to be bound to the first parameter
of a constructor that takes a reference to possibly cv-qualified T as its first argument, called with a
single argument in the context of direct-initialization, explicit conversion functions are also considered.
Those that are not hidden within S and yield a type whose cv-unqualified version is the same type as
T or is a derived class thereof are candidate functions. Conversion functions that return “reference to
X” return lvalues or xvalues, depending on the type of reference, of type X and are therefore considered
to yield X for this process of selecting candidate functions.
2 In both cases, the argument list has one argument, which is the initializer expression. [ Note: This argument
will be compared against the first parameter of the constructors and against the implicit object parameter
of the conversion functions. — end note ]
13.3.1.5 Initialization by conversion function [over.match.conv]
1 Under the conditions specified in 8.5, as part of an initialization of an object of nonclass type, a conversion
function can be invoked to convert an initializer expression of class type to the type of the object being
initialized. Overload resolution is used to select the conversion function to be invoked. Assuming that “cv1
T” is the type of the object being initialized, and “cv S” is the type of the initializer expression, with S a
class type, the candidate functions are selected as follows:
§ 13.3.1.5 298

 c ISO/IEC N3242=11-0012
— The conversion functions of S and its base classes are considered. Those non-explicit conversion
functions that are not hidden within S and yield type T or a type that can be converted to type T
via a standard conversion sequence (13.3.3.1.1) are candidate functions. For direct-initialization, those
explicit conversion functions that are not hidden within S and yield type T or a type that can be
converted to type T with a qualification conversion (4.4) are also candidate functions. Conversion
functions that return a cv-qualified type are considered to yield the cv-unqualified version of that type
for this process of selecting candidate functions. Conversion functions that return “reference to cv2
X” return lvalues or xvalues, depending on the type of reference, of type “cv2 X” and are therefore
considered to yield X for this process of selecting candidate functions.
2 The argument list has one argument, which is the initializer expression. [ Note: This argument will be
compared against the implicit object parameter of the conversion functions. — end note ]
13.3.1.6 Initialization by conversion function for direct reference binding [over.match.ref]
1 Under the conditions specified in 8.5.3, a reference can be bound directly to a glvalue or class prvalue that is
the result of applying a conversion function to an initializer expression. Overload resolution is used to select
the conversion function to be invoked. Assuming that “cv1 T” is the underlying type of the reference being
initialized, and “cv S” is the type of the initializer expression, with S a class type, the candidate functions
are selected as follows:
— The conversion functions of S and its base classes are considered, except that for copy-initialization,
only the non-explicit conversion functions are considered. Those that are not hidden within S and yield
type “lvalue reference to cv2 T2” (when 8.5.3 requires an lvalue result) or “cv2 T2” or “rvalue reference
to cv2 T2” (when 8.5.3 requires an rvalue result), where “cv1 T” is reference-compatible (8.5.3) with
“cv2 T2”, are candidate functions.
2 The argument list has one argument, which is the initializer expression. [ Note: This argument will be
compared against the implicit object parameter of the conversion functions. — end note ]
13.3.1.7 Initialization by list-initialization [over.match.list]
1 When objects of non-aggregate class type are list-initialized (8.5.4), overload resolution selects the constructor
as follows, where T is the cv-unqualified class type of the object being initialized:
— If T has an initializer-list constructor (8.5.4), the argument list consists of the initializer list as a single
argument; otherwise, the argument list consists of the elements of the initializer list.
— For direct-list-initialization, the candidate functions are all the constructors of the class T.
— For copy-list-initialization, the candidate functions are all the constructors of T. However, if an
explicit constructor is chosen, the initialization is ill-formed. [ Note: This restriction only applies if
this initialization is part of the final result of overload resolution — end note ]
13.3.2 Viable functions [over.match.viable]
1 From the set of candidate functions constructed for a given context (13.3.1), a set of viable functions is
chosen, from which the best function will be selected by comparing argument conversion sequences for the
best fit (13.3.3). The selection of viable functions considers relationships between arguments and function
parameters other than the ranking of conversion sequences.
2 First, to be a viable function, a candidate function shall have enough parameters to agree in number with
the arguments in the list.
— If there are m arguments in the list, all candidate functions having exactly m parameters are viable.
§ 13.3.2 299

 c ISO/IEC N3242=11-0012
— A candidate function having fewer than m parameters is viable only if it has an ellipsis in its parameter
list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding
parameter is considered to “match the ellipsis” (13.3.3.1.3) .
— A candidate function having more than m parameters is viable only if the (m+1)-st parameter has a
default argument (8.3.6).131 For the purposes of overload resolution, the parameter list is truncated
on the right, so that there are exactly m parameters.
3 Second, for F to be a viable function, there shall exist for each argument an implicit conversion sequence (13.3.3.1) that converts that argument to the corresponding parameter of F. If the parameter has
reference type, the implicit conversion sequence includes the operation of binding the reference, and the fact
that an lvalue reference to non-const cannot be bound to an rvalue and that an rvalue reference cannot be
bound to an lvalue can affect the viability of the function (see 13.3.3.1.4).
13.3.3 Best viable function [over.match.best]
1 Define ICSi(F) as follows:
— if F is a static member function, ICS1(F) is defined such that ICS1(F) is neither better nor worse than
ICS1(G) for any function G, and, symmetrically, ICS1(G) is neither better nor worse than ICS1(F)132;
otherwise,
— let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the
type of the i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and
13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence
or worse conversion sequence than another.
Given these definitions, a viable function F1 is defined to be a better function than another viable function
F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then
— for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,
— the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the
standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the
entity being initialized) is a better conversion sequence than the standard conversion sequence from
the return type of F2 to the destination type. [ Example:
struct A {
A();
operator int();
operator double();
} a;
int i = a; // a.operator int() followed by no conversion
// is better than a.operator double() followed by
// a conversion to int
float x = a; // ambiguous: both possibilities require conversions,
// and neither is better than the other
— end example ] or, if not that,
— F1 is a non-template function and F2 is a function template specialization, or, if not that,
131) According to 8.3.6, parameters following the (m+1)-st parameter must also have default arguments.
132) If a function is a static member function, this definition means that the first argument, the implied object argument, has
no effect in the determination of whether the function is better or worse than any other function.
§ 13.3.3 300

 c ISO/IEC N3242=11-0012
— F1 and F2 are function template specializations, and the function template for F1 is more specialized
than the template for F2 according to the partial ordering rules described in 14.5.6.2.
2 If there is exactly one viable function that is a better function than all other viable functions, then it is the
one selected by overload resolution; otherwise the call is ill-formed133.
[ Example:
void Fcn(const int*, short);
void Fcn(int*, int);
int i;
short s = 0;
void f() {
Fcn(&i, s); // is ambiguous because
// &i → int* is better than &i → const int*
// but s → short is also better than s → int
Fcn(&i, 1L); // calls Fcn(int*, int), because
// &i → int* is better than &i → const int*
// and 1L → short and 1L → int are indistinguishable
Fcn(&i,’c’); // calls Fcn(int*, int), because
// &i → int* is better than &i → const int*
// and c → int is better than c → short
}
— end example ]
3 If the best viable function resolves to a function for which multiple declarations were found, and if at least
two of these declarations — or the declarations they refer to in the case of using-declarations — specify a
default argument that made the function viable, the program is ill-formed. [ Example:
namespace A {
extern "C" void f(int = 5);
}
namespace B {
extern "C" void f(int = 5);
}
using A::f;
using B::f;
void use() {
f(3); // OK, default argument was not used for viability
f(); // Error: found default argument twice
} —
end example ]
133) The algorithm for selecting the best viable function is linear in the number of viable functions. Run a simple tournament
to find a function W that is not worse than any opponent it faced. Although another function F that W did not face might be
at least as good as W, F cannot be the best function because at some point in the tournament F encountered another function
G such that F was not better than G. Hence, W is either the best function or there is no best function. So, make a second pass
over the viable functions to verify that W is better than all other functions.
§ 13.3.3 301

 c ISO/IEC N3242=11-0012
13.3.3.1 Implicit conversion sequences [over.best.ics]
1 An implicit conversion sequence is a sequence of conversions used to convert an argument in a function call
to the type of the corresponding parameter of the function being called. The sequence of conversions is an
implicit conversion as defined in Clause 4, which means it is governed by the rules for initialization of an
object or reference by a single expression (8.5, 8.5.3).
2 Implicit conversion sequences are concerned only with the type, cv-qualification, and value category of the
argument and how these are converted to match the corresponding properties of the parameter. Other
properties, such as the lifetime, storage class, alignment, or accessibility of the argument and whether or not
the argument is a bit-field are ignored. So, although an implicit conversion sequence can be defined for a
given argument-parameter pair, the conversion from the argument to the parameter might still be ill-formed
in the final analysis.
3 A well-formed implicit conversion sequence is one of the following forms:
— a standard conversion sequence (13.3.3.1.1),
— a user-defined conversion sequence (13.3.3.1.2), or
— an ellipsis conversion sequence (13.3.3.1.3).
4 However, when considering the argument of a constructor or user-defined conversion function that is a
candidate by 13.3.1.3 when invoked for the copying/moving of the temporary in the second step of a class
copy-initialization, by 13.3.1.7 when passing the initializer list as a single argument or when the initializer
list has exactly one element and a conversion to some class X or reference to (possibly cv-qualified) X is
considered for the first parameter of a constructor of X, or by 13.3.1.4, 13.3.1.5, or 13.3.1.6 in all cases, only
standard conversion sequences and ellipsis conversion sequences are considered.
5 For the case where the parameter type is a reference, see 13.3.3.1.4.
6 When the parameter type is not a reference, the implicit conversion sequence models a copy-initialization of
the parameter from the argument expression. The implicit conversion sequence is the one required to convert
the argument expression to a prvalue of the type of the parameter. [ Note: When the parameter has a class
type, this is a conceptual conversion defined for the purposes of Clause 13; the actual initialization is defined
in terms of constructors and is not a conversion. — end note ] Any difference in top-level cv-qualification is
subsumed by the initialization itself and does not constitute a conversion. [ Example: a parameter of type A
can be initialized from an argument of type const A. The implicit conversion sequence for that case is the
identity sequence; it contains no “conversion” from const A to A. — end example ] When the parameter has
a class type and the argument expression has the same type, the implicit conversion sequence is an identity
conversion. When the parameter has a class type and the argument expression has a derived class type,
the implicit conversion sequence is a derived-to-base Conversion from the derived class to the base class.
[ Note: There is no such standard conversion; this derived-to-base Conversion exists only in the description of
implicit conversion sequences. — end note ] A derived-to-base Conversion has Conversion rank (13.3.3.1.1).
7 In all contexts, when converting to the implicit object parameter or when converting to the left operand of
an assignment operation only standard conversion sequences that create no temporary object for the result
are allowed.
8 If no conversions are required to match an argument to a parameter type, the implicit conversion sequence
is the standard conversion sequence consisting of the identity conversion (13.3.3.1.1).
9 If no sequence of conversions can be found to convert an argument to a parameter type or the conversion is
otherwise ill-formed, an implicit conversion sequence cannot be formed.
10 If several different sequences of conversions exist that each convert the argument to the parameter type, the
implicit conversion sequence associated with the parameter is defined to be the unique conversion sequence
§ 13.3.3.1 302

 c ISO/IEC N3242=11-0012
designated the ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences
as described in 13.3.3.2, the ambiguous conversion sequence is treated as a user-defined sequence that is
indistinguishable from any other user-defined conversion sequence134. If a function that uses the ambiguous
conversion sequence is selected as the best viable function, the call will be ill-formed because the conversion
of one of the arguments in the call is ambiguous.
11 The three forms of implicit conversion sequences mentioned above are defined in the following subclauses.
13.3.3.1.1 Standard conversion sequences [over.ics.scs]
1 Table 12 summarizes the conversions defined in Clause 4 and partitions them into four disjoint categories:
Lvalue Transformation, Qualification Adjustment, Promotion, and Conversion. [ Note: These categories are
orthogonal with respect to value category, cv-qualification, and data representation: the Lvalue Transformations do not change the cv-qualification or data representation of the type; the Qualification Adjustments
do not change the value category or data representation of the type; and the Promotions and Conversions
do not change the value category or cv-qualification of the type. — end note ]
2 [ Note: As described in Clause 4, a standard conversion sequence is either the Identity conversion by itself
(that is, no conversion) or consists of one to three conversions from the other four categories. At most one
conversion from each category is allowed in a single standard conversion sequence. If there are two or more
conversions in the sequence, the conversions are applied in the canonical order: Lvalue Transformation,
Promotion or Conversion, Qualification Adjustment. — end note ]
3 Each conversion in Table 12 also has an associated rank (Exact Match, Promotion, or Conversion). These are
used to rank standard conversion sequences (13.3.3.2). The rank of a conversion sequence is determined by
considering the rank of each conversion in the sequence and the rank of any reference binding (13.3.3.1.4). If
any of those has Conversion rank, the sequence has Conversion rank; otherwise, if any of those has Promotion
rank, the sequence has Promotion rank; otherwise, the sequence has Exact Match rank.
13.3.3.1.2 User-defined conversion sequences [over.ics.user]
1 A user-defined conversion sequence consists of an initial standard conversion sequence followed by a userdefined conversion (12.3) followed by a second standard conversion sequence. If the user-defined conversion
is specified by a constructor (12.3.1), the initial standard conversion sequence converts the source type to the
type required by the argument of the constructor. If the user-defined conversion is specified by a conversion
134) The ambiguous conversion sequence is ranked with user-defined conversion sequences because multiple conversion sequences
for an argument can exist only if they involve different user-defined conversions. The ambiguous conversion sequence is indistinguishable from any other user-defined conversion sequence because it represents at least two user-defined conversion sequences,
each with a different user-defined conversion, and any other user-defined conversion sequence must be indistinguishable from
at least one of them.
This rule prevents a function from becoming non-viable because of an ambiguous conversion sequence for one of its parameters.
Consider this example,
class B;
class A { A (B&);};
class B { operator A (); };
class C { C (B&); };
void f(A) { }
void f(C) { }
B b;
f(b); // ambiguous because b → C via constructor and
// b → A via constructor or conversion function.
If it were not for this rule, f(A) would be eliminated as a viable function for the call f(b) causing overload resolution to
select f(C) as the function to call even though it is not clearly the best choice. On the other hand, if an f(B) were to be
declared then f(b) would resolve to that f(B) because the exact match with f(B) is better than any of the sequences required
to match f(A).
§ 13.3.3.1.2 303

 c ISO/IEC N3242=11-0012
Table 12 — Conversions
Conversion Category Rank Subclause
No conversions required Identity
Lvalue-to-rvalue conversion 4.1
Array-to-pointer conversion Lvalue Transformation Exact Match 4.2
Function-to-pointer conversion 4.3
Qualification conversions Qualification Adjustment 4.4
Integral promotions 4.5
Floating point promotion Promotion Promotion 4.6
Integral conversions 4.7
Floating point conversions 4.8
Floating-integral conversions 4.9
Pointer conversions Conversion Conversion 4.10
Pointer to member conversions 4.11
Boolean conversions 4.12
function (12.3.2), the initial standard conversion sequence converts the source type to the implicit object
parameter of the conversion function.
2 The second standard conversion sequence converts the result of the user-defined conversion to the target type
for the sequence. Since an implicit conversion sequence is an initialization, the special rules for initialization
by user-defined conversion apply when selecting the best user-defined conversion for a user-defined conversion
sequence (see 13.3.3 and 13.3.3.1).
3 If the user-defined conversion is specified by a specialization of a conversion function template, the second
standard conversion sequence shall have exact match rank.
4 A conversion of an expression of class type to the same class type is given Exact Match rank, and a conversion
of an expression of class type to a base class of that type is given Conversion rank, in spite of the fact that
a copy/move constructor (i.e., a user-defined conversion function) is called for those cases.
13.3.3.1.3 Ellipsis conversion sequences [over.ics.ellipsis]
1 An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis
parameter specification of the function called (see 5.2.2).
13.3.3.1.4 Reference binding [over.ics.ref]
1 When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion
sequence is the identity conversion, unless the argument expression has a type that is a derived class of the
parameter type, in which case the implicit conversion sequence is a derived-to-base Conversion (13.3.3.1).
[ Example:
struct A {};
struct B : public A {} b;
int f(A&);
int f(B&);
int i = f(b); // calls f(B&), an exact match, rather than
// f(A&), a conversion
— end example ] If the parameter binds directly to the result of applying a conversion function to the
argument expression, the implicit conversion sequence is a user-defined conversion sequence (13.3.3.1.2),
§ 13.3.3.1.4 304

 c ISO/IEC N3242=11-0012
with the second standard conversion sequence either an identity conversion or, if the conversion function
returns an entity of a type that is a derived class of the parameter type, a derived-to-base Conversion.
2 When a parameter of reference type is not bound directly to an argument expression, the conversion sequence
is the one required to convert the argument expression to the underlying type of the reference according
to 13.3.3.1. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the
underlying type with the argument expression. Any difference in top-level cv-qualification is subsumed by
the initialization itself and does not constitute a conversion.
3 Except for an implicit object parameter, for which see 13.3.1, a standard conversion sequence cannot be
formed if it requires binding an lvalue reference other than a reference to a non-volatile const type to an
rvalue or binding an rvalue reference to an lvalue. [ Note: This means, for example, that a candidate function
cannot be a viable function if it has a non-const lvalue reference parameter (other than the implicit object
parameter) and the corresponding argument is a temporary or would require one to be created to initialize
the lvalue reference (see 8.5.3). — end note ]
4 Other restrictions on binding a reference to a particular argument that are not based on the types of
the reference and the argument do not affect the formation of a standard conversion sequence, however.
[ Example: a function with an “lvalue reference to int” parameter can be a viable candidate even if the
corresponding argument is an int bit-field. The formation of implicit conversion sequences treats the int
bit-field as an int lvalue and finds an exact match with the parameter. If the function is selected by overload
resolution, the call will nonetheless be ill-formed because of the prohibition on binding a non-const lvalue
reference to a bit-field (8.5.3). — end example ]
5 The binding of a reference to an expression that is reference-compatible with added qualification influences
the rank of a standard conversion; see 13.3.3.2 and 8.5.3.
13.3.3.1.5 List-initialization sequence [over.ics.list]
1 When an argument is an initializer list (8.5.4), it is not an expression and special rules apply for converting
it to a parameter type.
2 If the parameter type is std::initializer_list<X> and all the elements of the initializer list can be
implicitly converted to X, the implicit conversion sequence is the worst conversion necessary to convert an
element of the list to X. This conversion can be a user-defined conversion even in the context of a call to an
initializer-list constructor. [ Example:
void f(std::initializer_list<int>);
f( {1,2,3} ); // OK: f(initializer_list<int>) identity conversion
f( {’a’,’b’} ); // OK: f(initializer_list<int>) integral promotion
f( {1.0} ); // error: narrowing
struct A {
A(std::initializer_list<double>); // #1
A(std::initializer_list<complex<double>>); // #2
A(std::initializer_list<std::string>); // #3
};
A a{ 1.0,2.0 }; // OK, uses #1
void g(A);
g({ "foo", "bar" }); // OK, uses #3
— end example ]
3 Otherwise, if the parameter is a non-aggregate class X and overload resolution per 13.3.1.7 chooses a single
best constructor of X to perform the initialization of an object of type X from the argument initializer list, the
§ 13.3.3.1.5 305

 c ISO/IEC N3242=11-0012
implicit conversion sequence is a user-defined conversion sequence. If multiple constructors are viable but
none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence. Userdefined conversions are allowed for conversion of the initializer list elements to the constructor parameter
types except as noted in 13.3.3.1. [ Example:
struct A {
A(std::initializer_list<int>);
};
void f(A);
f( {’a’, ’b’} ); // OK: f(A(std::initializer_list<int>)) user-defined conversion
struct B {
B(int, double);
};
void g(B);
g( {’a’, ’b’} ); // OK: g(B(int,double)) user-defined conversion
g( {1.0, 1,0} ); // error: narrowing
void f(B);
f( {’a’, ’b’} ); // error: ambiguous f(A) or f(B)
struct C {
C(std::string);
};
void h(C);
h({"foo"}); // OK: h(C(std::string("foo")))
struct D {
C(A, C);
};
void i(D);
i({ {1,2}, {"bar"} }); // OK: i(D(A(std::initializer_list<int>{1,2}),C(std::string("bar"))))
— end example ]
4 Otherwise, if the parameter has an aggregate type which can be initialized from the initializer list according
to the rules for aggregate initialization (8.5.1), the implicit conversion sequence is a user-defined conversion
sequence. [ Example:
struct A {
int m1;
double m2;
};
void f(A);
f( {’a’, ’b’} ); // OK: f(A(int,double)) user-defined conversion
f( {1.0} ); // error: narrowing
— end example ]
5 Otherwise, if the parameter is a reference, see 13.3.3.1.4. [ Note: The rules in this section will apply for
initializing the underlying temporary for the reference. — end note ] [ Example:
struct A {
int m1;
double m2;
};
§ 13.3.3.1.5 306

 c ISO/IEC N3242=11-0012
void f(const A&);
f( {’a’, ’b’} ); // OK: f(A(int,double)) user-defined conversion
f( {1.0} ); // error: narrowing
void g(const double &);
g({1}); // same conversion as int to double
— end example ]
6 Otherwise, if the parameter type is not a class:
— if the initializer list has one element, the implicit conversion sequence is the one required to convert
the element to the parameter type; [ Example:
void f(int);
f( {’a’} ); // OK: same conversion as char to int
f( {1.0} ); // error: narrowing
— end example ]
— if the initializer list has no elements, the implicit conversion sequence is the identity conversion.
[ Example:
void f(int);
f( { } ); // OK: identity conversion
— end example ]
7 In all cases other than those enumerated above, no conversion is possible.
13.3.3.2 Ranking implicit conversion sequences [over.ics.rank]
1 13.3.3.2 defines a partial ordering of implicit conversion sequences based on the relationships better conversion
sequence and better conversion. If an implicit conversion sequence S1 is defined by these rules to be a better
conversion sequence than S2, then it is also the case that S2 is a worse conversion sequence than S1. If
conversion sequence S1 is neither better than nor worse than conversion sequence S2, S1 and S2 are said to
be indistinguishable conversion sequences.
2 When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)
— a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and
— a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).
3 Two implicit conversion sequences of the same form are indistinguishable conversion sequences unless one of
the following rules applies:
— Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence
S2 if
— S1 is a proper subsequence of S2 (comparing the conversion sequences in the canonical form
defined by 13.3.3.1.1, excluding any Lvalue Transformation; the identity conversion sequence is
considered to be a subsequence of any non-identity conversion sequence) or, if not that,
§ 13.3.3.2 307

 c ISO/IEC N3242=11-0012
— the rank of S1 is better than the rank of S2, or S1 and S2 have the same rank and are distinguishable by the rules in the paragraph below, or, if not that,
— S1 and S2 differ only in their qualification conversion and yield similar types T1 and T2 (4.4),
respectively, and the cv-qualification signature of type T1 is a proper subset of the cv-qualification
signature of type T2. [ Example:
int f(const int *);
int f(int *);
int i;
int j = f(&i); // calls f(int*)
— end example ] or, if not that,
— S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a
non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to
an rvalue and S2 binds an lvalue reference.
[ Example:
int i;
int f1();
int&& f2();
int g(const int&);
int g(const int&&);
int j = g(i); // calls g(const int&)
int k = g(f1()); // calls g(const int&&)
int l = g(f2()); // calls g(const int&&)
struct A {
A& operator<<(int);
void p() &;
void p() &&;
};
A& operator<<(A&&, char);
A() << 1; // calls A::operator<<(int)
A() << ’c’; // calls operator<<(A&&, char)
A a;
a << 1; // calls A::operator<<(int)
a << ’c’; // calls A::operator<<(int)
A().p(); // calls A::p()&&
a.p(); // calls A::p()&
— end example ] or, if not that,
— S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same
type except for top-level cv-qualifiers, and the type to which the reference initialized by S2 refers
is more cv-qualified than the type to which the reference initialized by S1 refers. [ Example:
int f(const int &);
int f(int &);
int g(const int &);
int g(int);
int i;
int j = f(i); // calls f(int &)
int k = g(i); // ambiguous
§ 13.3.3.2 308

 c ISO/IEC N3242=11-0012
struct X {
void f() const;
void f();
};
void g(const X& a, X b) {
a.f(); // calls X::f() const
b.f(); // calls X::f()
} —
end example ]
— User-defined conversion sequence U1 is a better conversion sequence than another user-defined conversion sequence U2 if they contain the same user-defined conversion function or constructor and if the
second standard conversion sequence of U1 is better than the second standard conversion sequence of
U2. [ Example:
struct A {
operator short();
} a;
int f(int);
int f(float);
int i = f(a); // calls f(int), because short → int is
// better than short → float.
— end example ]
— List-initialization sequence L1 is a better conversion sequence than list-initialization sequence L2 if L1
converts to std::initializer_list<X> for some X and L2 does not.
4 Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a
Promotion, which is a better conversion than a Conversion. Two conversion sequences with the same rank
are indistinguishable unless one of the following rules applies:
— A conversion that does not convert a pointer, a pointer to member, or std::nullptr_t to bool is
better than one that does.
— If class B is derived directly or indirectly from class A, conversion of B* to A* is better than conversion
of B* to void*, and conversion of A* to void* is better than conversion of B* to void*.
— If class B is derived directly or indirectly from class A and class C is derived directly or indirectly from
B,
— conversion of C* to B* is better than conversion of C* to A*, [ Example:
struct A {};
struct B : public A {};
struct C : public B {};
C *pc;
int f(A *);
int f(B *);
int i = f(pc); // calls f(B*)
— end example ]
— binding of an expression of type C to a reference of type B& is better than binding an expression
of type C to a reference of type A&,
§ 13.3.3.2 309

 c ISO/IEC N3242=11-0012
— conversion of A::* to B::* is better than conversion of A::* to C::*,
— conversion of C to B is better than conversion of C to A,
— conversion of B* to A* is better than conversion of C* to A*,
— binding of an expression of type B to a reference of type A& is better than binding an expression
of type C to a reference of type A&,
— conversion of B::* to C::* is better than conversion of A::* to C::*, and
— conversion of B to A is better than conversion of C to A.
[ Note: Compared conversion sequences will have different source types only in the context of comparing
the second standard conversion sequence of an initialization by user-defined conversion (see 13.3.3);
in all other contexts, the source types will be the same and the target types will be different. — end
note ]
13.4 Address of overloaded function [over.over]
1 A use of an overloaded function name without arguments is resolved in certain contexts to a function, a
pointer to function or a pointer to member function for a specific function from the overload set. A function
template name is considered to name a set of overloaded functions in such contexts. The function selected
is the one whose type is identical to the function type of the target type required in the context. [ Note:
That is, the class of which the function is a member is ignored when matching a pointer-to-member-function
type. — end note ] The target can be
— an object or reference being initialized (8.5, 8.5.3),
— the left side of an assignment (5.17),
— a parameter of a function (5.2.2),
— a parameter of a user-defined operator (13.5),
— the return value of a function, operator function, or conversion (6.6.3),
— an explicit type conversion (5.2.3, 5.2.9, 5.4), or
— a non-type template-parameter (14.3.2).
The overloaded function name can be preceded by the & operator. An overloaded function name shall not
be used without arguments in contexts other than those listed. [ Note: Any redundant set of parentheses
surrounding the overloaded function name is ignored (5.1). — end note ]
2 If the name is a function template, template argument deduction is done (14.8.2.2), and if the argument
deduction succeeds, the resulting template argument list is used to generate a single function template
specialization, which is added to the set of overloaded functions considered. [ Note: As described in 14.8.1,
if deduction fails and the function template name is followed by an explicit template argument list, the
template-id is then examined to see whether it identifies a single function template specialization. If it does,
the template-id is considered to be an lvalue for that function template specialization. The target type is
not used in that determination. — end note ]
3 Non-member functions and static member functions match targets of type “pointer-to-function” or “referenceto-function.” Nonstatic member functions match targets of type “pointer-to-member-function”. If a nonstatic member function is selected, the reference to the overloaded function name is required to have the
form of a pointer to member as described in 5.3.1.
§ 13.4 310

 c ISO/IEC N3242=11-0012
4 If more than one function is selected, any function template specializations in the set are eliminated if the
set also contains a non-template function, and any given function template specialization F1 is eliminated if
the set contains a second function template specialization whose function template is more specialized than
the function template of F1 according to the partial ordering rules of 14.5.6.2. After such eliminations, if
any, there shall remain exactly one selected function.
5 [ Example:
int f(double);
int f(int);
int (*pfd)(double) = &f; // selects f(double)
int (*pfi)(int) = &f; // selects f(int)
int (*pfe)(...) = &f; // error: type mismatch
int (&rfi)(int) = f; // selects f(int)
int (&rfd)(double) = f; // selects f(double)
void g() {
(int (*)(int))&f; // cast expression as selector
}
The initialization of pfe is ill-formed because no f() with type int(...) has been declared, and not because
of any ambiguity. For another example,
struct X {
int f(int);
static int f(long);
};
int (X::*p1)(int) = &X::f; // OK
int (*p2)(int) = &X::f; // error: mismatch
int (*p3)(long) = &X::f; // OK
int (X::*p4)(long) = &X::f; // error: mismatch
int (X::*p5)(int) = &(X::f); // error: wrong syntax for
// pointer to member
int (*p6)(long) = &(X::f); // OK
— end example ]
6 [ Note: If f() and g() are both overloaded functions, the cross product of possibilities must be considered
to resolve f(&g), or the equivalent expression f(g). — end note ]
7 [ Note: There are no standard conversions (Clause 4) of one pointer-to-function type into another. In
particular, even if B is a public base of D, we have
D* f();
B* (*p1)() = &f; // error
void g(D*);
void (*p2)(B*) = &g; // error
— end note ]
13.5 Overloaded operators [over.oper]
1 A function declaration having one of the following operator-function-ids as its name declares an operator
function. A function template declaration having one of the following operator-function-ids as its name
§ 13.5 311

 c ISO/IEC N3242=11-0012
declares an operator function template. A specialization of an operator function template is also an operator
function. An operator function is said to implement the operator named in its operator-function-id.
operator-function-id:
operator operator
operator: one of
new delete new[] delete[]
+ - * / % ˆ & | ∼
! = < > += -= *= /= %=
ˆ= &= |= << >> >>= <<= == !=
<= >= && || ++ -- , ->* ->
( ) [ ]
[ Note: The last two operators are function call (5.2.2) and subscripting (5.2.1). The operators new[],
delete[], (), and [] are formed from more than one token. — end note ]
2 Both the unary and binary forms of
+ - * &
can be overloaded.
3 The following operators cannot be overloaded:
. .* :: ?:
nor can the preprocessing symbols # and ## (Clause 16).
4 Operator functions are usually not called directly; instead they are invoked to evaluate the operators they
implement (13.5.1 – 13.5.7). They can be explicitly called, however, using the operator-function-id as the
name of the function in the function call syntax (5.2.2). [ Example:
complex z = a.operator+(b); // complex z = a+b;
void* p = operator new(sizeof(int)*n);
— end example ]
5 The allocation and deallocation functions, operator new, operator new[], operator delete and operator
delete[], are described completely in 3.7.4. The attributes and restrictions found in the rest of this
subclause do not apply to them unless explicitly stated in 3.7.4.
6 An operator function shall either be a non-static member function or be a non-member function and have
at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an
enumeration. It is not possible to change the precedence, grouping, or number of operands of operators.
The meaning of the operators =, (unary) &, and , (comma), predefined for each type, can be changed for
specific class and enumeration types by defining operator functions that implement these operators. Operator
functions are inherited in the same manner as other base class functions.
7 The identities among certain predefined operators applied to basic types (for example, ++a ≡ a+=1) need
not hold for operator functions. Some predefined operators, such as +=, require an operand to be an lvalue
when applied to basic types; this is not required by operator functions.
8 An operator function cannot have default arguments (8.3.6), except where explicitly stated below. Operator
functions cannot have more or fewer parameters than the number required for the corresponding operator,
as described in the rest of this subclause.
§ 13.5 312

 c ISO/IEC N3242=11-0012
9 Operators not mentioned explicitly in subclauses 13.5.3 through 13.5.7 act as ordinary unary and binary
operators obeying the rules of 13.5.1 or 13.5.2.
13.5.1 Unary operators [over.unary]
1 A prefix unary operator shall be implemented by a non-static member function (9.3) with no parameters or
a non-member function with one parameter. Thus, for any prefix unary operator @, @x can be interpreted
as either x.operator@() or operator@(x). If both forms of the operator function have been declared, the
rules in 13.3.1.2 determine which, if any, interpretation is used. See 13.5.7 for an explanation of the postfix
unary operators ++ and --.
2 The unary and binary forms of the same operator are considered to have the same name. [ Note: Consequently, a unary operator can hide a binary operator from an enclosing scope, and vice versa. — end
note ]
13.5.2 Binary operators [over.binary]
1 A binary operator shall be implemented either by a non-static member function (9.3) with one parameter
or by a non-member function with two parameters. Thus, for any binary operator @, x@y can be interpreted
as either x.operator@(y) or operator@(x,y). If both forms of the operator function have been declared,
the rules in 13.3.1.2 determine which, if any, interpretation is used.
13.5.3 Assignment [over.ass]
1 An assignment operator shall be implemented by a non-static member function with exactly one parameter.
Because a copy assignment operator operator= is implicitly declared for a class if not declared by the
user (12.8), a base class assignment operator is always hidden by the copy assignment operator of the
derived class.
2 Any assignment operator, even the copy and move assignment operators, can be virtual. [ Note: For a derived
class D with a base class B for which a virtual copy/move assignment has been declared, the copy/move
assignment operator in D does not override B’s virtual copy/move assignment operator. [ Example:
struct B {
virtual int operator= (int);
virtual B& operator= (const B&);
};
struct D : B {
virtual int operator= (int);
virtual D& operator= (const B&);
};
D dobj1;
D dobj2;
B* bptr = &dobj1;
void f() {
bptr->operator=(99); // calls D::operator=(int)
*bptr = 99; // ditto
bptr->operator=(dobj2); // calls D::operator=(const B&)
*bptr = dobj2; // ditto
dobj1 = dobj2; // calls implicitly-declared
// D::operator=(const D&)
}
§ 13.5.3 313

 c ISO/IEC N3242=11-0012
— end example ] — end note ]
13.5.4 Function call [over.call]
1 operator() shall be a non-static member function with an arbitrary number of parameters. It can have
default arguments. It implements the function call syntax
postfix-expression ( expression-listopt)
where the postfix-expression evaluates to a class object and the possibly empty expression-list matches the
parameter list of an operator() member function of the class. Thus, a call x(arg1,...) is interpreted as
x.operator()(arg1, ...) for a class object x of type T if T::operator()(T1, T2, T3) exists and if the
operator is selected as the best match function by the overload resolution mechanism (13.3.3).
13.5.5 Subscripting [over.sub]
1 operator[] shall be a non-static member function with exactly one parameter. It implements the subscripting syntax
postfix-expression [ expression ]
Thus, a subscripting expression x[y] is interpreted as x.operator[](y) for a class object x of type T
if T::operator[](T1) exists and if the operator is selected as the best match function by the overload
resolution mechanism (13.3.3).
13.5.6 Class member access [over.ref]
1 operator-> shall be a non-static member function taking no parameters. It implements the class member
access syntax that uses ->.
postfix-expression -> templateopt id-expression
postfix-expression -> pseudo-destructor-name
An expression x->m is interpreted as (x.operator->())->m for a class object x of type T if T::operator->()
exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3).
13.5.7 Increment and decrement [over.inc]
1 The user-defined function called operator++ implements the prefix and postfix ++ operator. If this function is
a member function with no parameters, or a non-member function with one parameter of class or enumeration
type, it defines the prefix increment operator ++ for objects of that type. If the function is a member function
with one parameter (which shall be of type int) or a non-member function with two parameters (the second
of which shall be of type int), it defines the postfix increment operator ++ for objects of that type. When
the postfix increment is called as a result of using the ++ operator, the int argument will have value zero.135
[ Example:
struct X {
X& operator++(); // prefix ++a
X operator++(int); // postfix a++
};
struct Y { };
Y& operator++(Y&); // prefix ++b
Y operator++(Y&, int); // postfix b++
135) Calling operator++ explicitly, as in expressions like a.operator++(2), has no special properties: The argument to
operator++ is 2.
§ 13.5.7 314

 c ISO/IEC N3242=11-0012
void f(X a, Y b) {
++a; // a.operator++();
a++; // a.operator++(0);
++b; // operator++(b);
b++; // operator++(b, 0);
a.operator++(); // explicit call: like ++a;
a.operator++(0); // explicit call: like a++;
operator++(b); // explicit call: like ++b;
operator++(b, 0); // explicit call: like b++;
} —
end example ]
2 The prefix and postfix decrement operators -- are handled analogously.
13.5.8 User-defined literals [over.literal]
literal-operator-id:
operator "" identifier
1 The identifier in a literal-operator-id is called a literal suffix identifier.
2 A declaration whose declarator-id is a literal-operator-id shall be a declaration of a namespace-scope function
or function template (it could be a friend function (11.3)), an explicit instantiation or specialization of a
function template, or a using-declaration (7.3.3). A function declared with a literal-operator-id is a literal
operator. A function template declared with a literal-operator-id is a literal operator template.
3 The declaration of a literal operator shall have a parameter-declaration-clause equivalent to one of the
following:
const char*
unsigned long long int
long double
char
wchar_t
char16_t
char32_t
const char*, std::size_t
const wchar_t*, std::size_t
const char16_t*, std::size_t
const char32_t*, std::size_t
4 A raw literal operator is a literal operator with a single parameter whose type is const char*.
5 The declaration of a literal operator template shall have an empty parameter-declaration-clause and its
template-parameter-list shall have a single template-parameter that is a non-type template parameter pack (14.5.3)
with element type char.
6 Literal operators and literal operator templates shall not have C language linkage.
7 [ Note: Literal operators and literal operator templates are usually invoked implicitly through user-defined
literals (2.14.8). However, except for the constraints described above, they are ordinary namespace-scope
functions and function templates. In particular, they are looked up like ordinary functions and function templates and they follow the same overload resolution rules. Also, they can be declared inline or constexpr,
they may have internal or external linkage, they can be called explicitly, their addresses can be taken, etc.
— end note ]
§ 13.5.8 315

 c ISO/IEC N3242=11-0012
8 [ Example:
void operator "" _km(long double); // OK
string operator "" _i18n(const char*, std::size_t); // OK
template <char...> int operator "" \u03C0(); // OK: UCN for lowercase pi
float operator ""E(const char*); // error: ""E (with no intervening space)
// is a single token
float operator " " B(const char*); // error: non-adjacent quotes
string operator "" 5X(const char*, std::size_t); // error: invalid literal suffix identifier
double operator "" _miles(double); // error: invalid parameter-declaration-clause
template <char...> int operator "" j(const char*); // error: invalid parameter-declaration-clause
— end example ]
13.6 Built-in operators [over.built]
1 The candidate operator functions that represent the built-in operators defined in Clause 5 are specified in
this subclause. These candidate functions participate in the operator overload resolution process as described
in 13.3.1.2 and are used for no other purpose. [ Note: Because built-in operators take only operands with
non-class type, and operator overload resolution occurs only when an operand expression originally has class
or enumeration type, operator overload resolution can resolve to a built-in operator only when an operand
has a class type that has a user-defined conversion to a non-class type appropriate for the operator, or when
an operand has an enumeration type that can be converted to a type appropriate for the operator. Also note
that some of the candidate operator functions given in this subclause are more permissive than the built-in
operators themselves. As described in 13.3.1.2, after a built-in operator is selected by overload resolution
the expression is subject to the requirements for the built-in operator given in Clause 5, and therefore to
any additional semantic constraints given there. If there is a user-written candidate with the same name
and parameter types as a built-in candidate operator function, the built-in operator function is hidden and
is not included in the set of candidate functions. — end note ]
2 In this subclause, the term promoted integral type is used to refer to those integral types which are preserved
by integral promotion (including e.g. int and long but excluding e.g. char). Similarly, the term promoted
arithmetic type refers to floating types plus promoted integral types. [ Note: In all cases where a promoted
integral type or promoted arithmetic type is required, an operand of enumeration type will be acceptable
by way of the integral promotions. — end note ]
3 For every pair (T, VQ), where T is an arithmetic type, and VQ is either volatile or empty, there exist
candidate operator functions of the form
VQ T & operator++(VQ T &);
T operator++(VQ T &, int);
4 For every pair (T, VQ), where T is an arithmetic type other than bool, and VQ is either volatile or empty,
there exist candidate operator functions of the form
VQ T & operator--(VQ T &);
T operator--(VQ T &, int);
5 For every pair (T, VQ), where T is a cv-qualified or cv-unqualified object type, and VQ is either volatile
or empty, there exist candidate operator functions of the form
T *VQ& operator++(T *VQ&);
T *VQ& operator--(T *VQ&);
T * operator++(T *VQ&, int);
T * operator--(T *VQ&, int);
§ 13.6 316

 c ISO/IEC N3242=11-0012
6 For every cv-qualified or cv-unqualified object type T, there exist candidate operator functions of the form
T & operator*(T *);
7 For every function type T that does not have cv-qualifiers or a ref-qualifier, there exist candidate operator
functions of the form
T & operator*(T *);
8 For every type T there exist candidate operator functions of the form
T * operator+(T *);
9 For every promoted arithmetic type T, there exist candidate operator functions of the form
T operator+(T );
T operator-(T );
10 For every promoted integral type T, there exist candidate operator functions of the form
T operator∼(T );
11 For every quintuple (C1, C2, T, CV1, CV2), where C2 is a class type, C1 is the same type as C2 or is a
derived class of C2, T is an object type or a function type, and CV1 and CV2 are cv-qualifier-seqs, there
exist candidate operator functions of the form
CV12 T & operator->*(CV1 C1*, CV2 T C2::*);
where CV12 is the union of CV1 and CV2.
12 For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form
LR operator*(L, R);
LR operator/(L, R);
LR operator+(L, R);
LR operator-(L, R);
bool operator<(L, R);
bool operator>(L, R);
bool operator<=(L, R);
bool operator>=(L, R);
bool operator==(L, R);
bool operator!=(L, R);
where LR is the result of the usual arithmetic conversions between types L and R.
13 For every cv-qualified or cv-unqualified object type T there exist candidate operator functions of the form
T * operator+(T *, std::ptrdiff_t);
T & operator[](T *, std::ptrdiff_t);
T * operator-(T *, std::ptrdiff_t);
T * operator+(std::ptrdiff_t, T *);
T & operator[](std::ptrdiff_t, T *);
14 For every T, where T is a pointer to object type, there exist candidate operator functions of the form
std::ptrdiff_t operator-(T , T );
15 For every T , where T is an enumeration type, a pointer type, or std::nullptr_t, there exist candidate
operator functions of the form
§ 13.6 317

 c ISO/IEC N3242=11-0012
bool operator<(T , T );
bool operator>(T , T );
bool operator<=(T , T );
bool operator>=(T , T );
bool operator==(T , T );
bool operator!=(T , T );
16 For every pointer to member type T there exist candidate operator functions of the form
bool operator==(T , T );
bool operator!=(T , T );
17 For every pair of promoted integral types L and R, there exist candidate operator functions of the form
LR operator%(L , R );
LR operator&(L , R );
LR operator^(L , R );
LR operator|(L , R );
L operator<<(L , R );
L operator>>(L , R );
where LR is the result of the usual arithmetic conversions between types L and R.
18 For every triple (L, VQ, R), where L is an arithmetic type, VQ is either volatile or empty, and R is a
promoted arithmetic type, there exist candidate operator functions of the form
VQ L & operator=(VQ L &, R );
VQ L & operator*=(VQ L &, R );
VQ L & operator/=(VQ L &, R );
VQ L & operator+=(VQ L &, R );
VQ L & operator-=(VQ L &, R );
19 For every pair (T , VQ), where T is any type and VQ is either volatile or empty, there exist candidate
operator functions of the form
T *VQ & operator=(T *VQ &, T *);
20 For every pair (T , VQ), where T is an enumeration or pointer to member type and VQ is either volatile
or empty, there exist candidate operator functions of the form
VQ T & operator=(VQ T &, T );
21 For every pair (T , VQ), where T is a cv-qualified or cv-unqualified object type and VQ is either volatile
or empty, there exist candidate operator functions of the form
T *VQ & operator+=(T *VQ &, std::ptrdiff_t);
T *VQ & operator-=(T *VQ &, std::ptrdiff_t);
22 For every triple (L, VQ, R), where L is an integral type, VQ is either volatile or empty, and R is a
promoted integral type, there exist candidate operator functions of the form
VQ L & operator%=(VQ L &, R );
VQ L & operator<<=(VQ L &, R );
VQ L & operator>>=(VQ L &, R );
VQ L & operator&=(VQ L &, R );
VQ L & operator^=(VQ L &, R );
VQ L & operator|=(VQ L &, R );
§ 13.6 318

 c ISO/IEC N3242=11-0012
23 There also exist candidate operator functions of the form
bool operator!(bool);
bool operator&&(bool, bool);
bool operator||(bool, bool);
24 For every pair of promoted arithmetic types L and R, there exist candidate operator functions of the form
LR operator?:(bool, L , R );
where LR is the result of the usual arithmetic conversions between types L and R. [ Note: As with all these
descriptions of candidate functions, this declaration serves only to describe the built-in operator for purposes
of overload resolution. The operator “?:” cannot be overloaded. — end note ]
25 For every type T , where T is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate
operator functions of the form
T operator?:(bool, T , T );
§ 13.6 319

 c ISO/IEC N3242=11-0012
14 Templates [temp]
1 A template defines a family of classes or functions or an alias for a family of types.
template-declaration:
template < template-parameter-list > declaration
template-parameter-list:
template-parameter
template-parameter-list , template-parameter
[ Note: The > token following the template-parameter-list of a template-declaration may be the product of
replacing a >> token by two consecutive > tokens (14.2). — end note ]
The declaration in a template-declaration shall
— declare or define a function or a class, or
— define a member function, a member class or a static data member of a class template or of a class
nested within a class template, or
— define a member template of a class or class template, or
— be an alias-declaration.
A template-declaration is a declaration. A template-declaration is also a definition if its declaration defines
a function, a class, or a static data member.
2 A template-declaration can appear only as a namespace scope or class scope declaration. In a function
template declaration, the last component of the declarator-id shall not be a template-id. [ Note: That last
component may be an identifier, an operator-function-id, a conversion-function-id, or a literal-operator-id.
In a class template declaration, if the class name is a simple-template-id, the declaration declares a class
template partial specialization (14.5.5). — end note ]
3 In a template-declaration, explicit specialization, or explicit instantiation the init-declarator-list in the declaration shall contain at most one declarator. When such a declaration is used to declare a class template,
no declarator is permitted.
4 A template name has linkage (3.5). A non-member function template can have internal linkage; any other
template name shall have external linkage. Specializations (explicit or implicit) of a template that has
internal linkage are distinct from all specializations in other translation units. A template, a template explicit specialization (14.7.3), and a class template partial specialization shall not have C linkage. Use of
a linkage specification other than C or C++ with any of these constructs is conditionally-supported, with
implementation-defined semantics. Template definitions shall obey the one definition rule (3.2). [Note: Default arguments for function templates and for member functions of class templates are considered definitions
for the purpose of template instantiation (14.5) and must also obey the one definition rule. — end note ]
5 A class template shall not have the same name as any other template, class, function, variable, enumeration,
enumerator, namespace, or type in the same scope (3.3), except as specified in (14.5.5). Except that a
function template can be overloaded either by (non-template) functions with the same name or by other
function templates with the same name (14.8.3), a template name declared in namespace scope or in class
scope shall be unique in that scope.
320

 c ISO/IEC N3242=11-0012
14.1 Template parameters [temp.param]
1 The syntax for template-parameters is:
template-parameter:
type-parameter
parameter-declaration
type-parameter:
class ...
opt identifieropt
class identifieropt= type-id
typename ...opt identifieropt
typename identifieropt= type-id
template < template-parameter-list > class ...opt identifieropt
template < template-parameter-list > class identifieropt= id-expression
[ Note: The > token following the template-parameter-list of a type-parameter may be the product of replacing
a >> token by two consecutive > tokens (14.2). — end note ]
2 There is no semantic difference between class and typename in a template-parameter. typename followed
by an unqualified-id names a template type parameter. typename followed by a qualified-id denotes the
type in a non-type 136 parameter-declaration. A storage class shall not be specified in a template-parameter
declaration. [ Note: A template parameter may be a class template. For example,
template<class T> class myarray { /∗ ... ∗/ };
template<class K, class V, template<class T> class C = myarray>
class Map {
C<K> key;
C<V> value;
};
— end note ]
3 A type-parameter whose identifier does not follow an ellipsis defines its identifier to be a typedef-name (if
declared with class or typename) or template-name (if declared with template) in the scope of the template
declaration. [ Note: Because of the name lookup rules, a template-parameter that could be interpreted as
either a non-type template-parameter or a type-parameter (because its identifier is the name of an already
existing class) is taken as a type-parameter. For example,
class T { /∗ ... ∗/ };
int i;
template<class T, T i> void f(T t) {
T t1 = i; // template-parameters T and i
::T t2 = ::i; // global namespace members T and i
}
Here, the template f has a type-parameter called T, rather than an unnamed non-type template-parameter
of class T. — end note ]
4 A non-type template-parameter shall have one of the following (optionally cv-qualified) types:
— integral or enumeration type,
— pointer to object or pointer to function,
136) Since template template-parameters and template template-arguments are treated as types for descriptive purposes, the
terms non-type parameter and non-type argument are used to refer to non-type, non-template parameters and arguments.
§ 14.1 321

 c ISO/IEC N3242=11-0012
— lvalue reference to object or lvalue reference to function,
— pointer to member,
— std::nullptr_t.
5 [ Note: Other types are disallowed either explicitly below or implicitly by the rules governing the form of
template-arguments (14.3). — end note ] The top-level cv-qualifiers on the template-parameter are ignored
when determining its type.
6 A non-type non-reference template-parameter is a prvalue. It shall not be assigned to or in any other way
have its value changed. A non-type non-reference template-parameter cannot have its address taken. When
a non-type non-reference template-parameter is used as an initializer for a reference, a temporary is always
used. [ Example:
template<const X& x, int i> void f() {
i++; // error: change of template-parameter value
&x; // OK
&i; // error: address of non-reference template-parameter
int& ri = i; // error: non-const reference bound to temporary
const int& cri = i; // OK: const reference bound to temporary
} —
end example ]
7 A non-type template-parameter shall not be declared to have floating point, class, or void type. [ Example:
template<double d> class X; // error
template<double* pd> class Y; // OK
template<double& rd> class Z; // OK
— end example ]
8 A non-type template-parameter of type “array of T” or “function returning T” is adjusted to be of type
“pointer to T” or “pointer to function returning T”, respectively. [ Example:
template<int *a> struct R { /∗ ... ∗/ };
template<int b[5]> struct S { /∗ ... ∗/ };
int p;
R<&p> w; // OK
S<&p> x; // OK due to parameter adjustment
int v[5];
R<v> y; // OK due to implicit argument conversion
S<v> z; // OK due to both adjustment and conversion
— end example ]
9 A default template-argument is a template-argument (14.3) specified after = in a template-parameter. A default template-argument may be specified for any kind of template-parameter (type, non-type, template) that
is not a template parameter pack (14.5.3). A default template-argument may be specified in a template declaration. A default template-argument shall not be specified in the template-parameter-lists of the definition
of a member of a class template that appears outside of the member’s class. A default template-argument
shall not be specified in a friend class template declaration. If a friend function template declaration specifies
a default template-argument, that declaration shall be a definition and shall be the only declaration of the
function template in the translation unit.
§ 14.1 322

 c ISO/IEC N3242=11-0012
10 The set of default template-arguments available for use with a template declaration or definition is obtained
by merging the default arguments from the definition (if in scope) and all declarations in scope in the same
way default function arguments are (8.3.6). [ Example:
template<class T1, class T2 = int> class A;
template<class T1 = int, class T2> class A;
is equivalent to
template<class T1 = int, class T2 = int> class A;
— end example ]
11 If a template-parameter of a class template has a default template-argument, each subsequent templateparameter shall either have a default template-argument supplied or be a template parameter pack. If a
template-parameter of a primary class template is a template parameter pack, it shall be the last templateparameter. [ Note: These are not requirements for function templates or class template partial specializations
because template arguments can be deduced (14.8.2). [ Example:
template<class T1 = int, class T2> class B; // error
— end example ] — end note ]
12 A template-parameter shall not be given default arguments by two different declarations in the same scope.
[ Example:
template<class T = int> class X;
template<class T = int> class X { /∗... ∗/ }; // error
— end example ]
13 When parsing a default template-argument for a non-type template-parameter, the first non-nested > is taken
as the end of the template-parameter-list rather than a greater-than operator. [ Example:
template<int i = 3 > 4 > // syntax error
class X { /∗ ... ∗/ };
template<int i = (3 > 4) > // OK
class Y { /∗ ... ∗/ };
— end example ]
14 A template-parameter of a template template-parameter is permitted to have a default template-argument.
When such default arguments are specified, they apply to the template template-parameter in the scope of
the template template-parameter. [ Example:
template <class T = float> struct B {};
template <template <class TT = float> class T> struct A {
inline void f();
inline void g();
};
template <template <class TT> class T> void A<T>::f() {
T<> t; // error - TT has no default template argument
}
template <template <class TT = char> class T> void A<T>::g() {
T<> t; // OK - T<char>
}
§ 14.1 323

 c ISO/IEC N3242=11-0012
— end example ]
15 If a template-parameter is a type-parameter with an ellipsis prior to its optional identifier or is a parameterdeclaration that declares a parameter pack (8.3.5), then the template-parameter is a template parameter
pack (14.5.3). [ Example:
template <class... Types> class Tuple; // Types is a template type parameter pack
template <class T, int... Dims> struct multi_array; // Dims is a non-type template parameter pack
— end example ]
14.2 Names of template specializations [temp.names]
1 A template specialization (14.7) can be referred to by a template-id:
simple-template-id:
template-name < template-argument-listopt>
template-id:
simple-template-id
operator-function-id < template-argument-listopt>
literal-operator-id < template-argument-listopt>
template-name:
identifier
template-argument-list:
template-argument ...opt
template-argument-list , template-argument ...opt
template-argument:
constant-expression
type-id
id-expression
[ Note: The name lookup rules (3.4) are used to associate the use of a name with a template declaration;
that is, to identify a name as a template-name. — end note ]
2 For a template-name to be explicitly qualified by the template arguments, the name must be known to refer
to a template.
3 After name lookup (3.4) finds that a name is a template-name or that an operator-function-id or a literaloperator-id refers to a set of overloaded functions any member of which is a function template if this is
followed by a <, the < is always taken as the delimiter of a template-argument-list and never as the less-than
operator. When parsing a template-argument-list, the first non-nested >137 is taken as the ending delimiter
rather than a greater-than operator. Similarly, the first non-nested >> is treated as two consecutive but
distinct > tokens, the first of which is taken as the end of the template-argument-list and completes the
template-id. [ Note: The second > token produced by this replacement rule may terminate an enclosing
template-id construct or it may be part of a different construct (e.g. a cast). — end note ] [ Example:
template<int i> class X { /* ... */ };
X< 1>2 > x1; // syntax error
X<(1>2)> x2; // OK
template<class T> class Y { /* ... */ };
137) A > that encloses the type-id of a dynamic_cast, static_cast, reinterpret_cast or const_cast, or which encloses the
template-arguments of a subsequent template-id, is considered nested for the purpose of this description.
§ 14.2 324

 c ISO/IEC N3242=11-0012
Y<X<1>> x3; // OK, same as Y<X<1> > x3;
Y<X<6>>1>> x4; // syntax error
Y<X<(6>>1)>> x5; // OK
— end example ]
4 When the name of a member template specialization appears after . or -> in a postfix-expression or after a
nested-name-specifier in a qualified-id, and the object or pointer expression of the postfix-expression or the
nested-name-specifier in the qualified-id depends on a template parameter (14.6.2) but does not refer to a
member of the current instantiation (14.6.2.1), the member template name must be prefixed by the keyword
template. Otherwise the name is assumed to name a non-template. [ Example:
struct X {
template<std::size_t> X* alloc();
template<std::size_t> static X* adjust();
};
template<class T> void f(T* p) {
T* p1 = p->alloc<200>(); // ill-formed: < means less than
T* p2 = p->template alloc<200>(); // OK: < starts template argument list
T::adjust<100>(); // ill-formed: < means less than
T::template adjust<100>(); // OK: < starts template argument list
}
— end example ]
5 A name prefixed by the keyword template shall be a template-id or the name shall refer to a class template.
[ Note: The keyword template may not be applied to non-template members of class templates. — end
note ] [ Note: As is the case with the typename prefix, the template prefix is allowed in cases where it is
not strictly necessary; i.e., when the nested-name-specifier or the expression on the left of the -> or . is not
dependent on a template-parameter, or the use does not appear in the scope of a template. — end note ]
[ Example:
template <class T> struct A {
void f(int);
template <class U> void f(U);
};
template <class T> void f(T t) {
A<T> a;
a.template f<>(t); // OK: calls template
a.template f(t); // error: not a template-id
}
template <class T> struct B {
template <class T2> struct C { };
};
// OK: T::template C names a class template:
template <class T, template <class X> class TT = T::template C> struct D { };
D<b<int> > db;
— end example ]
6 A simple-template-id that names a class template specialization is a class-name (Clause 9).
§ 14.2 325

 c ISO/IEC N3242=11-0012
7 A template-id that names [FI 11] a template aliasan alias template specialization is a type-name.
14.3 Template arguments [temp.arg]
1 There are three forms of template-argument, corresponding to the three forms of template-parameter: type,
non-type and template. The type and form of each template-argument specified in a template-id shall
match the type and form specified for the corresponding parameter declared by the template in its templateparameter-list. When the parameter declared by the template is a template parameter pack (14.5.3), it will
correspond to zero or more template-arguments. [ Example:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
Array<int> v1(20);
typedef std::complex<double> dcomplex; // std::complex is a standard
// library template
Array<dcomplex> v2(30);
Array<dcomplex> v3(40);
void bar() {
v1[3] = 7;
v2[3] = v3.elem(4) = dcomplex(7,8);
}
— end example ]
2 In a template-argument, an ambiguity between a type-id and an expression is resolved to a type-id, regardless
of the form of the corresponding template-parameter.138 [ Example:
template<class T> void f();
template<int I> void f();
void g() {
f<int()>(); // int() is a type-id: call the first f()
} —
end example ]
3 The name of a template-argument shall be accessible at the point where it is used as a template-argument.
[ Note: If the name of the template-argument is accessible at the point where it is used as a templateargument, there is no further access restriction in the resulting instantiation where the corresponding
template-parameter name is used. — end note ] [ Example:
template<class T> class X {
static T t;
};
class Y {
138) There is no such ambiguity in a default template-argument because the form of the template-parameter determines the
allowable forms of the template-argument.
§ 14.3 326

 c ISO/IEC N3242=11-0012
private:
struct S { /∗ ... ∗/ };
X<S> x; // OK: S is accessible
// X<Y::S> has a static member of type Y::S
// OK: even though Y::S is private
};
X<Y::S> y; // error: S not accessible
— end example ] For a template-argument that is a class type or a class template, the template definition
has no special access rights to the members of the template-argument. [ Example:
template <template <class TT> class T> class A {
typename T<int>::S s;
};
template <class U> class B {
private:
struct S { /∗ ... ∗/ };
};
A<B> b; // ill-formed: A has no access to B::S
— end example ]
4 When template argument packs or default template-arguments are used, a template-argument list can be
empty. In that case the empty <> brackets shall still be used as the template-argument-list. [ Example:
template<class T = char> class String;
String<>* p; // OK: String<char>
String* q; // syntax error
template<class ... Elements> class Tuple;
Tuple<>* t; // OK: Elements is empty
Tuple* u; // syntax error
— end example ]
5 An explicit destructor call (12.4) for an object that has a type that is a class template specialization may
explicitly specify the template-arguments. [ Example:
template<class T> struct A {
~A();
};
void f(A<int>* p, A<int>* q) {
p->A<int>::~A(); // OK: destructor call
q->A<int>::~A<int>(); // OK: destructor call
} —
end example ]
6 If the use of a template-argument gives rise to an ill-formed construct in the instantiation of a template
specialization, the program is ill-formed.
7 When the template in a template-id is an overloaded function template, both non-template functions in the
overload set and function templates in the overload set for which the template-arguments do not match the
template-parameters are ignored. If none of the function templates have matching template-parameters, the
program is ill-formed.
§ 14.3 327

 c ISO/IEC N3242=11-0012
8 A template-argument followed by an ellipsis is a pack expansion (14.5.3).
14.3.1 Template type arguments [temp.arg.type]
1 A template-argument for a template-parameter which is a type shall be a type-id.
2 [ Example:
template <class T> class X { };
template <class T> void f(T t) { }
struct { } unnamed_obj;
void f() {
struct A { };
enum { e1 };
typedef struct { } B;
B b;
X<A> x1; // OK
X<A*> x2; // OK
X<B> x3; // OK
f(e1); // OK
f(unnamed_obj); // OK
f(b); // OK
}
— end example ] [ Note: A template type argument may be an incomplete type (3.9). — end note ]
3 If a declaration acquires a function type through a type dependent on a template-parameter and this causes a
declaration that does not use the syntactic form of a function declarator to have function type, the program
is ill-formed. [ Example:
template<class T> struct A {
static T t;
};
typedef int function();
A<function> a; // ill-formed: would declare A<function>::t
// as a static member function
— end example ]
14.3.2 Template non-type arguments [temp.arg.nontype]
1 A template-argument for a non-type, non-template template-parameter shall be one of:
— an integral constant expression (including a constant expression of literal class type that can be used
as an integral constant expression as described in 5.19); or
— the name of a non-type template-parameter; or
— a constant expression (5.19) that designates the address of an object with static storage duration and
external or internal linkage or a function with external or internal linkage, including function templates
and function template-ids but excluding non-static class members, expressed (ignoring parentheses) as
& id-expression, except that the & may be omitted if the name refers to a function or array and shall
be omitted if the corresponding template-parameter is a reference; or
— a constant expression that evaluates to a null pointer value (4.10); or
— a constant expression that evaluates to a null member pointer value (4.11); or
§ 14.3.2 328

 c ISO/IEC N3242=11-0012
— a pointer to member expressed as described in 5.3.1.
2 [ Note: A string literal (2.14.5) does not satisfy the requirements of any of these categories and thus is not
an acceptable template-argument. [ Example:
template<class T, const char* p> class X {
/∗
... ∗/
};
X<int, "Studebaker"> x1; // error: string literal as template-argument
const char p[] = "Vivisectionist";
X<int,p> x2; // OK
— end example ] — end note ]
3 [ Note: Addresses of array elements and names or addresses of non-static class members are not acceptable
template-arguments. [ Example:
template<int* p> class X { };
int a[10];
struct S { int m; static int s; } s;
X<&a[2]> x3; // error: address of array element
X<&s.m> x4; // error: address of non-static member
X<&s.s> x5; // error: &S::s must be used
X<&S::s> x6; // OK: address of static member
— end example ] — end note ]
4 [ Note: Temporaries, unnamed lvalues, and named lvalues that do not have external linkage are not acceptable template-arguments when the corresponding template-parameter has reference type. [ Example:
template<const int& CRI> struct B { /∗ ... ∗/ };
B<1> b2; // error: temporary would be required for template argument
int c = 1;
B<c> b1; // OK
— end example ] — end note ]
5 The following conversions are performed on each expression used as a non-type template-argument. If a
non-type template-argument cannot be converted to the type of the corresponding template-parameter then
the program is ill-formed.
— for a non-type template-parameter of integral or enumeration type, integral promotions (4.5) and
integral conversions (4.7) are applied.
— for a non-type template-parameter of type pointer to object, qualification conversions (4.4) and the
array-to-pointer conversion (4.2) are applied; if the template-argument is of type std::nullptr_t, the
null pointer conversion (4.10) is applied. [ Note: In particular, neither the null pointer conversion for
a zero-valued integral constant expression (4.10) nor the derived-to-base conversion (4.10) are applied.
Although 0 is a valid template-argument for a non-type template-parameter of integral type, it is not
a valid template-argument for a non-type template-parameter of pointer type. However, both (int*)0
and nullptr are valid template-arguments for a non-type template-parameter of type “pointer to int.”
— end note ]
§ 14.3.2 329

 c ISO/IEC N3242=11-0012
— For a non-type template-parameter of type reference to object, no conversions apply. The type referred
to by the reference may be more cv-qualified than the (otherwise identical) type of the templateargument. The template-parameter is bound directly to the template-argument, which shall be an
lvalue.
— For a non-type template-parameter of type pointer to function, the function-to-pointer conversion (4.3)
is applied; if the template-argument is of type std::nullptr_t, the null pointer conversion (4.10) is
applied. If the template-argument represents a set of overloaded functions (or a pointer to such), the
matching function is selected from the set (13.4).
— For a non-type template-parameter of type reference to function, no conversions apply. If the templateargument represents a set of overloaded functions, the matching function is selected from the set (13.4).
— For a non-type template-parameter of type pointer to member function, if the template-argument is of
type std::nullptr_t, the null member pointer conversion (4.11) is applied; otherwise, no conversions
apply. If the template-argument represents a set of overloaded member functions, the matching member
function is selected from the set (13.4).
— For a non-type template-parameter of type pointer to data member, qualification conversions (4.4) are
applied; if the template-argument is of type std::nullptr_t, the null member pointer conversion (4.11)
is applied.
[ Example:
template<const int* pci> struct X { /∗ ... ∗/ };
int ai[10];
X<ai> xi; // array to pointer and qualification conversions
struct Y { /∗ ... ∗/ };
template<const Y& b> struct Z { /∗ ... ∗/ };
Y y;
Z<y> z; // no conversion, but note extra cv-qualification
template<int (&pa)[5]> struct W { /∗ ... ∗/ };
int b[5];
W<b> w; // no conversion
void f(char);
void f(int);
template<void (*pf)(int)> struct A { /∗ ... ∗/ };
A<&f> a; // selects f(int)
— end example ]
14.3.3 Template template arguments [temp.arg.template]
1 A template-argument for a template template-parameter shall be the name of a class template or [FI 11]
a template aliasan alias template, expressed as id-expression. When the template-argument names a class
template, only primary class templates are considered when matching the template template argument with
the corresponding parameter; partial specializations are not considered even if their parameter lists match
that of the template template parameter.
2 Any partial specializations (14.5.5) associated with the primary class template are considered when a specialization based on the template template-parameter is instantiated. If a specialization is not visible at the
§ 14.3.3 330

 c ISO/IEC N3242=11-0012
point of instantiation, and it would have been selected had it been visible, the program is ill-formed; no
diagnostic is required. [ Example:
template<class T> class A { // primary template
int x;
};
template<class T> class A<T*> { // partial specialization
long x;
};
template<template<class U> class V> class C {
V<int> y;
V<int*> z;
};
C<A> c; // V<int> within C<A> uses the primary template,
// so c.y.x has type int
// V<int*> within C<A> uses the partial specialization,
// so c.z.x has type long
— end example ]
[ Example:
template<class T> class A { /∗ ... ∗/ };
template<class T, class U = T> class B { /∗ ... ∗/ };
template <class ... Types> class C { /∗ ... ∗/ };
template<template<class> class P> class X { /∗ ... ∗/ };
template<template<class ...> class Q> class Y { /∗ ... ∗/ };
X<A> xa; // OK
X<B> xb; // ill-formed: default arguments for the parameters of a template argument are ignored
X<C> xc; // ill-formed: a template parameter pack does not match a template parameter
Y<A> ya; // OK
Y<B> yb; // OK
Y<C> yc; // OK
— end example ]
3 A template-argument matches a template template-parameter (call it P) when each of the template parameters
in the template-parameter-list of the template-argument’s corresponding class template or [FI 11] template
aliasalias template (call it A) matches the corresponding template parameter in the template-parameter-list
of P. When P’s template-parameter-list contains a template parameter pack (14.5.3), the template parameter
pack will match zero or more template parameters or template parameter packs in the template-parameterlist of A with the same type and form as the template parameter pack in P (ignoring whether those template
parameters are template parameter packs) [ Example:
template <class T> struct eval;
template <template <class, class...> class TT, class T1, class... Rest>
struct eval<TT<T1, Rest...>> { };
template <class T1> struct A;
template <class T1, class T2> struct B;
template <int N> struct C;
template <class T1, int N> struct D;
template <class T1, class T2, int N = 17> struct E;
§ 14.3.3 331

 c ISO/IEC N3242=11-0012
eval<A<int>> eA; // OK: matches partial specialization of eval
eval<B<int, float>> eB; // OK: matches partial specialization of eval
eval<C<17>> eC; // error: C does not match TT in partial specialization
eval<D<int, 17>> eD; // error: D does not match TT in partial specialization
eval<E<int, float>> eE; // error: E does not match TT in partial specialization
— end example ]
14.4 Type equivalence [temp.type]
1 Two template-ids refer to the same class or function if
— their template-names, operator-function-ids, or literal-operator-ids refer to the same template and
— their corresponding type template-arguments are the same type and
— their corresponding non-type template arguments of integral or enumeration type have identical values
and
— their corresponding non-type template-arguments of pointer type refer to the same external object or
function or are both the null pointer value and
— their corresponding non-type template-arguments of pointer-to-member type refer to the same class
member or are both the null member pointer value and
— their corresponding non-type template-arguments of reference type refer to the same external object
or function and
— their corresponding template template-arguments refer to the same template.
[ Example:
template<class E, int size> class buffer { /∗ ... ∗/ };
buffer<char,2*512> x;
buffer<char,1024> y;
declares x and y to be of the same type, and
template<class T, void(*err_fct)()> class list { /∗ ... ∗/ };
list<int,&error_handler1> x1;
list<int,&error_handler2> x2;
list<int,&error_handler2> x3;
list<char,&error_handler2> x4;
declares x2 and x3 to be of the same type. Their type differs from the types of x1 and x4.
template<template<class> class TT> struct X { };
template<class> struct Y { };
template<class T> using Z = Y<T>;
X<Y> y;
X<Z> z;
declares y and z to be of the same type. — end example ]
§ 14.4 332

 c ISO/IEC N3242=11-0012
14.5 Template declarations [temp.decls]
1 A template-id, that is, the template-name followed by a template-argument-list shall not be specified in the
declaration of a primary template declaration. [ Example:
template<class T1, class T2, int I> class A<T1, T2, I> { }; // error
template<class T1, int I> void sort<T1, I>(T1 data[I]); // error
— end example ] [ Note: However, this syntax is allowed in class template partial specializations (14.5.5).
— end note ]
2 For purposes of name lookup and instantiation, default arguments of function templates and default arguments of member functions of class templates are considered definitions; each default argument is a separate
definition which is unrelated to the function template definition or to any other default arguments.
3 Because an alias-declaration cannot declare a template-id, it is not possible to partially or explicitly specialize
[FI 11] a template aliasan alias template.
14.5.1 Class templates [temp.class]
1 A class template defines the layout and operations for an unbounded set of related types. [ Example: a single
class template List might provide a common definition for list of int, list of float, and list of pointers to
Shapes. — end example ]
[ Example: An array class template might be declared like this:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
2 The prefix template <class T> specifies that a template is being declared and that a type-name T will be
used in the declaration. In other words, Array is a parameterized type with T as its parameter. — end
example ]
3 When a member function, a member class, a static data member or a member template of a class template
is defined outside of the class template definition, the member definition is defined as a template definition
in which the template-parameters are those of the class template. The names of the template parameters
used in the definition of the member may be different from the template parameter names used in the class
template definition. The template argument list following the class template name in the member definition
shall name the parameters in the same order as the one used in the template parameter list of the member.
Each template parameter pack shall be expanded with an ellipsis in the template argument list. [ Example:
template<class T1, class T2> struct A {
void f1();
void f2();
};
template<class T2, class T1> void A<T2,T1>::f1() { } // OK
template<class T2, class T1> void A<T1,T2>::f2() { } // error
§ 14.5.1 333

 c ISO/IEC N3242=11-0012
template<class ... Types> struct B {
void f3();
void f4();
};
template<class ... Types> void B<Types ...>::f3() { } // OK
template<class ... Types> void B<Types>::f4() { } // error
— end example ]
4 In a redeclaration, partial specialization, explicit specialization or explicit instantiation of a class template,
the class-key shall agree in kind with the original class template declaration (7.1.6.3).
14.5.1.1 Member functions of class templates [temp.mem.func]
1 A member function of a class template may be defined outside of the class template definition in which it is
declared. [ Example:
template<class T> class Array {
T* v;
int sz;
public:
explicit Array(int);
T& operator[](int);
T& elem(int i) { return v[i]; }
};
declares three function templates. The subscript function might be defined like this:
template<class T> T& Array<T>::operator[](int i) {
if (i<0 || sz<=i) error("Array: range error");
return v[i];
}
— end example ]
2 The template-arguments for a member function of a class template are determined by the template-arguments
of the type of the object for which the member function is called. [ Example: the template-argument for
Array<T> :: operator [] () will be determined by the Array to which the subscripting operation is applied.
Array<int> v1(20);
Array<dcomplex> v2(30);
v1[3] = 7; // Array<int>::operator[]()
v2[3] = dcomplex(7,8); // Array<dcomplex>::operator[]()
— end example ]
14.5.1.2 Member classes of class templates [temp.mem.class]
1 A class member of a class template may be defined outside the class template definition in which it is declared.
[ Note: The class member must be defined before its first use that requires an instantiation (14.7.1). For
example,
template<class T> struct A {
class B;
};
A<int>::B* b1; // OK: requires A to be defined but not A::B
§ 14.5.1.2 334

 c ISO/IEC N3242=11-0012
template<class T> class A<T>::B { };
A<int>::B b2; // OK: requires A::B to be defined
— end note ]
14.5.1.3 Static data members of class templates [temp.static]
1 A definition for a static data member may be provided in a namespace scope enclosing the definition of the
static member’s class template. [ Example:
template<class T> class X {
static T s;
};
template<class T> T X<T>::s = 0;
— end example ]
2 An explicit specialization of a static data member declared as an array of unknown bound can have a different
bound from its definition, if any. [ Example:
template <class T> struct A {
static int i[];
};
template <class T> int A<T>::i[4]; // 4 elements
template <> int A<int>::i[] = { 1 }; // OK: 1 element
— end example ]
14.5.2 Member templates [temp.mem]
1 A template can be declared within a class or class template; such a template is called a member template. A
member template can be defined within or outside its class definition or class template definition. A member
template of a class template that is defined outside of its class template definition shall be specified with
the template-parameters of the class template followed by the template-parameters of the member template.
[ Example:
template<class T> struct string {
template<class T2> int compare(const T2&);
template<class T2> string(const string<T2>& s) { /∗ ... ∗/ }
};
template<class T> template<class T2> int string<T>::compare(const T2& s) {
}
— end example ]
2 A local class shall not have member templates. Access control rules (Clause 11) apply to member template
names. A destructor shall not be a member template. A normal (non-template) member function with a
given name and type and a member function template of the same name, which could be used to generate
a specialization of the same type, can both be declared in a class. When both exist, a use of that name and
type refers to the non-template member unless an explicit template argument list is supplied. [ Example:
template <class T> struct A {
void f(int);
template <class T2> void f(T2);
};
§ 14.5.2 335

 c ISO/IEC N3242=11-0012
template <> void A<int>::f(int) { } // non-template member
template <> template <> void A<int>::f<>(int) { } // template member
int main() {
A<char> ac;
ac.f(1); // non-template
ac.f(’c’); // template
ac.f<>(1); // template
} —
end example ]
3 A member function template shall not be virtual. [ Example:
template <class T> struct AA {
template <class C> virtual void g(C); // error
virtual void f(); // OK
};
— end example ]
4 A specialization of a member function template does not override a virtual function from a base class.
[ Example:
class B {
virtual void f(int);
};
class D : public B {
template <class T> void f(T); // does not override B::f(int)
void f(int i) { f<>(i); } // overriding function that calls
// the template instantiation
};
— end example ]
5 A specialization of a conversion function template is referenced in the same way as a non-template conversion
function that converts to the same type. [ Example:
struct A {
template <class T> operator T*();
};
template <class T> A::operator T*(){ return 0; }
template <> A::operator char*(){ return 0; } // specialization
template A::operator void*(); // explicit instantiation
int main() {
A a;
int *ip;
ip = a.operator int*(); // explicit call to template operator
// A::operator int*()
} —
end example ] [ Note: Because the explicit template argument list follows the function template name,
and because conversion member function templates and constructor member function templates are called
without using a function name, there is no way to provide an explicit template argument list for these
function templates. — end note ]
§ 14.5.2 336

 c ISO/IEC N3242=11-0012
6 A specialization of a conversion function template is not found by name lookup. Instead, any conversion
function templates visible in the context of the use are considered. For each such operator, if argument
deduction succeeds (14.8.2.3), the resulting specialization is used as if found by name lookup.
7 A using-declaration in a derived class cannot refer to a specialization of a conversion function template in a
base class.
8 Overload resolution (13.3.3.2) and partial ordering (14.5.6.2) are used to select the best conversion function
among multiple specializations of conversion function templates and/or non-template conversion functions.
14.5.3 Variadic templates [temp.variadic]
1 A template parameter pack is a template parameter that accepts zero or more template arguments. [ Example:
template<class ... Types> struct Tuple { };
Tuple<> t0; // Types contains no arguments
Tuple<int> t1; // Types contains one argument: int
Tuple<int, float> t2; // Types contains two arguments: int and float
Tuple<0> error; // error: 0 is not a type
— end example ]
2 A function parameter pack is a function parameter that accepts zero or more function arguments. [ Example:
template<class ... Types> void f(Types ... args);
f(); // OK: args contains no arguments
f(1); // OK: args contains one argument: int
f(2, 1.0); // OK: args contains two arguments: int and double
— end example ]
3 A parameter pack is either a template parameter pack or a function parameter pack.
4 A pack expansion is a sequence of tokens that names one or more parameter packs, followed by an ellipsis.
The sequence of tokens is called the pattern of the expansion; its syntax depends on the context in which
the expansion occurs. Pack expansions can occur in the following contexts:
— In an initializer-list (8.5); the pattern is an initializer-clause.
— In a base-specifier-list (Clause 10); the pattern is a base-specifier.
— In a mem-initializer-list (12.6.2); the pattern is a mem-initializer.
— In a template-argument-list (14.3); the pattern is a template-argument.
— In a dynamic-exception-specification (15.4); the pattern is a type-id.
— In an attribute-list (7.6.1); the pattern is an attribute.
— In an alignment-specifier (7.6.2); the pattern is the alignment-specifier without the ellipsis.
— In a capture-list (5.1.2); the pattern is a capture.
[ Example:
template<class ... Types> void f(Types ... rest);
template<class ... Types> void g(Types ... rest) {
f(&rest ...); // “&rest ...” is a pack expansion; “&rest” is its pattern
}
§ 14.5.3 337

 c ISO/IEC N3242=11-0012
— end example ]
5 A parameter pack whose name appears within the pattern of a pack expansion is expanded by that pack
expansion. An appearance of the name of a parameter pack is only expanded by the innermost enclosing
pack expansion. The pattern of a pack expansion shall name one or more parameter packs that are not
expanded by a nested pack expansion. All of the parameter packs expanded by a pack expansion shall have
the same number of arguments specified. An appearance of a name of a parameter pack that is not expanded
is ill-formed. [ Example:
template<typename...> struct Tuple {};
template<typename T1, typename T2> struct Pair {};
template<class ... Args1> struct zip {
template<class ... Args2> struct with {
typedef Tuple<Pair<Args1, Args2> ... > type;
};
};
typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
// T1 is Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>
typedef zip<short>::with<unsigned short, unsigned>::type T2;
// error: different number of arguments specified for Args1 and Args2
template<class ... Args> void g(Args ... args) {
f(const_cast<const Args*>(&args)...); // OK: “Args” and “args” are expanded
f(5 ...); // error: pattern does not contain any parameter packs
f(args); // error: parameter pack “args” is not expanded
f(h(args ...) + args ...); // OK: first “args” expanded within h, second
// “args” expanded within f
}
— end example ]
6 The instantiation of an expansion produces a list E1 ⊕ E2 ⊕ ... ⊕ EN , E1, E2, ..., EN , where N is the number of
elements in the pack expansion parameters and ⊕ is the syntactically-appropriate separator for the list (if
any). Each Ei is generated by instantiating the pattern and replacing each pack expansion parameter with
its ith element. All of the Ei become elements in the enclosing list. [ Note: The variety of list varies with
the context: expression-list, base-specifier-list, template-argument-list, etc. — end note ]
14.5.4 Friends [temp.friend]
1 A friend of a class or class template can be a function template or class template, a specialization of a
function template or class template, or an ordinary (non-template) function or class. For a friend function
declaration that is not a template declaration:
— if the name of the friend is a qualified or unqualified template-id, the friend declaration refers to a
specialization of a function template, otherwise
— if the name of the friend is a qualified-id and a matching non-template function is found in the specified
class or namespace, the friend declaration refers to that function, otherwise,
— if the name of the friend is a qualified-id and a matching function template is found in the specified class or namespace, the friend declaration refers to the deduced specialization of that function
template (14.8.2.6), otherwise,
— the name shall be an unqualified-id that declares (or redeclares) an ordinary (non-template) function.
§ 14.5.4 338

 c ISO/IEC N3242=11-0012
[ Example:
template<class T> class task;
template<class T> task<T>* preempt(task<T>*);
template<class T> class task {
friend void next_time();
friend void process(task<T>*);
friend task<T>* preempt<T>(task<T>*);
template<class C> friend int func(C);
friend class task<int>;
template<class P> friend class frd;
};
Here, each specialization of the task class template has the function next_time as a friend; because process
does not have explicit template-arguments, each specialization of the task class template has an appropriately
typed function process as a friend, and this friend is not a function template specialization; because the
friend preempt has an explicit template-argument <T>, each specialization of the task class template has
the appropriate specialization of the function template preempt as a friend; and each specialization of
the task class template has all specializations of the function template func as friends. Similarly, each
specialization of the task class template has the class template specialization task<int> as a friend, and
has all specializations of the class template frd as friends. — end example ]
2 A friend template may be declared within a class or class template. A friend function template may be
defined within a class or class template, but a friend class template may not be defined in a class or class
template. In these cases, all specializations of the friend class or friend function template are friends of the
class or class template granting friendship. [ Example:
class A {
template<class T> friend class B; // OK
template<class T> friend void f(T){ /* ... */ } // OK
};
— end example ]
3 A template friend declaration specifies that all specializations of that template, whether they are implicitly
instantiated (14.7.1), partially specialized (14.5.5) or explicitly specialized (14.7.3), are friends of the class
containing the template friend declaration. [ Example:
class X {
template<class T> friend struct A;
class Y { };
};
template<class T> struct A { X::Y ab; }; // OK
template<class T> struct A<T*> { X::Y ab; }; // OK
— end example ]
4 When a function is defined in a friend function declaration in a class template, the function is instantiated
when the function is odr-used. The same restrictions on multiple declarations and definitions that apply to
non-template function declarations and definitions also apply to these implicit definitions.
5 A member of a class template may be declared to be a friend of a non-template class. In this case, the
corresponding member of every specialization of the class template is a friend of the class granting friendship.
§ 14.5.4 339

 c ISO/IEC N3242=11-0012
For explicit specializations the corresponding member is the member (if any) that has the same name, kind
(type, function, class template, or function template), template parameters, and signature as the member
of the class template instantiation that would otherwise have been generated. [ Example:
template<class T> struct A {
struct B { };
void f();
struct D {
void g();
};
};
template<> struct A<int> {
struct B { };
int f();
struct D {
void g();
};
};
class C {
template<class T> friend struct A<T>::B; // grants friendship to A<int>::B even though
// it is not a specialization of A<T>::B
template<class T> friend void A<T>::f(); // does not grant friendship to A<int>::f()
// because its return type does not match
template<class T> friend void A<T>::D::g(); // does not grant friendship to A<int>::D::g()
// because A<int>::D is not a specialization of A<T>::D
};
— end example ]
6 [ Note: A friend declaration may first declare a member of an enclosing namespace scope (14.6.5). — end
note ]
7 A friend template shall not be declared in a local class.
8 Friend declarations shall not declare partial specializations. [ Example:
template<class T> class A { };
class X {
template<class T> friend class A<T*>; // error
};
— end example ]
9 When a friend declaration refers to a specialization of a function template, the function parameter declarations shall not include default arguments, nor shall the inline specifier be used in such a declaration.
14.5.5 Class template partial specializations [temp.class.spec]
1 A primary class template declaration is one in which the class template name is an identifier. A template
declaration in which the class template name is a simple-template-id is a partial specialization of the class
template named in the simple-template-id. A partial specialization of a class template provides an alternative
definition of the template that is used instead of the primary definition when the arguments in a specialization
match those given in the partial specialization (14.5.5.1). The primary template shall be declared before
any specializations of that template. A partial specialization shall be declared before the first use of a class
§ 14.5.5 340

 c ISO/IEC N3242=11-0012
template specialization that would make use of the partial specialization as the result of an implicit or
explicit instantiation in every translation unit in which such a use occurs; no diagnostic is required.
2 Each class template partial specialization is a distinct template and definitions shall be provided for the
members of a template partial specialization (14.5.5.3).
3 [ Example:
template<class T1, class T2, int I> class A { }; // #1
template<class T, int I> class A<T, T*, I> { }; // #2
template<class T1, class T2, int I> class A<T1*, T2, I> { }; // #3
template<class T> class A<int, T*, 5> { }; // #4
template<class T1, class T2, int I> class A<T1, T2*, I> { }; // #5
The first declaration declares the primary (unspecialized) class template. The second and subsequent declarations declare partial specializations of the primary template. — end example ]
4 The template parameters are specified in the angle bracket enclosed list that immediately follows the keyword
template. For partial specializations, the template argument list is explicitly written immediately following
the class template name. For primary templates, this list is implicitly described by the template parameter
list. Specifically, the order of the template arguments is the sequence in which they appear in the template
parameter list. [ Example: the template argument list for the primary template in the example above is <T1,
T2, I>. — end example ] [ Note: The template argument list shall not be specified in the primary template
declaration. For example,
template<class T1, class T2, int I> class A<T1, T2, I> { }; // error
— end note ]
5 A class template partial specialization may be declared or redeclared in any namespace scope in which its
definition may be defined (14.5.1 and 14.5.2). [ Example:
template<class T> struct A {
struct C {
template<class T2> struct B { };
};
};
// partial specialization of A<T>::C::B<T2>
template<class T> template<class T2>
struct A<T>::C::B<T2*> { };
A<short>::C::B<int*> absip; // uses partial specialization
— end example ]
6 Partial specialization declarations themselves are not found by name lookup. Rather, when the primary
template name is used, any previously-declared partial specializations of the primary template are also
considered. One consequence is that a using-declaration which refers to a class template does not restrict
the set of partial specializations which may be found through the using-declaration. [ Example:
namespace N {
template<class T1, class T2> class A { }; // primary template
}
using N::A; // refers to the primary template
§ 14.5.5 341

 c ISO/IEC N3242=11-0012
namespace N {
template<class T> class A<T, T*> { }; // partial specialization
}
A<int,int*> a; // uses the partial specialization, which is found through
// the using declaration which refers to the primary template
— end example ]
7 A non-type argument is non-specialized if it is the name of a non-type parameter. All other non-type
arguments are specialized.
8 Within the argument list of a class template partial specialization, the following restrictions apply:
— A partially specialized non-type argument expression shall not involve a template parameter of the
partial specialization except when the argument expression is a simple identifier. [ Example:
template <int I, int J> struct A {};
template <int I> struct A<I+5, I*2> {}; // error
template <int I, int J> struct B {};
template <int I> struct B<I, I> {}; // OK
— end example ]
— The type of a template parameter corresponding to a specialized non-type argument shall not be
dependent on a parameter of the specialization. [ Example:
template <class T, T t> struct C {};
template <class T> struct C<T, 1>; // error
template< int X, int (*array_ptr)[X] > class A {};
int array[5];
template< int X > class A<X,&array> { }; // error
— end example ]
— The argument list of the specialization shall not be identical to the implicit argument list of the primary
template.
— The template parameter list of a specialization shall not contain default template argument values.139
— An argument shall not contain an unexpanded parameter pack. If an argument is a pack expansion (14.5.3), it shall be the last argument in the template argument list.
14.5.5.1 Matching of class template partial specializations [temp.class.spec.match]
1 When a class template is used in a context that requires an instantiation of the class, it is necessary to
determine whether the instantiation is to be generated using the primary template or one of the partial
specializations. This is done by matching the template arguments of the class template specialization with
the template argument lists of the partial specializations.
— If exactly one matching specialization is found, the instantiation is generated from that specialization.
139) There is no way in which they could be used.
§ 14.5.5.1 342

 c ISO/IEC N3242=11-0012
— If more than one matching specialization is found, the partial order rules (14.5.5.2) are used to determine whether one of the specializations is more specialized than the others. If none of the specializations
is more specialized than all of the other matching specializations, then the use of the class template is
ambiguous and the program is ill-formed.
— If no matches are found, the instantiation is generated from the primary template.
2 A partial specialization matches a given actual template argument list if the template arguments of the
partial specialization can be deduced from the actual template argument list (14.8.2). [ Example:
A<int, int, 1> a1; // uses #1
A<int, int*, 1> a2; // uses #2, T is int, I is 1
A<int, char*, 5> a3; // uses #4, T is char
A<int, char*, 1> a4; // uses #5, T1 is int, T2 is char, I is 1
A<int*, int*, 2> a5; // ambiguous: matches #3 and #5
— end example ]
3 A non-type template argument can also be deduced from the value of an actual template argument of a
non-type parameter of the primary template. [ Example: the declaration of a2 above. — end example ]
4 In a type name that refers to a class template specialization, (e.g., A<int, int, 1>) the argument list shall
match the template parameter list of the primary template. The template arguments of a specialization are
deduced from the arguments of the primary template.
14.5.5.2 Partial ordering of class template specializations [temp.class.order]
1 For two class template partial specializations, the first is at least as specialized as the second if, given the
following rewrite to two function templates, the first function template is at least as specialized as the second
according to the ordering rules for function templates (14.5.6.2):
— the first function template has the same template parameters as the first partial specialization and has
a single function parameter whose type is a class template specialization with the template arguments
of the first partial specialization, and
— the second function template has the same template parameters as the second partial specialization
and has a single function parameter whose type is a class template specialization with the template
arguments of the second partial specialization.
2 [ Example:
template<int I, int J, class T> class X { };
template<int I, int J> class X<I, J, int> { }; // #1
template<int I> class X<I, I, int> { }; // #2
template<int I, int J> void f(X<I, J, int>); // A
template<int I> void f(X<I, I, int>); // B
The partial specialization #2 is more specialized than the partial specialization #1 because the function
template B is more specialized than the function template A according to the ordering rules for function
templates. — end example ]
14.5.5.3 Members of class template specializations [temp.class.spec.mfunc]
1 The template parameter list of a member of a class template partial specialization shall match the template
parameter list of the class template partial specialization. The template argument list of a member of a class
§ 14.5.5.3 343

 c ISO/IEC N3242=11-0012
template partial specialization shall match the template argument list of the class template partial specialization. A class template specialization is a distinct template. The members of the class template partial
specialization are unrelated to the members of the primary template. Class template partial specialization
members that are used in a way that requires a definition shall be defined; the definitions of members of the
primary template are never used as definitions for members of a class template partial specialization. An
explicit specialization of a member of a class template partial specialization is declared in the same way as
an explicit specialization of the primary template. [ Example:
// primary template
template<class T, int I> struct A {
void f();
};
template<class T, int I> void A<T,I>::f() { }
// class template partial specialization
template<class T> struct A<T,2> {
void f();
void g();
void h();
};
// member of class template partial specialization
template<class T> void A<T,2>::g() { }
// explicit specialization
template<> void A<char,2>::h() { }
int main() {
A<char,0> a0;
A<char,2> a2;
a0.f(); // OK, uses definition of primary template’s member
a2.g(); // OK, uses definition of
// partial specialization’s member
a2.h(); // OK, uses definition of
// explicit specialization’s member
a2.f(); // ill-formed, no definition of f for A<T,2>
// the primary template is not used here
}
— end example ]
2 If a member template of a class template is partially specialized, the member template partial specializations
are member templates of the enclosing class template; if the enclosing class template is instantiated (14.7.1,
14.7.2), a declaration for every member template partial specialization is also instantiated as part of creating
the members of the class template specialization. If the primary member template is explicitly specialized
for a given (implicit) specialization of the enclosing class template, the partial specializations of the member
template are ignored for this specialization of the enclosing class template. If a partial specialization of the
member template is explicitly specialized for a given (implicit) specialization of the enclosing class template,
the primary member template and its other partial specializations are still considered for this specialization
of the enclosing class template. [ Example:
template<class T> struct A {
template<class T2> struct B {}; // #1
template<class T2> struct B<T2*> {}; // #2
§ 14.5.5.3 344

 c ISO/IEC N3242=11-0012
};
template<> template<class T2> struct A<short>::B {}; // #3
A<char>::B<int*> abcip; // uses #2
A<short>::B<int*> absip; // uses #3
A<char>::B<int> abci; // uses #1
— end example ]
14.5.6 Function templates [temp.fct]
1 A function template defines an unbounded set of related functions. [ Example: a family of sort functions
might be declared like this:
template<class T> class Array { };
template<class T> void sort(Array<T>&);
— end example ]
2 A function template can be overloaded with other function templates and with normal (non-template)
functions. A normal function is not related to a function template (i.e., it is never considered to be a specialization), even if it has the same name and type as a potentially generated function template specialization.140
14.5.6.1 Function template overloading [temp.over.link]
1 It is possible to overload function templates so that two different function template specializations have the
same type. [ Example:
// file1.c
template<class T>
void f(T*);
void g(int* p) {
f(p); // calls f<int>(int*)
}
// file2.c
template<class T>
void f(T);
void h(int* p) {
f(p); // calls f<int*>(int*)
}
— end example ]
2 Such specializations are distinct functions and do not violate the one definition rule (3.2).
3 The signature of a function template is defined in 1.3. The names of the template parameters are significant
only for establishing the relationship between the template parameters and the rest of the signature. [ Note:
Two distinct function templates may have identical function return types and function parameter lists, even
if overload resolution alone cannot distinguish them.
template<class T> void f();
template<int I> void f(); // OK: overloads the first template
// distinguishable with an explicit template argument list
— end note ]
4 When an expression that references a template parameter is used in the function parameter list or the return
type in the declaration of a function template, the expression that references the template parameter is part
140) That is, declarations of non-template functions do not merely guide overload resolution of function template specializations
with the same name. If such a non-template function is odr-used (3.2) in a program, it must be defined; it will not be implicitly
instantiated using the function template definition.
§ 14.5.6.1 345

 c ISO/IEC N3242=11-0012
of the signature of the function template. This is necessary to permit a declaration of a function template
in one translation unit to be linked with another declaration of the function template in another translation
unit and, conversely, to ensure that function templates that are intended to be distinct are not linked with
one another. [ Example:
template <int I, int J> A<I+J> f(A<I>, A<J>); // #1
template <int K, int L> A<K+L> f(A<K>, A<L>); // same as #1
template <int I, int J> A<I-J> f(A<I>, A<J>); // different from #1
— end example ] [ Note: Most expressions that use template parameters use non-type template parameters,
but it is possible for an expression to reference a type parameter. For example, a template type parameter
can be used in the sizeof operator. — end note ]
5 Two expressions involving template parameters are considered equivalent if two function definitions containing the expressions would satisfy the one definition rule (3.2), except that the tokens used to name the
template parameters may differ as long as a token used to name a template parameter in one expression is
replaced by another token that names the same template parameter in the other expression. [ Example:
template <int I, int J> void f(A<I+J>); // #1
template <int K, int L> void f(A<K+L>); // same as #1
— end example ] Two expressions involving template parameters that are not equivalent are functionally
equivalent if, for any given set of template arguments, the evaluation of the expression results in the same
value.
6 Two function templates are equivalent if they are declared in the same scope, have the same name, have
identical template parameter lists, and have return types and parameter lists that are equivalent using the
rules described above to compare expressions involving template parameters. Two function templates are
functionally equivalent if they are equivalent except that one or more expressions that involve template
parameters in the return types and parameter lists are functionally equivalent using the rules described
above to compare expressions involving template parameters. If a program contains declarations of function
templates that are functionally equivalent but not equivalent, the program is ill-formed; no diagnostic is
required.
7 [ Note: This rule guarantees that equivalent declarations will be linked with one another, while not requiring
implementations to use heroic efforts to guarantee that functionally equivalent declarations will be treated
as distinct. For example, the last two declarations are functionally equivalent and would cause a program
to be ill-formed:
// Guaranteed to be the same
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+10>);
// Guaranteed to be different
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+11>);
// Ill-formed, no diagnostic required
template <int I> void f(A<I>, A<I+10>);
template <int I> void f(A<I>, A<I+1+2+3+4>);
— end note ]
14.5.6.2 Partial ordering of function templates [temp.func.order]
1 If a function template is overloaded, the use of a function template specialization might be ambiguous
because template argument deduction (14.8.2) may associate the function template specialization with more
§ 14.5.6.2 346

 c ISO/IEC N3242=11-0012
than one function template declaration. Partial ordering of overloaded function template declarations is
used in the following contexts to select the function template to which a function template specialization
refers:
— during overload resolution for a call to a function template specialization (13.3.3);
— when the address of a function template specialization is taken;
— when a placement operator delete that is a function template specialization is selected to match a
placement operator new (3.7.4.2, 5.3.4);
— when a friend function declaration (14.5.4), an explicit instantiation (14.7.2) or an explicit specialization (14.7.3) refers to a function template specialization.
2 Partial ordering selects which of two function templates is more specialized than the other by transforming
each template in turn (see next paragraph) and performing template argument deduction using the function
type. The deduction process determines whether one of the templates is more specialized than the other. If
so, the more specialized template is the one chosen by the partial ordering process.
3 To produce the transformed template, for each type, non-type, or template template parameter (including
template parameter packs (14.5.3) thereof) synthesize a unique type, value, or class template respectively
and substitute it for each occurrence of that parameter in the function type of the template. If only one
of the function templates is a non-static member, that function template is considered to have a new first
parameter inserted in its function parameter list. The new parameter is of type “reference to cv A,” where cv
are the cv-qualifiers of the function template (if any) and A is the class of which the function template is a
member. [ Note: This allows a non-static member to be ordered with respect to a nonmember function and
for the results to be equivalent to the ordering of two equivalent nonmembers. — end note ] [ Example:
struct A { };
template<class T> struct B {
template<class R> int operator*(R&); // #1
};
template<class T, class R> int operator*(T&, R&); // #2
// The declaration of B::operator* is transformed into the equivalent of
// template<class R> int operator*(B<A>&, R&); // #1a
int main() {
A a;
B<A> b;
b * a; // calls #1a
}
— end example ]
4 Using the transformed function template’s function type, perform type deduction against the function type
of the other function template. The mechanism for performing these deductions is given in 14.8.2.4.
[ Example:
template<class T> struct A { A(); };
template<class T> void f(T);
template<class T> void f(T*);
template<class T> void f(const T*);
template<class T> void g(T);
§ 14.5.6.2 347

 c ISO/IEC N3242=11-0012
template<class T> void g(T&);
template<class T> void h(const T&);
template<class T> void h(A<T>&);
void m() {
const int *p;
f(p); // f(const T*) is more specialized than f(T) or f(T*)
float x;
g(x); // Ambiguous: g(T) or g(T&)
A<int> z;
h(z); // overload resolution selects h(A<T>&)
const A<int> z2;
h(z2); // h(const T&) is called because h(A<T>&) is not callable
}
— end example ]
5 The presence of unused ellipsis and default arguments has no effect on the partial ordering of function
templates. [ Example:
template<class T> void f(T); // #1
template<class T> void f(T*, int=1); // #2
template<class T> void g(T); // #3
template<class T> void g(T*, ...); // #4
int main() {
int* ip;
f(ip); // calls #2
g(ip); // calls #4
}
— end example ]
14.5.7 Aliase templates [temp.alias]
1 A template-declaration in which the declaration is an alias-declaration (Clause 7) declares the identifier to
be a [FI 11] template alias alias template . [FI 11] A template aliasAn alias template is a name for a family
of types. The name of the [FI 11] template aliasalias template is a template-name.
2 When a template-id refers to the specialization of [FI 11] a template aliasan alias template, it is equivalent
to the associated type obtained by substitution of its template-arguments for the template-parameters in the
type-id of the [FI 11] template aliasalias template. [ Note: [FI 11] A template aliasAn alias template name
is never deduced. — end note ] [ Example:
template<class T> struct Alloc { /∗ ... ∗/ };
template<class T> using Vec = vector<T, Alloc<T>>;
Vec<int> v; // same as vector<int, Alloc<int>> v;
template<class T>
void process(Vec<T>& v)
{ /∗ ... ∗/ }
template<class T>
void process(vector<T, Alloc<T>>& w)
{ /∗ ... ∗/ } // error: redefinition
§ 14.5.7 348

 c ISO/IEC N3242=11-0012
template<template<class> class TT>
void f(TT<int>);
f(v); // error: Vec not deduced
template<template<class,class> class TT>
void g(TT<int, Alloc<int>>);
g(v); // OK: TT = vector
— end example ]
3 The type-id in [FI 11] a template aliasan alias template declaration shall not refer to the [FI 11] template
aliasalias template being declared. The type produced by [FI 11] a template aliasan alias template specialization shall not directly or indirectly make use of that specialization. [ Example:
template <class T> struct A;
template <class T> using B = typename A<T>::U;
template <class T> struct A {
typedef B<T> U;
};
B<short> b; // error: instantiation of B<short> uses own type via A<short>::U
— end example ]
14.6 Name resolution [temp.res]
1 Three kinds of names can be used within a template definition:
— The name of the template itself, and names declared within the template itself.
— Names dependent on a template-parameter (14.6.2).
— Names from scopes which are visible within the template definition.
2 A name used in a template declaration or definition and that is dependent on a template-parameter is
assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified
by the keyword typename. [ Example:
// no B declared here
class X;
template<class T> class Y {
class Z; // forward declaration of member class
void f() {
X* a1; // declare pointer to X
T* a2; // declare pointer to T
Y* a3; // declare pointer to Y<T>
Z* a4; // declare pointer to Z
typedef typename T::A TA;
TA* a5; // declare pointer to T’s A
typename T::A* a6; // declare pointer to T’s A
T::A* a7; // T::A is not a type name:
// multiply T::A by a7; ill-formed,
// no visible declaration of a7
B* a8; // B is not a type name:
§ 14.6 349

 c ISO/IEC N3242=11-0012
// multiply B by a8; ill-formed,
// no visible declarations of B and a8
}
};
— end example ]
3 When a qualified-id is intended to refer to a type that is not a member of the current instantiation (14.6.2.1)
and its nested-name-specifier depends on a template-parameter (14.6.2), it shall be prefixed by the keyword
typename, forming a typename-specifier. If the qualified-id in a typename-specifier does not denote a type,
the program is ill-formed.
typename-specifier:
typename ::opt nested-name-specifier identifier
typename ::opt nested-name-specifier templateopt simple-template-id
4 If a specialization of a template is instantiated for a set of template-arguments such that the qualified-id
prefixed by typename does not denote a type, the specialization is ill-formed. The usual qualified name
lookup (3.4.3) is used to find the qualified-id even in the presence of typename. [ Example:
struct A {
struct X { };
int X;
};
struct B {
struct X { };
};
template<class T> void f(T t) {
typename T::X x;
}
void foo() {
A a;
B b;
f(b); // OK: T::X refers to B::X
f(a); // error: T::X refers to the data member A::X not the struct A::X
} —
end example ]
5 A qualified name used as the name in a mem-initializer-id, a base-specifier, or an elaborated-type-specifier
is implicitly assumed to name a type, without the use of the typename keyword. In a nested-name-specifier
that immediately contains a nested-name-specifier that depends on a template parameter, the identifier or
simple-template-id is implicitly assumed to name a type, without the use of the typename keyword. [ Note:
The typename keyword is not permitted by the syntax of these constructs. — end note ]
6 If, for a given set of template arguments, a specialization of a template is instantiated that refers to a
qualified-id that denotes a type, and the nested-name-specifier of the qualified-id depends on a template
parameter, the qualified-id shall either be prefixed by typename or shall be used in a context in which it
implicitly names a type as described above. [ Example:
template <class T> void f(int i) {
T::x * i; // T::x must not be a type
}
struct Foo {
typedef int x;
};
§ 14.6 350

 c ISO/IEC N3242=11-0012
struct Bar {
static int const x = 5;
};
int main() {
f<Bar>(1); // OK
f<Foo>(1); // error: Foo::x is a type
} —
end example ]
7 Within the definition of a class template or within the definition of a member of a class template, the keyword
typename is not required when referring to the unqualified name of a previously declared member of the
class template that declares a type. [ Example:
template<class T> struct A {
typedef int B;
B b; // OK, no typename required
};
— end example ]
8 Knowing which names are type names allows the syntax of every template definition to be checked. No
diagnostic shall be issued for a template definition for which a valid specialization can be generated. If
no valid specialization can be generated for a template definition, and that template is not instantiated,
the template definition is ill-formed, no diagnostic required. If a type used in a non-dependent name is
incomplete at the point at which a template is defined but is complete at the point at which an instantiation
is done, and if the completeness of that type affects whether or not the program is well-formed or affects
the semantics of the program, the program is ill-formed; no diagnostic is required. [ Note: If a template
is instantiated, errors will be diagnosed according to the other rules in this Standard. Exactly when these
errors are diagnosed is a quality of implementation issue. — end note ] [ Example:
int j;
template<class T> class X {
void f(T t, int i, char* p) {
t = i; // diagnosed if X::f is instantiated
// and the assignment to t is an error
p = i; // may be diagnosed even if X::f is
// not instantiated
p = j; // may be diagnosed even if X::f is
// not instantiated
}
void g(T t) {
+; // may be diagnosed even if X::g is
// not instantiated
}
};
— end example ]
9 When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1,
3.4.2) are used for non-dependent names. The lookup of names dependent on the template parameters is
postponed until the actual template argument is known (14.6.2). [ Example:
#include <iostream>
§ 14.6 351

 c ISO/IEC N3242=11-0012
using namespace std;
template<class T> class Set {
T* p;
int cnt;
public:
Set();
Set<T>(const Set<T>&);
void printall() {
for (int i = 0; i<cnt; i++)
cout << p[i] << ’\n’;
}
};
in the example, i is the local variable i declared in printall, cnt is the member cnt declared in Set, and
cout is the standard output stream declared in iostream. However, not every declaration can be found this
way; the resolution of some names must be postponed until the actual template-arguments are known. For
example, even though the name operator<< is known within the definition of printall() and a declaration
of it can be found in <iostream>, the actual declaration of operator<< needed to print p[i] cannot be
known until it is known what type T is (14.6.2). — end example ]
10 If a name does not depend on a template-parameter (as defined in 14.6.2), a declaration (or set of declarations)
for that name shall be in scope at the point where the name appears in the template definition; the name is
bound to the declaration (or declarations) found at that point and this binding is not affected by declarations
that are visible at the point of instantiation. [ Example:
void f(char);
template<class T> void g(T t) {
f(1); // f(char)
f(T(1)); // dependent
f(t); // dependent
dd++; // not dependent
// error: declaration for dd not found
}
enum E { e };
void f(E);
double dd;
void h() {
g(e); // will cause one call of f(char) followed
// by two calls of f(E)
g(’a’); // will cause three calls of f(char)
}
— end example ]
11 [ Note: For purposes of name lookup, default arguments of function templates and default arguments of
member functions of class templates are considered definitions (14.5). — end note ]
14.6.1 Locally declared names [temp.local]
1 Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injectedclass-name can be used with or without a template-argument-list. When it is used without a template-
§ 14.6.1 352

 c ISO/IEC N3242=11-0012
argument-list, it is equivalent to the injected-class-name followed by the template-parameters of the class
template enclosed in <>. When it is used with a template-argument-list, it refers to the specified class
template specialization, which could be the current specialization or another specialization.
2 Within the scope of a class template specialization or partial specialization, when the injected-class-name
is not followed by a <, it is equivalent to the injected-class-name followed by the template-arguments of the
class template specialization or partial specialization enclosed in <>. [ Example:
template<class T> class Y;
template<> class Y<int> {
Y* p; // meaning Y<int>
Y<char>* q; // meaning Y<char>
};
— end example ]
3 The injected-class-name of a class template or class template specialization can be used either with or without
a template-argument-list wherever it is in scope. [ Example:
template <class T> struct Base {
Base* p;
};
template <class T> struct Derived: public Base<T> {
typename Derived::Base* p; // meaning Derived::Base<T>
};
— end example ]
4 A lookup that finds an injected-class-name (10.2) can result in an ambiguity in certain cases (for example, if it
is found in more than one base class). If all of the injected-class-names that are found refer to specializations
of the same class template, and if the name is followed by a template-argument-list, the reference refers to
the class template itself and not a specialization thereof, and is not ambiguous. [ Example:
template <class T> struct Base { };
template <class T> struct Derived: Base<int>, Base<char> {
typename Derived::Base b; // error: ambiguous
typename Derived::Base<double> d; // OK
};
— end example ]
5 When the normal name of the template (i.e., the name from the enclosing scope, not the injected-class-name)
is used without a template-argument-list, it refers to the class template itself and not a specialization of the
template. [ Example:
template<class T> class X {
X* p; // meaning X<T>
X<T>* p2;
X<int>* p3;
::X* p4; // error: missing template argument list
// ::X does not refer to the injected-class-name
};
— end example ]
6 A template-parameter shall not be redeclared within its scope (including nested scopes). A templateparameter shall not have the same name as the template name. [ Example:
§ 14.6.1 353

 c ISO/IEC N3242=11-0012
template<class T, int i> class Y {
int T; // error: template-parameter redeclared
void f() {
char T; // error: template-parameter redeclared
}
};
template<class X> class X; // error: template-parameter redeclared
— end example ]
7 In the definition of a member of a class template that appears outside of the class template definition, the
name of a member of the class template hides the name of a template-parameter of any enclosing class
templates (but not a template-parameter of the member if the member is a class or function template).
[ Example:
template<class T> struct A {
struct B { /* ... */ };
typedef void C;
void f();
template<class U> void g(U);
};
template<class B> void A<B>::f() {
B b; // A’s B, not the template parameter
}
template<class B> template<class C> void A<B>::g(C) {
B b; // A’s B, not the template parameter
C c; // the template parameter C, not A’s C
}
— end example ]
8 In the definition of a member of a class template that appears outside of the namespace containing the
class template definition, the name of a template-parameter hides the name of a member of this namespace.
[ Example:
namespace N {
class C { };
template<class T> class B {
void f(T);
};
}
template<class C> void N::B<C>::f(C) {
C b; // C is the template parameter, not N::C
} —
end example ]
9 In the definition of a class template or in the definition of a member of such a template that appears outside
of the template definition, for each base class which does not depend on a template-parameter (14.6.2), if
the name of the base class or the name of a member of the base class is the same as the name of a templateparameter, the base class name or member name hides the template-parameter name (3.3.10). [ Example:
struct A {
struct B { /∗ ... ∗/ };
§ 14.6.1 354

 c ISO/IEC N3242=11-0012
int a;
int Y;
};
template<class B, class a> struct X : A {
B b; // A’s B
a b; // error: A’s a isn’t a type name
};
— end example ]
14.6.2 Dependent names [temp.dep]
1 Inside a template, some constructs have semantics which may differ from one instantiation to another. Such a
construct depends on the template parameters. In particular, types and expressions may depend on the type
and/or value of template parameters (as determined by the template arguments) and this determines the
context for name lookup for certain names. Expressions may be type-dependent (on the type of a template
parameter) or value-dependent (on the value of a non-type template parameter). In an expression of the
form:
postfix-expression ( expression-listopt)
where the postfix-expression is an id-expression, the id-expression denotes a dependent name if any of the
expressions in the expression-list is a type-dependent expression (14.6.2.2) or if the unqualified-id of the
id-expression is a template-id in which any of the template arguments depends on a template parameter.
If an operand of an operator is a type-dependent expression, the operator also denotes a dependent name.
Such names are unbound and are looked up at the point of the template instantiation (14.6.4.1) in both the
context of the template definition and the context of the point of instantiation.
2 [ Example:
template<class T> struct X : B<T> {
typename T::A* pa;
void f(B<T>* pb) {
static int i = B<T>::i;
pb->j++;
}
};
the base class name B<T>, the type name T::A, the names B<T>::i and pb->j explicitly depend on the
template-parameter. — end example ]
3 In the definition of a class or class template, if a base class depends on a template-parameter, the base class
scope is not examined during unqualified name lookup either at the point of definition of the class template
or member or during an instantiation of the class template or member. [ Example:
typedef double A;
template<class T> class B {
typedef int A;
};
template<class T> struct X : B<T> {
A a; // a has type double
};
The type name A in the definition of X<T> binds to the typedef name defined in the global namespace scope,
not to the typedef name defined in the base class B<T>. — end example ] [ Example:
§ 14.6.2 355

 c ISO/IEC N3242=11-0012
struct A {
struct B { /∗ ... ∗/ };
int a;
int Y;
};
int a;
template<class T> struct Y : T {
struct B { /∗ ... ∗/ };
B b; // The B defined in Y
void f(int i) { a = i; } // ::a
Y* p; // Y<T>
};
Y<A> ya;
The members A::B, A::a, and A::Y of the template argument A do not affect the binding of names in Y<A>.
— end example ]
14.6.2.1 Dependent types [temp.dep.type]
1 A name refers to the current instantiation if it is
— in the definition of a class template, a nested class of a class template, a member of a class template, or
a member of a nested class of a class template, the injected-class-name (Clause 9) of the class template
or nested class,
— in the definition of a primary class template or a member of a primary class template, the name of the
class template followed by the template argument list of the primary template (as described below)
enclosed in <>,
— in the definition of a nested class of a class template, the name of the nested class referenced as a
member of the current instantiation, or
— in the definition of a partial specialization or a member of a partial specialization, the name of the
class template followed by the template argument list of the partial specialization enclosed in <>. If the
nth template parameter is a parameter pack, the nth template argument is a pack expansion (14.5.3)
whose pattern is the name of the parameter pack.
2 The template argument list of a primary template is a template argument list in which the nth template
argument has the value of the nth template parameter of the class template. If the nth template parameter
is a template parameter pack (14.5.3), the nth template argument is a pack expansion (14.5.3) whose pattern
is the name of the template parameter pack.
3 A template argument that is equivalent to a template parameter (i.e., has the same constant value or the
same type as the template parameter) can be used in place of that template parameter in a reference to
the current instantiation. In the case of a non-type template argument, the argument must have been given
the value of the template parameter and not an expression in which the template parameter appears as a
subexpression. [ Example:
template <class T> class A {
A* p1; // A is the current instantiation
A<T>* p2; // A<T> is the current instantiation
A<T*> p3; // A<T*> is not the current instantiation
::A<T>* p4; // ::A<T> is the current instantiation
class B {
§ 14.6.2.1 356

 c ISO/IEC N3242=11-0012
B* p1; // B is the current instantiation
A<T>::B* p2; // A<T>::B is the current instantiation
typename A<T*>::B* p3; // A<T*>::B is not the
// current instantiation
};
};
template <class T> class A<T*> {
A<T*>* p1; // A<T*> is the current instantiation
A<T>* p2; // A<T> is not the current instantiation
};
template <class T1, class T2, int I> struct B {
B<T1, T2, I>* b1; // refers to the current instantiation
B<T2, T1, I>* b2; // not the current instantiation
typedef T1 my_T1;
static const int my_I = I;
static const int my_I2 = I+0;
static const int my_I3 = my_I;
B<my_T1, T2, my_I>* b3; // refers to the current instantiation
B<my_T1, T2, my_I2>* b4; // not the current instantiation
B<my_T1, T2, my_I3>* b5; // refers to the current instantiation
};
— end example ]
4 A name is a member of the current instantiation if it is
— An unqualified name that, when looked up, refers to a member of a class template. [ Note: This can
only occur when looking up a name in a scope enclosed by the definition of a class template. — end
note ]
— A qualified-id in which the nested-name-specifier refers to the current instantiation.
[ Example:
template <class T> class A {
static const int i = 5;
int n1[i]; // i refers to a member of the current instantiation
int n2[A::i]; // A::i refers to a member of the current instantiation
int n3[A<T>::i]; // A<T>::i refers to a member of the current instantiation
int f();
};
template <class T> int A<T>::f() {
return i; // i refers to a member of the current instantiation
}
— end example ]
5 A name is a member of an unknown specialization if the name is a qualified-id in which the nested-namespecifier names a dependent type that is not the current instantiation.
6 A type is dependent if it is
— a template parameter,
— a member of an unknown specialization,
§ 14.6.2.1 357

 c ISO/IEC N3242=11-0012
— a nested class or enumeration that is a member of the current instantiation,
— a cv-qualified type where the cv-unqualified type is dependent,
— a compound type constructed from any dependent type,
— an array type constructed from any dependent type or whose size is specified by a constant expression
that is value-dependent,
— a simple-template-id in which either the template name is a template parameter or any of the template
arguments is a dependent type or an expression that is type-dependent or value-dependent, or
— denoted by decltype(expression), where expression is type-dependent (14.6.2.2).
7 [ Note: Because typedefs do not introduce new types, but instead simply refer to other types, a name that
refers to a typedef that is a member of the current instantiation is dependent only if the type referred to is
dependent. — end note ]
14.6.2.2 Type-dependent expressions [temp.dep.expr]
1 Except as described below, an expression is type-dependent if any subexpression is type-dependent.
2 this is type-dependent if the class type of the enclosing member function is dependent (14.6.2.1).
3 An id-expression is type-dependent if it contains
— an identifier associated by name lookup with one or more declarations declared with a dependent type,
— a template-id that is dependent,
— a conversion-function-id that specifies a dependent type, or
— a nested-name-specifier or a qualified-id that names a member of an unknown specialization;
or if it names a static data member of the current instantiation that has type “array of unknown bound of
T” for some T (14.5.1.3). Expressions of the following forms are type-dependent only if the type specified by
the type-id, simple-type-specifier or new-type-id is dependent, even if any subexpression is type-dependent:
simple-type-specifier ( expression-listopt)
::opt new new-placementopt new-type-id new-initializeropt
::opt new new-placementopt( type-id ) new-initializeropt
dynamic_cast < type-id > ( expression )
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
( type-id ) cast-expression
4 Expressions of the following forms are never type-dependent (because the type of the expression cannot be
dependent):
§ 14.6.2.2 358

 c ISO/IEC N3242=11-0012
literal
postfix-expression . pseudo-destructor-name
postfix-expression -> pseudo-destructor-name
sizeof unary-expression
sizeof ( type-id )
sizeof ... ( identifier )
alignof ( type-id )
typeid ( expression )
typeid ( type-id )
::opt delete cast-expression
::opt delete [ ] cast-expression
throw assignment-expressionopt
noexcept ( expression )
[ Note: For the standard library macro offsetof, see 18.2. — end note ]
5 A class member access expression (5.2.5) is type-dependent if the type of the referenced member is dependent.
[ Note: In an expression of the form x.y or xp->y the type of the expression is usually the type of the member
y of the class of x (or the class pointed to by xp). However, if x or xp refers to a dependent type that is not
the current instantiation, the type of y is always dependent. If x or xp refers to a non-dependent type or
refers to the current instantiation, the type of y is the type of the class member access expression. — end
note ]
14.6.2.3 Value-dependent expressions [temp.dep.constexpr]
1 Except as described below, a constant expression is value-dependent if any subexpression is value-dependent.
2 An identifier is value-dependent if it is:
— a name declared with a dependent type,
— the name of a non-type template parameter,
— a constant with literal type and is initialized with an expression that is value-dependent.
Expressions of the following form are value-dependent if the unary-expression or expression is type-dependent
or the type-id is dependent:
sizeof unary-expression
sizeof ( type-id )
typeid ( expression )
typeid ( type-id )
alignof ( type-id )
noexcept ( expression )
[ Note: For the standard library macro offsetof, see 18.2. — end note ]
3 Expressions of the following form are value-dependent if either the type-id or simple-type-specifier is dependent or the expression or cast-expression is value-dependent:
simple-type-specifier ( expression-listopt)
static_cast < type-id > ( expression )
const_cast < type-id > ( expression )
reinterpret_cast < type-id > ( expression )
( type-id ) cast-expression
noexcept ( expression )
4 Expressions of the following form are value-dependent:
§ 14.6.2.3 359

 c ISO/IEC N3242=11-0012
sizeof ... ( identifier )
14.6.2.4 Dependent template arguments [temp.dep.temp]
1 A type template-argument is dependent if the type it specifies is dependent.
2 An integral non-type template-argument is dependent if the constant expression it specifies is value-dependent.
3 A non-integral non-type template-argument is dependent if its type is dependent or it has either of the
following forms
qualified-id
& qualified-id
and contains a nested-name-specifier which specifies a class-name that names a dependent type.
4 A template template-argument is dependent if it names a template-parameter or is a qualified-id with a
nested-name-specifier which contains a class-name or a decltype-specifier that denotes a dependent type.
14.6.3 Non-dependent names [temp.nondep]
1 Non-dependent names used in a template definition are found using the usual name lookup and bound at
the point they are used. [ Example:
void g(double);
void h();
template<class T> class Z {
public:
void f() {
g(1); // calls g(double)
h++; // ill-formed: cannot increment function;
// this could be diagnosed either here or
// at the point of instantiation
}
};
void g(int); // not in scope at the point of the template
// definition, not considered for the call g(1)
— end example ]
14.6.4 Dependent name resolution [temp.dep.res]
1 In resolving dependent names, names from the following sources are considered:
— Declarations that are visible at the point of definition of the template.
— Declarations from namespaces associated with the types of the function arguments both from the
instantiation context (14.6.4.1) and from the definition context.
14.6.4.1 Point of instantiation [temp.point]
1 For a function template specialization, a member function template specialization, or a specialization for a
member function or static data member of a class template, if the specialization is implicitly instantiated
because it is referenced from within another template specialization and the context from which it is referenced depends on a template parameter, the point of instantiation of the specialization is the point of
§ 14.6.4.1 360

 c ISO/IEC N3242=11-0012
instantiation of the enclosing specialization. Otherwise, the point of instantiation for such a specialization
immediately follows the namespace scope declaration or definition that refers to the specialization.
2 If a function template or member function of a class template is called in a way which uses the definition of
a default argument of that function template or member function, the point of instantiation of the default
argument is the point of instantiation of the function template or member function specialization.
3 For a class template specialization, a class member template specialization, or a specialization for a class
member of a class template, if the specialization is implicitly instantiated because it is referenced from
within another template specialization, if the context from which the specialization is referenced depends
on a template parameter, and if the specialization is not instantiated previous to the instantiation of the
enclosing template, the point of instantiation is immediately before the point of instantiation of the enclosing
template. Otherwise, the point of instantiation for such a specialization immediately precedes the namespace
scope declaration or definition that refers to the specialization.
4 If a virtual function is implicitly instantiated, its point of instantiation is immediately following the point of
instantiation of its enclosing class template specialization.
5 An explicit instantiation definition is an instantiation point for the specialization or specializations specified
by the explicit instantiation.
6 The instantiation context of an expression that depends on the template arguments is the set of declarations
with external linkage declared prior to the point of instantiation of the template specialization in the same
translation unit.
7 A specialization for a function template, a member function template, or of a member function or static
data member of a class template may have multiple points of instantiations within a translation unit.
A specialization for a class template has at most one point of instantiation within a translation unit. A
specialization for any template may have points of instantiation in multiple translation units. If two different
points of instantiation give a template specialization different meanings according to the one definition
rule (3.2), the program is ill-formed, no diagnostic required.
14.6.4.2 Candidate functions [temp.dep.candidate]
1 For a function call that depends on a template parameter, the candidate functions are found using the usual
lookup rules (3.4.1, 3.4.2, 3.4.3) except that:
— For the part of the lookup using unqualified name lookup (3.4.1) or qualified name lookup (3.4.3), only
function declarations from the template definition context are found.
— For the part of the lookup using associated namespaces (3.4.2), only function declarations found in
either the template definition context or the template instantiation context are found.
If the function name is an unqualified-id and the call would be ill-formed or would find a better match had
the lookup within the associated namespaces considered all the function declarations with external linkage
introduced in those namespaces in all translation units, not just considering those declarations found in the
template definition and template instantiation contexts, then the program has undefined behavior.
14.6.5 Friend names declared within a class template [temp.inject]
1 Friend classes or functions can be declared within a class template. When a template is instantiated, the
names of its friends are treated as if the specialization had been explicitly declared at its point of instantiation.
§ 14.6.5 361

 c ISO/IEC N3242=11-0012
2 As with non-template classes, the names of namespace-scope friend functions of a class template specialization are not visible during an ordinary lookup unless explicitly declared at namespace scope (11.3). Such
names may be found under the rules for associated classes (3.4.2).141 [ Example:
template<typename T> struct number {
number(int);
friend number gcd(number x, number y) { return 0; };
};
void g() {
number<double> a(3), b(4);
a = gcd(a,b); // finds gcd because number<double> is an
// associated class, making gcd visible
// in its namespace (global scope)
b = gcd(3,4); // ill-formed; gcd is not visible
}
— end example ]
14.7 Template instantiation and specialization [temp.spec]
1 The act of instantiating a function, a class, a member of a class template or a member template is referred
to as template instantiation.
2 A function instantiated from a function template is called an instantiated function. A class instantiated from
a class template is called an instantiated class. A member function, a member class, or a static data member
of a class template instantiated from the member definition of the class template is called, respectively, an
instantiated member function, member class or static data member. A member function instantiated from
a member function template is called an instantiated member function. A member class instantiated from
a member class template is called an instantiated member class.
3 An explicit specialization may be declared for a function template, a class template, a member of a class
template or a member template. An explicit specialization declaration is introduced by template<>. In
an explicit specialization declaration for a class template, a member of a class template or a class member
template, the name of the class that is explicitly specialized shall be a simple-template-id. In the explicit
specialization declaration for a function template or a member function template, the name of the function
or member function explicitly specialized may be a template-id. [ Example:
template<class T = int> struct A {
static int x;
};
template<class U> void g(U) { }
template<> struct A<double> { }; // specialize for T == double
template<> struct A<> { }; // specialize for T == int
template<> void g(char) { } // specialize for U == char
// U is deduced from the parameter type
template<> void g<int>(int) { } // specialize for U == int
template<> int A<char>::x = 0; // specialize for T == char
template<class T = int> struct B {
static int x;
};
template<> int B<>::x = 1; // specialize for T == int
141) Friend declarations do not introduce new names into any scope, either when the template is declared or when it is
instantiated.
§ 14.7 362

 c ISO/IEC N3242=11-0012
— end example ]
4 An instantiated template specialization can be either implicitly instantiated (14.7.1) for a given argument
list or be explicitly instantiated (14.7.2). A specialization is a class, function, or class member that is either
instantiated or explicitly specialized (14.7.3).
5 For a given template and a given set of template-arguments,
— an explicit instantiation definition shall appear at most once in a program,
— an explicit specialization shall be defined at most once in a program (according to 3.2), and
— both an explicit instantiation and a declaration of an explicit specialization shall not appear in a
program unless the explicit instantiation follows a declaration of the explicit specialization.
An implementation is not required to diagnose a violation of this rule.
6 Each class template specialization instantiated from a template has its own copy of any static members.
[ Example:
template<class T> class X {
static T s;
};
template<class T> T X<T>::s = 0;
X<int> aa;
X<char*> bb;
X<int> has a static member s of type int and X<char*> has a static member s of type char*. — end
example ]
14.7.1 Implicit instantiation [temp.inst]
1 Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),
the class template specialization is implicitly instantiated when the specialization is referenced in a context
that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program. The implicit instantiation of a class template specialization causes the implicit
instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, static data members and member templates; and it causes the implicit instantiation
of the definitions of member anonymous unions. Unless a member of a class template or a member template
has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; in
particular, the initialization (and any associated side-effects) of a static data member does not occur unless
the static data member is itself used in a way that requires the definition of the static data member to exist.
2 Unless a function template specialization has been explicitly instantiated or explicitly specialized, the function template specialization is implicitly instantiated when the specialization is referenced in a context that
requires a function definition to exist. Unless a call is to a function template explicit specialization or to a
member function of an explicitly specialized class template, a default argument for a function template or a
member function of a class template is implicitly instantiated when the function is called in a context that
requires the value of the default argument.
3 [ Example:
template<class T> struct Z {
void f();
void g();
};
§ 14.7.1 363

 c ISO/IEC N3242=11-0012
void h() {
Z<int> a; // instantiation of class Z<int> required
Z<char>* p; // instantiation of class Z<char> not required
Z<double>* q; // instantiation of class Z<double> not required
a.f(); // instantiation of Z<int>::f() required
p->g(); // instantiation of class Z<char> required, and
// instantiation of Z<char>::g() required
}
Nothing in this example requires class Z<double>, Z<int>::g(), or Z<char>::f() to be implicitly instantiated. — end example ]
4 A class template specialization is implicitly instantiated if the class type is used in a context that requires
a completely-defined object type or if the completeness of the class type might affect the semantics of the
program. [ Note: In particular, if the semantics of an expression depend on the member or base class lists
of a class template specialization, the class template specialization is implicitly generated. For instance,
deleting a pointer to class type depends on whether or not the class declares a destructor, and conversion
between pointer to class types depends on the inheritance relationship between the two classes involved.
— end note ] [ Example:
template<class T> class B { /∗ ... ∗/ };
template<class T> class D : public B<T> { /∗ ... ∗/ };
void f(void*);
void f(B<int>*);
void g(D<int>* p, D<char>* pp, D<double>* ppp) {
f(p); // instantiation of D<int> required: call f(B<int>*)
B<char>* q = pp; // instantiation of D<char> required:
// convert D<char>* to B<char>*
delete ppp; // instantiation of D<double> required
}
— end example ]
5 If the overload resolution process can determine the correct function to call without instantiating a class
template definition, it is unspecified whether that instantiation actually takes place. [ Example:
template <class T> struct S {
operator int();
};
void f(int);
void f(S<int>&);
void f(S<float>);
void g(S<int>& sr) {
f(sr); // instantiation of S<int> allowed but not required
// instantiation of S<float> allowed but not required
};
— end example ]
6 If an implicit instantiation of a class template specialization is required and the template is declared but not
defined, the program is ill-formed. [ Example:
§ 14.7.1 364

 c ISO/IEC N3242=11-0012
template<class T> class X;
X<char> ch; // error: definition of X required
— end example ]
7 The implicit instantiation of a class template does not cause any static data members of that class to be
implicitly instantiated.
8 If a function template or a member function template specialization is used in a way that involves overload
resolution, a declaration of the specialization is implicitly instantiated (14.8.3).
9 An implementation shall not implicitly instantiate a function template, a member template, a non-virtual
member function, a member class, or a static data member of a class template that does not require instantiation. It is unspecified whether or not an implementation implicitly instantiates a virtual member function
of a class template if the virtual member function would not otherwise be instantiated. The use of a template
specialization in a default argument shall not cause the template to be implicitly instantiated except that
a class template may be instantiated where its complete type is needed to determine the correctness of the
default argument. The use of a default argument in a function call causes specializations in the default
argument to be implicitly instantiated.
10 Implicitly instantiated class and function template specializations are placed in the namespace where the
template is defined. Implicitly instantiated specializations for members of a class template are placed in
the namespace where the enclosing class template is defined. Implicitly instantiated member templates are
placed in the namespace where the enclosing class or class template is defined. [ Example:
namespace N {
template<class T> class List {
public:
T* get();
};
}
template<class K, class V> class Map {
public:
N::List<V> lt;
V get(K);
};
void g(Map<const char*,int>& m) {
int i = m.get("Nicholas");
}
a call of lt.get() from Map<const char*,int>::get() would place List<int>::get() in the namespace
N rather than in the global namespace. — end example ]
11 If a function template f is called in a way that requires a default argument to be used, the dependent names
are looked up, the semantics constraints are checked, and the instantiation of any template used in the default
argument is done as if the default argument had been an initializer used in a function template specialization
with the same scope, the same template parameters and the same access as that of the function template f
used at that point. This analysis is called default argument instantiation. The instantiated default argument
is then used as the argument of f.
12 Each default argument is instantiated independently. [ Example:
template<class T> void f(T x, T y = ydef(T()), T z = zdef(T()));
§ 14.7.1 365

 c ISO/IEC N3242=11-0012
class A { };
A zdef(A);
void g(A a, A b, A c) {
f(a, b, c); // no default argument instantiation
f(a, b); // default argument z = zdef(T()) instantiated
f(a); // ill-formed; ydef is not declared
} —
end example ]
13 [ Note: 14.6.4.1 defines the point of instantiation of a template specialization. — end note ]
14 There is an implementation-defined quantity that specifies the limit on the total depth of recursive instantiations, which could involve more than one template. The result of an infinite recursion in instantiation is
undefined. [ Example:
template<class T> class X {
X<T>* p; // OK
X<T*> a; // implicit generation of X<T> requires
// the implicit instantiation of X<T*> which requires
// the implicit instantiation of X<T**> which ...
};
— end example ]
14.7.2 Explicit instantiation [temp.explicit]
1 A class, a function or member template specialization can be explicitly instantiated from its template. A
member function, member class or static data member of a class template can be explicitly instantiated from
the member definition associated with its class template. An explicit instantiation of a function template or
member function of a class template shall not use the inline or constexpr specifiers.
2 The syntax for explicit instantiation is:
explicit-instantiation:
extern
opt template declaration
There are two forms of explicit instantiation: an explicit instantiation definition and an explicit instantiation
declaration. An explicit instantiation declaration begins with the extern keyword.
3 If the explicit instantiation is for a class or member class, the elaborated-type-specifier in the declaration shall
include a simple-template-id. If the explicit instantiation is for a function or member function, the unqualifiedid in the declaration shall be either a template-id or, where all template arguments can be deduced, a
template-name or operator-function-id. [ Note: The declaration may declare a qualified-id, in which case the
unqualified-id of the qualified-id must be a template-id. — end note ] If the explicit instantiation is for a
member function, a member class or a static data member of a class template specialization, the name of
the class template specialization in the qualified-id for the member name shall be a simple-template-id. An
explicit instantiation shall appear in an enclosing namespace of its template. If the name declared in the
explicit instantiation is an unqualified name, the explicit instantiation shall appear in the namespace where
its template is declared or, if that namespace is inline (7.3.1), any namespace from its enclosing namespace
set. [ Note: Regarding qualified names in declarators, see 8.3. — end note ] [ Example:
template<class T> class Array { void mf(); };
template class Array<char>;
§ 14.7.2 366

 c ISO/IEC N3242=11-0012
template void Array<int>::mf();
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }
template void sort(Array<char>&); // argument is deduced here
namespace N {
template<class T> void f(T&) { }
}
template void N::f<int>(int&);
— end example ]
4 A declaration of a function template shall be in scope at the point of the explicit instantiation of the function
template. A definition of the class or class template containing a member function template shall be in scope
at the point of the explicit instantiation of the member function template. A definition of a class template
or class member template shall be in scope at the point of the explicit instantiation of the class template
or class member template. A definition of a class template shall be in scope at the point of an explicit
instantiation of a member function or a static data member of the class template. A definition of a member
class of a class template shall be in scope at the point of an explicit instantiation of the member class. If the
declaration of the explicit instantiation names an implicitly-declared special member function (Clause 12),
the program is ill-formed.
5 For a given set of template parameters, if an explicit instantiation of a template appears after a declaration
of an explicit specialization for that template, the explicit instantiation has no effect. Otherwise, for an
explicit instantiation definition the definition of a function template, a member function template, or a
member function or static data member of a class template shall be present in every translation unit in
which it is explicitly instantiated.
6 An explicit instantiation of a class or function template specialization is placed in the namespace in which
the template is defined. An explicit instantiation for a member of a class template is placed in the namespace
where the enclosing class template is defined. An explicit instantiation for a member template is placed in
the namespace where the enclosing class or class template is defined. [ Example:
namespace N {
template<class T> class Y { void mf() { } };
}
template class Y<int>; // error: class template Y not visible
// in the global namespace
using N::Y;
template class Y<int>; // error: explicit instantiation outside of the
// namespace of the template
template class N::Y<char*>; // OK: explicit instantiation in namespace N
template void N::Y<double>::mf(); // OK: explicit instantiation
// in namespace N
— end example ]
7 A trailing template-argument can be left unspecified in an explicit instantiation of a function template
specialization or of a member function template specialization provided it can be deduced from the type of
a function parameter (14.8.2). [ Example:
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }
§ 14.7.2 367

 c ISO/IEC N3242=11-0012
// instantiate sort(Array<int>&) - template-argument deduced
template void sort<>(Array<int>&);
— end example ]
8 An explicit instantiation that names a class template specialization is also an explicit instantiation of the
same kind (declaration or definition) of each of its members (not including members inherited from base
classes) that has not been previously explicitly specialized in the translation unit containing the explicit
instantiation, except as described below. [ Note: In addition, it will typically be an explicit instantiation of
certain implementation-dependent data about the class. — end note ]
9 An explicit instantiation definition that names a class template specialization explicitly instantiates the
class template specialization and is an explicit instantiation definition of only those members that have been
defined at the point of instantiation.
10 Except for inline functions and class template specializations, explicit instantiation declarations have the
effect of suppressing the implicit instantiation of the entity to which they refer. [ Note: The intent is that an
inline function that is the subject of an explicit instantiation declaration will still be implicitly instantiated
when odr-used (3.2) so that the body can be considered for inlining, but that no out-of-line copy of the
inline function would be generated in the translation unit. — end note ]
11 If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition
in the same translation unit, the definition shall follow the declaration. An entity that is the subject of
an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit
instantiation (14.7.1) in the translation unit shall be the subject of an explicit instantiation definition somewhere in the program; otherwise the program is ill-formed, no diagnostic required. [ Note: This rule does
apply to inline functions even though an explicit instantiation declaration of such an entity has no other
normative effect. This is needed to ensure that if the address of an inline function is taken in a translation
unit in which the implementation chose to suppress the out-of-line body, another translation unit will supply
the body. — end note ] An explicit instantiation declaration shall not name a specialization of a template
with internal linkage.
12 The usual access checking rules do not apply to names used to specify explicit instantiations. [ Note: In
particular, the template arguments and names used in the function declarator (including parameter types,
return types and exception specifications) may be private types or objects which would normally not be
accessible and the template may be a member template or member function which would not normally be
accessible. — end note ]
13 An explicit instantiation does not constitute a use of a default argument, so default argument instantiation
is not done. [ Example:
char* p = 0;
template<class T> T g(T x = &p) { return x; }
template int g<int>(int); // OK even though &p isn’t an int.
— end example ]
14.7.3 Explicit specialization [temp.expl.spec]
1 An explicit specialization of any of the following:
— function template
— class template
— member function of a class template
§ 14.7.3 368

 c ISO/IEC N3242=11-0012
— static data member of a class template
— member class of a class template
— member class template of a class or class template
— member function template of a class or class template
can be declared by a declaration introduced by template<>; that is:
explicit-specialization:
template < > declaration
[ Example:
template<class T> class stream;
template<> class stream<char> { /∗ ... ∗/ };
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }
template<> void sort<char*>(Array<char*>&) ;
Given these declarations, stream<char> will be used as the definition of streams of chars; other streams will
be handled by class template specializations instantiated from the class template. Similarly, sort<char*>
will be used as the sort function for arguments of type Array<char*>; other Array types will be sorted by
functions generated from the template. — end example ]
2 An explicit specialization shall be declared in a namespace enclosing the specialized template. An explicit
specialization whose declarator-id is not qualified shall be declared in the nearest enclosing namespace of
the template, or, if the namespace is inline (7.3.1), any namespace from its enclosing namespace set. Such a
declaration may also be a definition. If the declaration is not a definition, the specialization may be defined
later (7.3.1.2).
3 A declaration of a function template or class template being explicitly specialized shall precede the declaration
of the explicit specialization. [ Note: A declaration, but not a definition of the template is required. — end
note ] The definition of a class or class template shall precede the declaration of an explicit specialization for
a member template of the class or class template. [ Example:
template<> class X<int> { /∗ ... ∗/ }; // error: X not a template
template<class T> class X;
template<> class X<char*> { /∗ ... ∗/ }; // OK: X is a template
— end example ]
4 A member function, a member class or a static data member of a class template may be explicitly specialized
for a class specialization that is implicitly instantiated; in this case, the definition of the class template shall
precede the explicit specialization for the member of the class template. If such an explicit specialization
for the member of a class template names an implicitly-declared special member function (Clause 12), the
program is ill-formed.
5 A member of an explicitly specialized class is not implicitly instantiated from the member declaration of
the class template; instead, the member of the class template specialization shall itself be explicitly defined.
In this case, the definition of the class template explicit specialization shall be in scope at the point of
declaration of the explicit specialization of the member. The definition of an explicitly specialized class is
§ 14.7.3 369

 c ISO/IEC N3242=11-0012
unrelated to the definition of a generated specialization. That is, its members need not have the same names,
types, etc. as the members of a generated specialization. Definitions of members of an explicitly specialized
class are defined in the same manner as members of normal classes, and not using the syntax for explicit
specialization. [ Example:
template<class T> struct A {
void f(T) { /∗ ... ∗/ }
};
template<> struct A<int> {
void f(int);
};
void h() {
A<int> a;
a.f(16); // A<int>::f must be defined somewhere
}
// explicit specialization syntax not used for a member of
// explicitly specialized class template specialization
void A<int>::f(int) { /∗ ... ∗/ }
— end example ]
6 If a template, a member template or the member of a class template is explicitly specialized then that
specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. If the
program does not provide a definition for an explicit specialization and either the specialization is used in a
way that would cause an implicit instantiation to take place or the member is a virtual member function,
the program is ill-formed, no diagnostic required. An implicit instantiation is never generated for an explicit
specialization that is declared but not defined. [ Example:
class String { };
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v) { /∗ ... ∗/ }
void f(Array<String>& v) {
sort(v); // use primary template
// sort(Array<T>&), T is String
}
template<> void sort<String>(Array<String>& v); // error: specialization
// after use of primary template
template<> void sort<>(Array<char*>& v); // OK: sort<char*> not yet used
— end example ]
7 The placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member
class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member
function templates of member classes of class templates, etc., and the placement of partial specialization
declarations of class templates, member class templates of non-template classes, member class templates of
class templates, etc., can affect whether a program is well-formed according to the relative positioning of
the explicit specialization declarations and their points of instantiation in the translation unit as specified
§ 14.7.3 370

 c ISO/IEC N3242=11-0012
above and below. When writing a specialization, be careful about its location; or to make it compile will be
such a trial as to kindle its self-immolation.
8 A template explicit specialization is in the scope of the namespace in which the template was defined.
[ Example:
namespace N {
template<class T> class X { /∗ ... ∗/ };
template<class T> class Y { /∗ ... ∗/ };
template<> class X<int> { /∗ ... ∗/ }; // OK: specialization
// in same namespace
template<> class Y<double>; // forward declare intent to
// specialize for double
}
template<> class N::Y<double> { /∗ ... ∗/ }; // OK: specialization
// in same namespace
— end example ]
9 A simple-template-id that names a class template explicit specialization that has been declared but not
defined can be used exactly like the names of other incompletely-defined classes (3.9). [ Example:
template<class T> class X; // X is a class template
template<> class X<int>;
X<int>* p; // OK: pointer to declared class X<int>
X<int> x; // error: object of incomplete class X<int>
— end example ]
10 A trailing template-argument can be left unspecified in the template-id naming an explicit function template
specialization provided it can be deduced from the function argument type. [ Example:
template<class T> class Array { /∗ ... ∗/ };
template<class T> void sort(Array<T>& v);
// explicit specialization for sort(Array<int>&)
// with deduced template-argument of type int
template<> void sort(Array<int>&);
— end example ]
11 A function with the same name as a template and a type that exactly matches that of a template specialization is not an explicit specialization (14.5.6).
12 An explicit specialization of a function template is inline only if it is declared with the inline specifier or
defined as deleted, and independently of whether its function template is inline. [ Example:
template<class T> void f(T) { /∗ ... ∗/ }
template<class T> inline T g(T) { /∗ ... ∗/ }
template<> inline void f<>(int) { /∗ ... ∗/ } // OK: inline
template<> int g<>(int) { /∗ ... ∗/ } // OK: not inline
— end example ]
§ 14.7.3 371

 c ISO/IEC N3242=11-0012
13 An explicit specialization of a static data member of a template is a definition if the declaration includes an
initializer; otherwise, it is a declaration. [ Note: The definition of a static data member of a template that
requires default initialization must use a braced-init-list:
template<> X Q<int>::x; // declaration
template<> X Q<int>::x (); // error: declares a function
template<> X Q<int>::x { }; // definition
— end note ]
14 A member or a member template of a class template may be explicitly specialized for a given implicit
instantiation of the class template, even if the member or member template is defined in the class template
definition. An explicit specialization of a member or member template is specified using the syntax for
explicit specialization. [ Example:
template<class T> struct A {
void f(T);
template<class X1> void g1(T, X1);
template<class X2> void g2(T, X2);
void h(T) { }
};
// specialization
template<> void A<int>::f(int);
// out of class member template definition
template<class T> template<class X1> void A<T>::g1(T, X1) { }
// member template specialization
template<> template<class X1> void A<int>::g1(int, X1);
//member template specialization
template<> template<>
void A<int>::g1(int, char); // X1 deduced as char
template<> template<>
void A<int>::g2<char>(int, char); // X2 specified as char
// member specialization even if defined in class definition
template<> void A<int>::h(int) { }
— end example ]
15 A member or a member template may be nested within many enclosing class templates. In an explicit
specialization for such a member, the member declaration shall be preceded by a template<> for each
enclosing class template that is explicitly specialized. [ Example:
template<class T1> class A {
template<class T2> class B {
void mf();
};
};
template<> template<> class A<int>::B<double>;
template<> template<> void A<char>::B<char>::mf();
— end example ]
§ 14.7.3 372

 c ISO/IEC N3242=11-0012
16 In an explicit specialization declaration for a member of a class template or a member template that appears in namespace scope, the member template and some of its enclosing class templates may remain
unspecialized, except that the declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well. In such explicit specialization declaration, the
keyword template followed by a template-parameter-list shall be provided instead of the template<> preceding the explicit specialization declaration of the member. The types of the template-parameters in the
template-parameter-list shall be the same as those specified in the primary template definition. [ Example:
template <class T1> class A {
template<class T2> class B {
template<class T3> void mf1(T3);
void mf2();
};
};
template <> template <class X>
class A<int>::B {
template <class T> void mf1(T);
};
template <> template <> template<class T>
void A<int>::B<double>::mf1(T t) { }
template <class Y> template <>
void A<Y>::B<double>::mf2() { } // ill-formed; B<double> is specialized but
// its enclosing class template A is not
— end example ]
17 A specialization of a member function template or member class template of a non-specialized class template
is itself a template.
18 An explicit specialization declaration shall not be a friend declaration.
19 Default function arguments shall not be specified in a declaration or a definition for one of the following
explicit specializations:
— the explicit specialization of a function template;
— the explicit specialization of a member function template;
— the explicit specialization of a member function of a class template where the class template specialization to which the member function specialization belongs is implicitly instantiated. [ Note: Default
function arguments may be specified in the declaration or definition of a member function of a class
template specialization that is explicitly specialized. — end note ]
14.8 Function template specializations [temp.fct.spec]
1 A function instantiated from a function template is called a function template specialization; so is an
explicit specialization of a function template. Template arguments can be explicitly specified when naming
the function template specialization, deduced from the context (e.g., deduced from the function arguments
in a call to the function template specialization, see 14.8.2), or obtained from default template arguments.
2 Each function template specialization instantiated from a template has its own copy of any static variable.
[ Example:
template<class T> void f(T* p) {
static T s;
};
§ 14.8 373

 c ISO/IEC N3242=11-0012
void g(int a, char* b) {
f(&a); // calls f<int>(int*)
f(&b); // calls f<char*>(char**)
}
Here f<int>(int*) has a static variable s of type int and f<char*>(char**) has a static variable s of
type char*. — end example ]
14.8.1 Explicit template argument specification [temp.arg.explicit]
1 Template arguments can be specified when referring to a function template specialization by qualifying the
function template name with the list of template-arguments in the same way as template-arguments are
specified in uses of a class template specialization. [ Example:
template<class T> void sort(Array<T>& v);
void f(Array<dcomplex>& cv, Array<int>& ci) {
sort<dcomplex>(cv); // sort(Array<dcomplex>&)
sort<int>(ci); // sort(Array<int>&)
}
and
template<class U, class V> U convert(V v);
void g(double d) {
int i = convert<int,double>(d); // int convert(double)
char c = convert<char,double>(d); // char convert(double)
} —
end example ]
2 A template argument list may be specified when referring to a specialization of a function template
— when a function is called,
— when the address of a function is taken, when a function initializes a reference to function, or when a
pointer to member function is formed,
— in an explicit specialization,
— in an explicit instantiation, or
— in a friend declaration.
3 Trailing template arguments that can be deduced (14.8.2) or obtained from default template-arguments may
be omitted from the list of explicit template-arguments. A trailing template parameter pack (14.5.3) not
otherwise deduced will be deduced to an empty sequence of template arguments. If all of the template
arguments can be deduced, they may all be omitted; in this case, the empty template argument list <>
itself may also be omitted. In contexts where deduction is done and fails, or in contexts where deduction
is not done, if a template argument list is specified and it, along with any default template arguments,
identifies a single function template specialization, then the template-id is an lvalue for the function template
specialization. [ Example:
template<class X, class Y> X f(Y);
template<class X, class Y, class ... Z> X g(Y);
void h() {
int i = f<int>(5.6); // Y is deduced to be double
int j = f(5.6); // ill-formed: X cannot be deduced
§ 14.8.1 374

 c ISO/IEC N3242=11-0012
f<void>(f<int, bool>); // Y for outer f deduced to be
// int (*)(bool)
f<void>(f<int>); // ill-formed: f<int> does not denote a
// single function template specialization
int k = g<int>(5.6); // Y is deduced to be double, Z is deduced to an empty sequence
f<void>(g<int, bool>); // Y for outer f is deduced to be
// int (*)(bool), Z is deduced to an empty sequence
}
— end example ]
4 [ Note: An empty template argument list can be used to indicate that a given use refers to a specialization
of a function template even when a normal (i.e., non-template) function is visible that would otherwise be
used. For example:
template <class T> int f(T); // #1
int f(int); // #2
int k = f(1); // uses #2
int l = f<>(1); // uses #1
— end note ]
5 Template arguments that are present shall be specified in the declaration order of their corresponding
template-parameters. The template argument list shall not specify more template-arguments than there
are corresponding template-parameters unless one of the template-parameters is a template parameter pack.
[ Example:
template<class X, class Y, class Z> X f(Y,Z);
template<class ... Args> void f2();
void g() {
f<int,const char*,double>("aa",3.0);
f<int,const char*>("aa",3.0); // Z is deduced to be double
f<int>("aa",3.0); // Y is deduced to be const char*, and
// Z is deduced to be double
f("aa",3.0); // error: X cannot be deduced
f2<char, short, int, long>(); // OK
} —
end example ]
6 Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the
corresponding function parameter if the parameter type contains no template-parameters that participate
in template argument deduction. [ Note: Template parameters do not participate in template argument
deduction if they are explicitly specified. For example,
template<class T> void f(T);
class Complex {
Complex(double);
};
void g() {
f<Complex>(1); // OK, means f<Complex>(Complex(1))
} —
end note ]
§ 14.8.1 375

 c ISO/IEC N3242=11-0012
7 [ Note: Because the explicit template argument list follows the function template name, and because conversion member function templates and constructor member function templates are called without using a
function name, there is no way to provide an explicit template argument list for these function templates.
— end note ]
8 [ Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name
is not visible within the scope of the call. This is because the call still has the syntactic form of a function
call (3.4.1). But when a function template with explicit template arguments is used, the call does not have
the correct syntactic form unless there is a function template with that name visible at the point of the call.
If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not
apply. If some such name is visible, argument dependent lookup applies and additional function templates
may be found in other namespaces. [ Example:
namespace A {
struct B { };
template<int X> void f(B);
}
namespace C {
template<class T> void f(T t);
}
void g(A::B b) {
f<3>(b); // ill-formed: not a function call
A::f<3>(b); // well-formed
C::f<3>(b); // ill-formed; argument dependent lookup
// applies only to unqualified names
using C::f;
f<3>(b); // well-formed because C::f is visible; then
// A::f is found by argument dependent lookup
} —
end example ] — end note ]
9 Template argument deduction can extend the sequence of template arguments corresponding to a template
parameter pack, even when the sequence contains explicitly specified template arguments. [ Example:
template<class ... Types> void f(Types ... values);
void g() {
f<int*, float*>(0, 0, 0); // Types is deduced to the sequence int*, float*, int
} —
end example ]
14.8.2 Template argument deduction [temp.deduct]
1 When a function template specialization is referenced, all of the template arguments shall have values.
The values can be explicitly specified or, in some cases, be deduced from the use or obtained from default
template-arguments. [ Example:
void f(Array<dcomplex>& cv, Array<int>& ci) {
sort(cv); // calls sort(Array<dcomplex>&)
sort(ci); // calls sort(Array<int>&)
}
and
§ 14.8.2 376

 c ISO/IEC N3242=11-0012
void g(double d) {
int i = convert<int>(d); // calls convert<int,double>(double)
int c = convert<char>(d); // calls convert<char,double>(double)
} —
end example ]
2 When an explicit template argument list is specified, the template arguments must be compatible with the
template parameter list and must result in a valid function type as described below; otherwise type deduction fails. Specifically, the following steps are performed when evaluating an explicitly specified template
argument list with respect to a given function template:
— The specified template arguments must match the template parameters in kind (i.e., type, non-type,
template). There must not be more arguments than there are parameters unless at least one parameter
is a template parameter pack, and there shall be an argument for each non-pack parameter. Otherwise,
type deduction fails.
— Non-type arguments must match the types of the corresponding non-type template parameters, or must
be convertible to the types of the corresponding non-type parameters as specified in 14.3.2, otherwise
type deduction fails.
— The specified template argument values are substituted for the corresponding template parameters as
specified below.
3 After this substitution is performed, the function parameter type adjustments described in 8.3.5 are performed. [ Example: A parameter type of “void ()(const int, int[5])” becomes “void(*)(int,int*)”.
— end example ] [ Note: A top-level qualifier in a function parameter declaration does not affect the function
type but still affects the type of the function parameter variable within the function. — end note ] [ Example:
template <class T> void f(T t);
template <class X> void g(const X x);
template <class Z> void h(Z, Z*);
int main() {
// #1: function type is f(int), t is non const
f<int>(1);
// #2: function type is f(int), t is const
f<const int>(1);
// #3: function type is g(int), x is const
g<int>(1);
// #4: function type is g(int), x is const
g<const int>(1);
// #5: function type is h(int, const int*)
h<const int>(1,0);
} —
end example ]
4 [ Note: f<int>(1) and f<const int>(1) call distinct functions even though both of the functions called
have the same function type. — end note ]
§ 14.8.2 377

 c ISO/IEC N3242=11-0012
5 The resulting substituted and adjusted function type is used as the type of the function template for template
argument deduction. If a template argument has not been deduced, its default template argument, if any,
is used. [ Example:
template <class T, class U = double>
void f(T t = 0, U u = 0);
void g() {
f(1, ’c’); // f<int,char>(1,’c’)
f(1); // f<int,double>(1,0)
f(); // error: T cannot be deduced
f<int>(); // f<int,double>(0,0)
f<int,char>(); // f<int,char>(0,0)
} —
end example ]
When all template arguments have been deduced or obtained from default template arguments, all uses of
template parameters in the template parameter list of the template and the function type are replaced with
the corresponding deduced or default argument values. If the substitution results in an invalid type, as
described above, type deduction fails.
6 At certain points in the template argument deduction process it is necessary to take a function type that
makes use of template parameters and replace those template parameters with the corresponding template
arguments. This is done at the beginning of template argument deduction when any explicitly specified template arguments are substituted into the function type, and again at the end of template argument deduction
when any template arguments that were deduced or obtained from default arguments are substituted.
7 The substitution occurs in all types and expressions that are used in the function type and in template
parameter declarations. The expressions include not only constant expressions such as those that appear in
array bounds or as nontype template arguments but also general expressions (i.e., non-constant expressions)
inside sizeof, decltype, and other contexts that allow non-constant expressions. [ Note: The equivalent
substitution in exception specifications is done only when the function is instantiated, at which point a
program is ill-formed if the substitution results in an invalid type or expression. — end note ]
8 If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression
is one that would be ill-formed if written using the substituted arguments. Access checking is not done as
part of the substitution process. Consequently, when deduction succeeds, an access error could still result
when the function is instantiated. Only invalid types and expressions in the immediate context of the
function type and its template parameter types can result in a deduction failure. [ Note: The evaluation of
the substituted types and expressions can result in side effects such as the instantiation of class template
specializations and/or function template specializations, the generation of implicitly-defined functions, etc.
Such side effects are not in the “immediate context” and can result in the program being ill-formed. — end
note ]
[ Example:
struct X { };
struct Y {
Y(X){}
};
template <class T> auto f(T t1, T t2) -> decltype(t1 + t2); // #1
X f(Y, Y); // #2
X x1, x2;
§ 14.8.2 378

 c ISO/IEC N3242=11-0012
X x3 = f(x1, x2); // deduction fails on #1 (cannot add X+X), calls #2
— end example ]
[ Note: Type deduction may fail for the following reasons:
— Attempting to instantiate a pack expansion containing multiple parameter packs of differing lengths.
— Attempting to create an array with an element type that is void, a function type, a reference type, or
an abstract class type, or attempting to create an array with a size that is zero or negative. [ Example:
template <class T> int f(T[5]);
int I = f<int>(0);
int j = f<void>(0); // invalid array
— end example ]
— Attempting to use a type that is not a class or enumeration type in a qualified name. [ Example:
template <class T> int f(typename T::B*);
int i = f<int>(0);
— end example ]
— Attempting to use a type in a nested-name-specifier of a qualified-id when that type does not contain
the specified member, or
— the specified member is not a type where a type is required, or
— the specified member is not a template where a template is required, or
— the specified member is not a non-type where a non-type is required.
[ Example:
template <int I> struct X { };
template <template <class T> class> struct Z { };
template <class T> void f(typename T::Y*){}
template <class T> void g(X<T::N>*){}
template <class T> void h(Z<T::template TT>*){}
struct A {};
struct B { int Y; };
struct C {
typedef int N;
};
struct D {
typedef int TT;
};
int main() {
// Deduction fails in each of these cases:
f<A>(0); // A does not contain a member Y
f<B>(0); // The Y member of B is not a type
g<C>(0); // The N member of C is not a non-type
h<D>(0); // The TT member of D is not a template
} —
end example ]
— Attempting to create a pointer to reference type.
§ 14.8.2 379

 c ISO/IEC N3242=11-0012
— Attempting to create a reference to void.
— Attempting to create “pointer to member of T” when T is not a class type. [ Example:
template <class T> int f(int T::*);
int i = f<int>(0);
— end example ]
— Attempting to give an invalid type to a non-type template parameter. [ Example:
template <class T, T> struct S {};
template <class T> int f(S<T, T()>*);
struct X {};
int i0 = f<X>(0);
— end example ]
— Attempting to perform an invalid conversion in either a template argument expression, or an expression
used in the function declaration. [ Example:
template <class T, T*> int f(int);
int i2 = f<int,1>(0); // can’t conv 1 to int*
— end example ]
— Attempting to create a function type in which a parameter has a type of void, or in which the return
type is a function type or array type.
— Attempting to create a function type in which a parameter type or the return type is an abstract class
type (10.4).
— end note ]
9 Except as described above, the use of an invalid value shall not cause type deduction to fail. [ Example:
In the following example 1000 is converted to signed char and results in an implementation-defined value
as specified in (4.7). In other words, both templates are considered even though 1000, when converted to
signed char, results in an implementation-defined value.
template <int> int f(int);
template <signed char> int f(int);
int i1 = f<1>(0); // ambiguous
int i2 = f<1000>(0); // ambiguous
— end example ]
14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]
1 Template argument deduction is done by comparing each function template parameter type (call it P) with
the type of the corresponding argument of the call (call it A) as described below. If removing references
and cv-qualifiers from P gives std::initializer_list<P 0> for some P 0 and the argument is an initializer
list (8.5.4), then deduction is performed instead for each element of the initializer list, taking P 0 as a function
template parameter type and the initializer element as its argument. Otherwise, an initializer list argument
causes the parameter to be considered a non-deduced context (14.8.2.5). [ Example:
template<class T> void f(std::initializer_list<T>);
f({1,2,3}); // T deduced to int
f({1,"asdf"}); // error: T deduced to both int and const char*
§ 14.8.2.1 380

 c ISO/IEC N3242=11-0012
template<class T> void g(T);
g({1,2,3}); // error: no argument deduced for T
— end example ] For a function parameter pack that occurs at the end of the parameter-declaration-list,
the type A of each remaining argument of the call is compared with the type P of the declarator-id of the
function parameter pack. Each comparison deduces template arguments for subsequent positions in the
template parameter packs expanded by the function parameter pack. For a function parameter pack that
does not occur at the end of the parameter-declaration-list, the type of the parameter pack is a non-deduced
context. [ Example:
template<class ... Types> void f(Types& ...);
template<class T1, class ... Types> void g(T1, Types ...);
void h(int x, float& y) {
const int z = x;
f(x, y, z); // Types is deduced to int, float, const int
g(x, y, z); // T1 is deduced to int; Types is deduced to float, int
} —
end example ]
2 If P is not a reference type:
— If A is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is
used in place of A for type deduction; otherwise,
— If A is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)
is used in place of A for type deduction; otherwise,
— If A is a cv-qualified type, the top level cv-qualifiers of A’s type are ignored for type deduction.
3 If P is a cv-qualified type, the top level cv-qualifiers of P’s type are ignored for type deduction. If P is a
reference type, the type referred to by P is used for type deduction. If P is an rvalue reference to a cvunqualified template parameter and the argument is an lvalue, the type “lvalue reference to A” is used in
place of A for type deduction. [ Example:
template <class T> int f(T&&);
template <class T> int g(const T&&);
int i;
int n1 = f(i); // calls f<int&>(int&)
int n2 = f(0); // calls f<int>(int&&)
int n3 = g(i); // error: would call g<int>(const int&&), which
// would bind an rvalue reference to an lvalue
— end example ]
4 In general, the deduction process attempts to find template argument values that will make the deduced A
identical to A (after the type A is transformed as described above). However, there are three cases that allow
a difference:
— If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be
more cv-qualified than the transformed A.
— The transformed A can be another pointer or pointer to member type that can be converted to the
deduced A via a qualification conversion (4.4).
§ 14.8.2.1 381

 c ISO/IEC N3242=11-0012
— If P is a class and P has the form simple-template-id, then the transformed A can be a derived class of
the deduced A. Likewise, if P is a pointer to a class of the form simple-template-id, the transformed A
can be a pointer to a derived class pointed to by the deduced A.
5 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one
possible deduced A, the type deduction fails. [ Note: If a template-parameter is not used in any of the
function parameters of a function template, or is used only in a non-deduced context, its corresponding
template-argument cannot be deduced from a function call and the template-argument must be explicitly
specified. — end note ]
6 When P is a function type, pointer to function type, or pointer to member function type:
— If the argument is an overload set containing one or more function templates, the parameter is treated
as a non-deduced context.
— If the argument is an overload set (not containing function templates), trial argument deduction is
attempted using each of the members of the set. If deduction succeeds for only one of the overload
set members, that member is used as the argument value for the deduction. If deduction succeeds for
more than one member of the overload set the parameter is treated as a non-deduced context.
7 [ Example:
// Only one function of an overload set matches the call so the function
// parameter is a deduced context.
template <class T> int f(T (*p)(T));
int g(int);
int g(char);
int i = f(g); // calls f(int (*)(int))
— end example ]
8 [ Example:
// Ambiguous deduction causes the second function parameter to be a
// non-deduced context.
template <class T> int f(T, T (*p)(T));
int g(int);
char g(char);
int i = f(1, g); // calls f(int, int (*)(int))
— end example ]
9 [ Example:
// The overload set contains a template, causing the second function
// parameter to be a non-deduced context.
template <class T> int f(T, T (*p)(T));
char g(char);
template <class T> T g(T);
int i = f(1, g); // calls f(int, int (*)(int))
— end example ]
§ 14.8.2.1 382

 c ISO/IEC N3242=11-0012
14.8.2.2 Deducing template arguments taking the address of a function template
[temp.deduct.funcaddr]
1 Template arguments can be deduced from the type specified when taking the address of an overloaded
function (13.4). The function template’s function type and the specified type are used as the types of P and
A, and the deduction is done as described in 14.8.2.5.
14.8.2.3 Deducing conversion function template arguments [temp.deduct.conv]
1 Template argument deduction is done by comparing the return type of the conversion function template
(call it P; see 8.5, 13.3.1.5, and 13.3.1.6 for the determination of that type) with the type that is required as
the result of the conversion (call it A) as described in 14.8.2.5.
2 If P is a reference type, the type referred to by P is used in place of P for type deduction and for any further
references to or transformations of P in the remainder of this section.
3 If A is not a reference type:
— If P is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is
used in place of P for type deduction; otherwise,
— If P is a function type, the pointer type produced by the function-to-pointer standard conversion (4.3)
is used in place of P for type deduction; otherwise,
— If P is a cv-qualified type, the top level cv-qualifiers of P’s type are ignored for type deduction.
4 If A is a cv-qualified type, the top level cv-qualifiers of A’s type are ignored for type deduction. If A is a
reference type, the type referred to by A is used for type deduction.
5 In general, the deduction process attempts to find template argument values that will make the deduced A
identical to A. However, there are two cases that allow a difference:
— If the original A is a reference type, A can be more cv-qualified than the deduced A (i.e., the type
referred to by the reference)
— The deduced A can be another pointer or pointer to member type that can be converted to A via a
qualification conversion.
6 These alternatives are considered only if type deduction would otherwise fail. If they yield more than one
possible deduced A, the type deduction fails.
7 When the deduction process requires a qualification conversion for a pointer or pointer to member type as
described above, the following process is used to determine the deduced template argument values:
If A is a type
cv 1,0 “pointer to . . .” cv 1,n−1 “pointer to” cv 1,nT1
and P is a type
cv 2,0 “pointer to . . .” cv 2,n−1 “pointer to” cv 2,nT2
The cv-unqualified T1 and T2 are used as the types of A and P respectively for type deduction. [ Example:
struct A {
template <class T> operator T***();
};
A a;
const int * const * const * p1 = a; // T is deduced as int, not const int
— end example ]
§ 14.8.2.3 383

 c ISO/IEC N3242=11-0012
14.8.2.4 Deducing template arguments during partial ordering [temp.deduct.partial]
1 Template argument deduction is done by comparing certain types associated with the two function templates
being compared.
2 Two sets of types are used to determine the partial ordering. For each of the templates involved there is
the original function type and the transformed function type. [ Note: The creation of the transformed type
is described in 14.5.6.2. — end note ] The deduction process uses the transformed type as the argument
template and the original type of the other template as the parameter template. This process is done twice
for each type involved in the partial ordering comparison: once using the transformed template-1 as the
argument template and template-2 as the parameter template and again using the transformed template-2
as the argument template and template-1 as the parameter template.
3 The types used to determine the ordering depend on the context in which the partial ordering is done:
— In the context of a function call, the function parameter types are used.
— In the context of a call to a conversion operator, the return types of the conversion function templates
are used.
— In other contexts (14.5.6.2) the function template’s function type is used.
4 Each type from the parameter template and the corresponding type from the argument template are used
as the types of P and A.
5 Before the partial ordering is done, certain transformations are performed on the types used for partial
ordering:
— If P is a reference type, P is replaced by the type referred to.
— If A is a reference type, A is replaced by the type referred to.
6 If both P and A were reference types (before being replaced with the type referred to above), determine
which of the two types (if any) is more cv-qualified than the other; otherwise the types are considered to be
equally cv-qualified for partial ordering purposes. The result of this determination will be used below.
7 Remove any top-level cv-qualifiers:
— If P is a cv-qualified type, P is replaced by the cv-unqualified version of P.
— If A is a cv-qualified type, A is replaced by the cv-unqualified version of A.
8 Using the resulting types P and A the deduction is then done as described in 14.8.2.5. If deduction succeeds
for a given type, the type from the argument template is considered to be at least as specialized as the type
from the parameter template.
9 If, for a given type, deduction succeeds in both directions (i.e., the types are identical after the transformations above) and both P and A were reference types (before being replaced with the type referred to
above):
— if the type from the argument template was an lvalue reference and the type from the parameter
template was not, the argument type is considered to be more specialized than the other; otherwise,
— if the type from the argument template is more cv-qualified than the type from the parameter template
(as described above), the argument type is considered to be more specialized than the other; otherwise,
— neither type is more specialized than the other.
10 If for each type being considered a given template is at least as specialized for all types and more specialized
for some set of types and the other template is not more specialized for any types or is not at least as
§ 14.8.2.4 384

 c ISO/IEC N3242=11-0012
specialized for any types, then the given template is more specialized than the other template. Otherwise,
neither template is more specialized than the other.
11 In most cases, all template parameters must have values in order for deduction to succeed, but for partial
ordering purposes a template parameter may remain without a value provided it is not used in the types
being used for partial ordering. [ Note: A template parameter used in a non-deduced context is considered
used. — end note ] [ Example:
template <class T> T f(int); // #1
template <class T, class U> T f(U); // #2
void g() {
f<int>(1); // calls #1
} —
end example ]
12 [ Note: Partial ordering of function templates containing template parameter packs is independent of the
number of deduced arguments for those template parameter packs. — end note ] [ Example:
template<class ...> struct Tuple { };
template<class ... Types> void g(Tuple<Types ...>); // #1
template<class T1, class ... Types> void g(Tuple<T1, Types ...>); // #2
template<class T1, class ... Types> void g(Tuple<T1, Types& ...>); // #3
g(Tuple<>()); // calls #1
g(Tuple<int, float>()); // calls #2
g(Tuple<int, float&>()); // calls #3
g(Tuple<int>()); // calls #3
— end example ]
14.8.2.5 Deducing template arguments from a type [temp.deduct.type]
1 Template arguments can be deduced in several different contexts, but in each case a type that is specified
in terms of template parameters (call it P) is compared with an actual type (call it A), and an attempt is
made to find template argument values (a type for a type parameter, a value for a non-type parameter, or
a template for a template parameter) that will make P, after substitution of the deduced values (call it the
deduced A), compatible with A.
2 In some cases, the deduction is done using a single set of types P and A, in other cases, there will be a set
of corresponding types P and A. Type deduction is done independently for each P/A pair, and the deduced
template argument values are then combined. If type deduction cannot be done for any P/A pair, or if for any
pair the deduction leads to more than one possible set of deduced values, or if different pairs yield different
deduced values, or if any template argument remains neither deduced nor explicitly specified, template
argument deduction fails.
3 A given type P can be composed from a number of other types, templates, and non-type values:
— A function type includes the types of each of the function parameters and the return type.
— A pointer to member type includes the type of the class object pointed to and the type of the member
pointed to.
— A type that is a specialization of a class template (e.g., A<int>) includes the types, templates, and
non-type values referenced by the template argument list of the specialization.
— An array type includes the array element type and the value of the array bound.
§ 14.8.2.5 385

 c ISO/IEC N3242=11-0012
4 In most cases, the types, templates, and non-type values that are used to compose P participate in template
argument deduction. That is, they may be used to determine the value of a template argument, and the
value so determined must be consistent with the values determined elsewhere. In certain contexts, however,
the value does not participate in type deduction, but instead uses the values of template arguments that
were either deduced elsewhere or explicitly specified. If a template parameter is used only in non-deduced
contexts and is not explicitly specified, template argument deduction fails.
5 The non-deduced contexts are:
— The nested-name-specifier of a type that was specified using a qualified-id.
— A non-type template argument or an array bound in which a subexpression references a template
parameter.
— A template parameter used in the parameter type of a function parameter that has a default argument
that is being used in the call for which argument deduction is being done.
— A function parameter for which argument deduction cannot be done because the associated function
argument is a function, or a set of overloaded functions (13.4), and one or more of the following apply:
— more than one function matches the function parameter type (resulting in an ambiguous deduction), or
— no function matches the function parameter type, or
— the set of functions supplied as an argument contains one or more function templates.
— A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter
does not have std::initializer_list or reference to possibly cv-qualified std::initializer_list
type. [ Example:
template<class T> void g(T);
g({1,2,3}); // error: no argument deduced for T
— end example ]
— A function parameter pack that does not occur at the end of the parameter-declaration-clause.
6 When a type name is specified in a way that includes a non-deduced context, all of the types that comprise
that type name are also non-deduced. However, a compound type can include both deduced and non-deduced
types. [ Example: If a type is specified as A<T>::B<T2>, both T and T2 are non-deduced. Likewise, if a type is
specified as A<I+J>::X<T>, I, J, and T are non-deduced. If a type is specified as void f(typename A<T>::B,
A<T>), the T in A<T>::B is non-deduced but the T in A<T> is deduced. — end example ]
7 [ Example: Here is an example in which different parameter/argument pairs produce inconsistent template
argument deductions:
template<class T> void f(T x, T y) { /∗ ... ∗/ }
struct A { /∗ ... ∗/ };
struct B : A { /∗ ... ∗/ };
void g(A a, B b) {
f(a,b); // error: T could be A or B
f(b,a); // error: T could be A or B
f(a,a); // OK: T is A
f(b,b); // OK: T is B
}
Here is an example where two template arguments are deduced from a single function parameter/argument
pair. This can lead to conflicts that cause type deduction to fail:
§ 14.8.2.5 386

 c ISO/IEC N3242=11-0012
template <class T, class U> void f( T (*)( T, U, U ) );
int g1( int, float, float);
char g2( int, float, float);
int g3( int, char, float);
void r() {
f(g1); // OK: T is int and U is float
f(g2); // error: T could be char or int
f(g3); // error: U could be char or float
}
Here is an example where a qualification conversion applies between the argument type on the function call
and the deduced template argument type:
template<class T> void f(const T*) { }
int *p;
void s() {
f(p); // f(const int*)
}
Here is an example where the template argument is used to instantiate a derived class type of the corresponding function parameter type:
template <class T> struct B { };
template <class T> struct D : public B<T> {};
struct D2 : public B<int> {};
template <class T> void f(B<T>&){}
void t() {
D<int> d;
D2 d2;
f(d); // calls f(B<int>&)
f(d2); // calls f(B<int>&)
} —
end example ]
8 A template type argument T, a template template argument TT or a template non-type argument i can be
deduced if P and A have one of the following forms:
T
cv-list T
T*
T&
T&&
T[integer-constant ]
template-name <T> (where template-name refers to a class template)
type (T)
T()
T(T)
T type ::*
type T::*
T T::*
T (type ::*)()
type (T::*)()
type (type ::*)(T)
§ 14.8.2.5 387

 c ISO/IEC N3242=11-0012
type (T::*)(T)
T (type ::*)(T)
T (T::*)()
T (T::*)(T)
type [i]
template-name <i> (where template-name refers to a class template)
TT<T>
TT<i>
TT<>
where (T) represents a parameter-type-list where at least one parameter type contains a T, and () represents
a parameter-type-list where no parameter type contains a T. Similarly, <T> represents template argument
lists where at least one argument contains a T, <i> represents template argument lists where at least one
argument contains an i and <> represents template argument lists where no argument contains a T or an i.
9 If P has a form that contains <T> or <i>, then each argument Pi of the respective template argument list
P is compared with the corresponding argument Ai of the corresponding template argument list of A. If
the template argument list of P contains a pack expansion that is not the last template argument, the
entire template argument list is a non-deduced context. If Pi is a pack expansion, then the pattern of Pi
is compared with each remaining argument in the template argument list of A. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded by Pi.
10 Similarly, if P has a form that contains (T), then each parameter type Pi of the respective parameter-typelist of P is compared with the corresponding parameter type Ai of the corresponding parameter-type-list
of A. If P and A are function types that originated from deduction when taking the address of a function
template (14.8.2.2) or when deducing template arguments from a function declaration (14.8.2.6) and Pi and
Ai are parameters of the top-level parameter-type-list of P and A, respectively, Pi is adjusted if it is an rvalue
reference to a cv-unqualified template parameter and Ai is an lvalue reference, in which case the type of Pi
is changed to be the template parameter type (i.e., T&& is changed to simply T). [ Note: As a result, when
Pi is T&& and Ai is X&, the adjusted Pi will be T, causing T to be deduced as X&. — end note ] [ Example:
template <class T> void f(T&&);
template <> void f(int&) { } // #1
template <> void f(int&&) { } // #2
void g(int i) {
f(i); // calls f<int&>(int&), i.e., #1
f(0); // calls f<int>(int&&), i.e., #2
} —
end example ]
If the parameter-declaration corresponding to Pi is a function parameter pack, then the type of its declaratorid is compared with each remaining parameter type in the parameter-type-list of A. Each comparison deduces
template arguments for subsequent positions in the template parameter packs expanded by the function
parameter pack. [ Note: A function parameter pack can only occur at the end of a parameter-declarationlist (8.3.5). — end note ]
11 These forms can be used in the same way as T is for further composition of types. [ Example:
X<int> (*)(char[6])
is of the form
template-name <T> (*)(type [i])
which is a variant of
§ 14.8.2.5 388

 c ISO/IEC N3242=11-0012
type (*)(T)
where type is X<int> and T is char[6]. — end example ]
12 Template arguments cannot be deduced from function arguments involving constructs other than the ones
specified above.
13 A template type argument cannot be deduced from the type of a non-type template-argument.
14 [ Example:
template<class T, T i> void f(double a[10][i]);
int v[10][20];
f(v); // error: argument for template-parameter T cannot be deduced
— end example ]
15 [ Note: Except for reference and pointer types, a major array bound is not part of a function parameter type
and cannot be deduced from an argument:
template<int i> void f1(int a[10][i]);
template<int i> void f2(int a[i][20]);
template<int i> void f3(int (&a)[i][20]);
void g() {
int v[10][20];
f1(v); // OK: i deduced to be 20
f1<20>(v); // OK
f2(v); // error: cannot deduce template-argument i
f2<10>(v); // OK
f3(v); // OK: i deduced to be 10
}
16 If, in the declaration of a function template with a non-type template parameter, the non-type template
parameter is used in a subexpression in the function parameter list, the expression is a non-deduced context
as specified above. [ Example:
template <int i> class A { /∗ ... ∗/ };
template <int i> void g(A<i+1>);
template <int i> void f(A<i>, A<i+1>);
void k() {
A<1> a1;
A<2> a2;
g(a1); // error: deduction fails for expression i+1
g<0>(a1); // OK
f(a1, a2); // OK
}
— end example ] — end note ] [ Note: Template parameters do not participate in template argument deduction if they are used only in non-deduced contexts. For example,
template<int i, typename T>
T deduce(typename A<T>::X x, // T is not deduced here
T t, // but T is deduced here
typename B<i>::Y y); // i is not deduced here
A<int> a;
B<77> b;
§ 14.8.2.5 389

 c ISO/IEC N3242=11-0012
int x = deduce<77>(a.xm, 62, b.ym);
// T is deduced to be int, a.xm must be convertible to
// A<int>::X
// i is explicitly specified to be 77, b.ym must be convertible
// to B<77>::Y
— end note ]
17 If, in the declaration of a function template with a non-type template-parameter, the non-type templateparameter is used in an expression in the function parameter-list and, if the corresponding template-argument
is deduced, the template-argument type shall match the type of the template-parameter exactly, except that
a template-argument deduced from an array bound may be of any integral type.142 [ Example:
template<int i> class A { /∗ ... ∗/ };
template<short s> void f(A<s>);
void k1() {
A<1> a;
f(a); // error: deduction fails for conversion from int to short
f<1>(a); // OK
}
template<const short cs> class B { };
template<short s> void g(B<s>);
void k2() {
B<1> b;
g(b); // OK: cv-qualifiers are ignored on template parameter types
} —
end example ]
18 A template-argument can be deduced from a function, pointer to function, or pointer to member function
type.
[ Example:
template<class T> void f(void(*)(T,int));
template<class T> void foo(T,int);
void g(int,int);
void g(char,int);
void h(int,int,int);
void h(char,int);
int m() {
f(&g); // error: ambiguous
f(&h); // OK: void h(char,int) is a unique match
f(&foo); // error: type deduction fails because foo is a template
} —
end example ]
19 A template type-parameter cannot be deduced from the type of a function default argument. [ Example:
template <class T> void f(T = 5, T = 7);
142) Although the template-argument corresponding to a template-parameter of type bool may be deduced from an array
bound, the resulting value will always be true because the array bound will be non-zero.
§ 14.8.2.5 390

 c ISO/IEC N3242=11-0012
void g() {
f(1); // OK: call f<int>(1,7)
f(); // error: cannot deduce T
f<int>(); // OK: call f<int>(5,7)
} —
end example ]
20 The template-argument corresponding to a template template-parameter is deduced from the type of the
template-argument of a class template specialization used in the argument list of a function call. [ Example:
template <template <class T> class X> struct A { };
template <template <class T> class X> void f(A<X>) { }
template<class T> struct B { };
A<B> ab;
f(ab); // calls f(A<B>)
— end example ]
21 [ Note: Template argument deduction involving parameter packs (14.5.3) can deduce zero or more arguments
for each parameter pack. — end note ] [ Example:
template<class> struct X { };
template<class R, class ... ArgTypes> struct X<R(int, ArgTypes ...)> { };
template<class ... Types> struct Y { };
template<class T, class ... Types> struct Y<T, Types& ...> { };
template<class ... Types> int f(void (*)(Types ...));
void g(int, float);
X<int> x1; // uses primary template
X<int(int, float, double)> x2; // uses partial specialization; ArgTypes contains float, double
X<int(float, int)> x3; // uses primary template
Y<> y1; // use primary template; Types is empty
Y<int&, float&, double&> y2; // uses partial specialization; T is int&, Types contains float, double
Y<int, float, double> y3; // uses primary template; Types contains int, float, double
int fv = f(g); // OK; Types contains int, float
— end example ]
22 If the original function parameter associated with A is a function parameter pack and the function parameter
associated with P is not a function parameter pack, then template argument deduction fails. [ Example:
template<class ... Args> void f(Args ... args); // #1
template<class T1, class ... Args> void f(T1 a1, Args ... args); // #2
template<class T1, class T2> void f(T1 a1, T2 a2); // #3
f(); // calls #1
f(1, 2, 3); // calls #2
f(1, 2); // calls #3; non-variadic template #3 is more
// specialized than the variadic templates #1 and #2
— end example ]
§ 14.8.2.5 391

 c ISO/IEC N3242=11-0012
14.8.2.6 Deducing template arguments from a function declaration [temp.deduct.decl]
1 In a declaration whose declarator-id refers to a specialization of a function template, template argument
deduction is performed to identify the specialization to which the declaration refers. Specifically, this is done
for explicit instantiations (14.7.2), explicit specializations (14.7.3), and certain friend declarations (14.5.4).
This is also done to determine whether a function template specialization matches a placement operator
new (3.7.4.2, 5.3.4). In all these cases, P is the type of the function template being considered as a potential
match and A is the function type from the declaration. The deduction is done as described in 14.8.2.5.
2 If, for the set of function templates so considered, there is either no match or more than one match after
partial ordering has been considered (14.5.6.2), deduction fails and the declaration is ill-formed.
14.8.3 Overload resolution [temp.over]
1 A function template can be overloaded either by (non-template) functions of its name or by (other) function
templates of the same name. When a call to that name is written (explicitly, or implicitly using the operator
notation), template argument deduction (14.8.2) and checking of any explicit template arguments (14.3) are
performed for each function template to find the template argument values (if any) that can be used with
that function template to instantiate a function template specialization that can be invoked with the call
arguments. For each function template, if the argument deduction and checking succeeds, the templatearguments (deduced and/or explicit) are used to synthesize the declaration of a single function template
specialization which is added to the candidate functions set to be used in overload resolution. If, for a given
function template, argument deduction fails, no such function is added to the set of candidate functions for
that template. The complete set of candidate functions includes all the synthesized declarations and all of
the non-template overloaded functions of the same name. The synthesized declarations are treated like any
other functions in the remainder of overload resolution, except as explicitly noted in 13.3.3.143
[ Example:
template<class T> T max(T a, T b) { return a>b?a:b; }
void f(int a, int b, char c, char d) {
int m1 = max(a,b); // max(int a, int b)
char m2 = max(c,d); // max(char a, char b)
int m3 = max(a,c); // error: cannot generate max(int,char)
}
2 Adding the non-template function
int max(int,int);
to the example above would resolve the third call, by providing a function that could be called for max(a,c)
after using the standard conversion of char to int for c.
3 Here is an example involving conversions on a function argument involved in template-argument deduction:
template<class T> struct B { /∗ ... ∗/ };
template<class T> struct D : public B<T> { /∗ ... ∗/ };
template<class T> void f(B<T>&);
void g(B<int>& bi, D<int>& di) {
143) The parameters of function template specializations contain no template parameter types. The set of conversions allowed
on deduced arguments is limited, because the argument deduction process produces function templates with parameters that
either match the call arguments exactly or differ only in ways that can be bridged by the allowed limited conversions. Nondeduced arguments allow the full range of conversions. Note also that 13.3.3 specifies that a non-template function will be given
preference over a template specialization if the two functions are otherwise equally good candidates for an overload match.
§ 14.8.3 392

 c ISO/IEC N3242=11-0012
f(bi); // f(bi)
f(di); // f((B<int>&)di)
}
4 Here is an example involving conversions on a function argument not involved in template-parameter deduction:
template<class T> void f(T*,int); // #1
template<class T> void f(T,char); // #2
void h(int* pi, int i, char c) {
f(pi,i); // #1: f<int>(pi,i)
f(pi,c); // #2: f<int*>(pi,c)
f(i,c); // #2: f<int>(i,c);
f(i,i); // #2: f<int>(i,char(i))
} —
end example ]
5 Only the signature of a function template specialization is needed to enter the specialization in a set of
candidate functions. Therefore only the function template declaration is needed to resolve a call for which
a template specialization is a candidate. [ Example:
template<class T> void f(T); // declaration
void g() {
f("Annemarie"); // call of f<const char*>
}
6 The call of f is well-formed even if the template f is only declared and not defined at the point of the call.
The program will be ill-formed unless a specialization for f<const char*>, either implicitly or explicitly
generated, is present in some translation unit. — end example ]
§ 14.8.3 393

 c ISO/IEC N3242=11-0012
15 Exception handling [except]
1 Exception handling provides a way of transferring control and information from a point in the execution of a
program to an exception handler associated with a point previously passed by the execution. A handler will
be invoked only by a throw-expression invoked in code executed in the handler’s try block or in functions
called from the handler’s try block .
try-block:
try compound-statement handler-seq
function-try-block:
try ctor-initializeropt compound-statement handler-seq
handler-seq:
handler handler-seqopt
handler:
catch ( exception-declaration ) compound-statement
exception-declaration:
attribute-specifier-seqopt type-specifier-seq declarator
attribute-specifier-seqopt type-specifier-seq abstract-declaratoropt
...
throw-expression:
throw assignment-expressionopt
The optional attribute-specifier-seq in an exception-declaration appertains to the formal parameter of the
catch clause (15.3).
2 A try-block is a statement (Clause 6). A throw-expression is of type void. Code that executes a throwexpression is said to “throw an exception;” code that subsequently gets control is called a “handler.” [Note:
Within this Clause “try block” is taken to mean both try-block and function-try-block. — end note ]
3 A goto or switch statement shall not be used to transfer control into a try block or into a handler.
[ Example:
void f() {
goto l1; // Ill-formed
goto l2; // Ill-formed
try {
goto l1; // OK
goto l2; // Ill-formed
l1: ;
} catch (...) {
l2: ;
goto l1; // Ill-formed
goto l2; // OK
}
} —
end example ] A goto, break, return, or continue statement can be used to transfer control out of a
try block or handler. When this happens, each variable declared in the try block will be destroyed in the
context that directly contains its declaration. [ Example:
394

 c ISO/IEC N3242=11-0012
lab: try {
T1 t1;
try {
T2 t2;
if (condition)
goto lab;
} catch(...) { /∗ handler 2 ∗/ }
} catch(...) { /∗ handler 1 ∗/ }
Here, executing goto lab; will destroy first t2, then t1, assuming the condition does not declare a variable.
Any exception raised while destroying t2 will result in executing handler 2; any exception raised while
destroying t1 will result in executing handler 1. — end example ]
4 A function-try-block associates a handler-seq with the ctor-initializer, if present, and the compound-statement.
An exception thrown during the execution of the initializer expressions in the ctor-initializer or during the
execution of the compound-statement transfers control to a handler in a function-try-block in the same way
as an exception thrown during the execution of a try-block transfers control to other handlers. [ Example:
int f(int);
class C {
int i;
double d;
public:
C(int, double);
};
C::C(int ii, double id)
try : i(f(ii)), d(id) {
// constructor statements
}
catch (...) {
// handles exceptions thrown from the ctor-initializer
// and from the constructor statements
}
— end example ]
15.1 Throwing an exception [except.throw]
1 Throwing an exception transfers control to a handler. An object is passed and the type of that object
determines which handlers can catch it. [ Example:
throw "Help!";
can be caught by a handler of const char* type:
try {
// ...
}
catch(const char* p) {
// handle character string exceptions here
}
and
class Overflow {
public:
§ 15.1 395

 c ISO/IEC N3242=11-0012
Overflow(char,double,double);
};
void f(double x) {
throw Overflow(’+’,x,3.45e107);
}
can be caught by a handler for exceptions of type Overflow
try {
f(1.2);
} catch(Overflow& oo) {
// handle exceptions of type Overflow here
} —
end example ]
2 When an exception is thrown, control is transferred to the nearest handler with a matching type (15.3);
“nearest” means the handler for which the compound-statement or ctor-initializer following the try keyword
was most recently entered by the thread of control and not yet exited.
3 A throw-expression initializes a temporary object, called the exception object, the type of which is determined
by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type
from “array of T” or “function returning T” to “pointer to T” or “pointer to function returning T”, respectively.
The temporary is an lvalue and is used to initialize the variable named in the matching handler (15.3). If
the type of the exception object would be an incomplete type or a pointer to an incomplete type other
than (possibly cv-qualified) void the program is ill-formed. Except for these restrictions and the restrictions
on type matching mentioned in 15.3, the operand of throw is treated exactly as a function argument in a
call (5.2.2) or the operand of a return statement.
4 The memory for the exception object is allocated in an unspecified way, except as noted in 3.7.4.1. If a
handler exits by rethrowing, control is passed to another handler for the same exception. The exception
object is destroyed after either the last remaining active handler for the exception exits by any means other
than rethrowing, or the last object of type std::exception_ptr (18.8.5) that refers to the exception object is
destroyed, whichever is later. In the former case, the destruction occurs when the handler exits, immediately
after the destruction of the object declared in the exception-declaration in the handler, if any. In the latter
case, the destruction occurs before the destructor of std::exception_ptr returns. The implementation
may then deallocate the memory for the exception object; any such deallocation is done in an unspecified
way.
5 When the thrown object is a class object, the copy/move constructor and the destructor shall be accessible,
even if the copy/move operation is elided (12.8).
6 An exception is considered caught when a handler for that exception becomes active (15.3). [ Note: An
exception can have active handlers and still be considered uncaught if it is rethrown. — end note ]
7 If the exception handling mechanism, after completing evaluation of the expression to be thrown but before
the exception is caught, calls a function that exits via an exception, std::terminate is called (15.5.1).
[ Example:
struct C {
C() { }
C(const C&) { throw 0; }
};
int main() {
§ 15.1 396

 c ISO/IEC N3242=11-0012
try {
throw C(); // calls std::terminate()
} catch(C) { }
} —
end example ]
8 A throw-expression with no operand rethrows the currently handled exception (15.3). The exception is
reactivated with the existing temporary; no new temporary exception object is created. The exception is
no longer considered to be caught; therefore, the value of std::uncaught_exception() will again be true.
[ Example: code that must be executed because of an exception yet cannot completely handle the exception
can be written like this:
try {
// ...
} catch (...) { // catch all exceptions
// respond (partially) to exception
throw; // pass the exception to some
// other handler
}
— end example ]
9 If no exception is presently being handled, executing a throw-expression with no operand calls std::
terminate() (15.5.1).
15.2 Constructors and destructors [except.ctor]
1 As control passes from a throw-expression to a handler, destructors are invoked for all automatic objects
constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the
completion of their construction.
2 An object of any storage duration whose initialization or destruction is terminated by an exception will
have destructors executed for all of its fully constructed subobjects (excluding the variant members of a
union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution
and the destructor has not yet begun execution. Similarly, if the non-delegating constructor for an object
has completed execution and a delegating constructor for that object exits with an exception, the object’s
destructor will be invoked. If the object was allocated in a new-expression, the matching deallocation
function (3.7.4.2, 5.3.4, 12.5), if any, is called to free the storage occupied by the object.
3 The process of calling destructors for automatic objects constructed on the path from a try block to a
throw-expression is called “stack unwinding.” If a destructor called during stack unwinding exits with an
exception, std::terminate is called (15.5.1). [ Note: So destructors should generally catch exceptions and
not let them propagate out of the destructor. — end note ]
15.3 Handling an exception [except.handle]
1 The exception-declaration in a handler describes the type(s) of exceptions that can cause that handler to
be entered. The exception-declaration shall not denote an incomplete type or an rvalue reference type. The
exception-declaration shall not denote a pointer or reference to an incomplete type, other than void*, const
void*, volatile void*, or const volatile void*.
2 A handler of type “array of T” or “function returning T” is adjusted to be of type “pointer to T” or “pointer
to function returning T”, respectively.
3 A handler is a match for an exception object of type E if
§ 15.3 397

 c ISO/IEC N3242=11-0012
— The handler is of type cv T or cv T& and E and T are the same type (ignoring the top-level cv-qualifiers),
or
— the handler is of type cv T or cv T& and T is an unambiguous public base class of E, or
— the handler is of type cv1 T* cv2 and E is a pointer type that can be converted to the type of the
handler by either or both of
— a standard pointer conversion (4.10) not involving conversions to pointers to private or protected
or ambiguous classes
— a qualification conversion
— the handler is a pointer or pointer to member type and E is std::nullptr_t.
[ Note: A throw-expression whose operand is an integral constant expression of integer type that evaluates
to zero does not match a handler of pointer or pointer to member type. — end note ]
[ Example:
class Matherr { /∗ ... ∗/ virtual void vf(); };
class Overflow: public Matherr { /∗ ... ∗/ };
class Underflow: public Matherr { /∗ ... ∗/ };
class Zerodivide: public Matherr { /∗ ... ∗/ };
void f() {
try {
g();
} catch (Overflow oo) {
// ...
} catch (Matherr mm) {
// ...
}
}
Here, the Overflow handler will catch exceptions of type Overflow and the Matherr handler will catch
exceptions of type Matherr and of all types publicly derived from Matherr including exceptions of type
Underflow and Zerodivide. — end example ]
4 The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that
can never be executed, for example by placing a handler for a derived class after a handler for a corresponding
base class.
5 A ... in a handler’s exception-declaration functions similarly to ... in a function parameter declaration;
it specifies a match for any exception. If present, a ... handler shall be the last handler for its try block.
6 If no match is found among the handlers for a try block, the search for a matching handler continues in a
dynamically surrounding try block.
7 A handler is considered active when initialization is complete for the formal parameter (if any) of the catch
clause. [ Note: The stack will have been unwound at that point. — end note ] Also, an implicit handler
is considered active when std::terminate() or std::unexpected() is entered due to a throw. A handler
is no longer considered active when the catch clause exits or when std::unexpected() exits after being
entered due to a throw.
8 The exception with the most recently activated handler that is still active is called the currently handled
exception.
§ 15.3 398

 c ISO/IEC N3242=11-0012
9 If no matching handler is found, the function std::terminate() is called; whether or not the stack is
unwound before this call to std::terminate() is implementation-defined (15.5.1).
10 Referring to any non-static member or base class of an object in the handler for a function-try-block of a
constructor or destructor for that object results in undefined behavior.
11 The fully constructed base classes and members of an object shall be destroyed before entering the handler
of a function-try-block of a constructor for that object. Similarly, if a delegating constructor for an object
exits with an exception after the non-delegating constructor for that object has completed execution, the
object’s destructor shall be executed before entering the handler of a function-try-block of a constructor for
that object. The base classes and non-variant members of an object shall be destroyed before entering the
handler of a function-try-block of a destructor for that object (12.4).
12 The scope and lifetime of the parameters of a function or constructor extend into the handlers of a functiontry-block.
13 Exceptions thrown in destructors of objects with static storage duration or in constructors of namespacescope objects with static storage duration are not caught by a function-try-block on main(). Exceptions
thrown in destructors of objects with thread storage duration or in constructors of namespace-scope objects
with thread storage duration are not caught by a function-try-block on the initial function of the thread.
14 If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed.
15 The currently handled exception is rethrown if control reaches the end of a handler of the function-try-block
of a constructor or destructor. Otherwise, a function returns when control reaches the end of a handler for
the function-try-block (6.6.3). Flowing off the end of a function-try-block is equivalent to a return with no
value; this results in undefined behavior in a value-returning function (6.6.3).
16 The object declared in an exception-declaration or, if the exception-declaration does not specify a name, a
temporary (12.2) is copy-initialized (8.5) from the exception object. The object shall not have an abstract
class type. The object is destroyed when the handler exits, after the destruction of any automatic objects
initialized within the handler.
17 When the handler declares a non-constant object, any changes to that object will not affect the temporary
object that was initialized by execution of the throw-expression. When the handler declares a reference to
a non-constant object, any changes to the referenced object are changes to the temporary object initialized
when the throw-expression was executed and will have effect should that object be rethrown.
15.4 Exception specifications [except.spec]
1 A function declaration lists exceptions that its function might directly or indirectly throw by using an
exception-specification as a suffix of its declarator.
exception-specification:
dynamic-exception-specification
noexcept-specification
dynamic-exception-specification:
throw ( type-id-listopt)
type-id-list:
type-id ...opt
type-id-list , type-id ...opt
§ 15.4 399

 c ISO/IEC N3242=11-0012
noexcept-specification:
noexcept ( constant-expression )
noexcept
In a noexcept-specification, the constant-expression, if supplied, shall be a constant expression (5.19) that is
contextually converted to bool (Clause 4). A noexcept-specification noexcept is equivalent to noexcept(true).
2 An exception-specification shall appear only on a function declarator for a function type, pointer to function
type, reference to function type, or pointer to member function type that is the top-level type of a declaration
or definition, or on such a type appearing as a parameter or return type in a function declarator. An
exception-specification shall not appear in a typedef declaration or alias-declaration. [ Example:
void f() throw(int); // OK
void (*fp)() throw (int); // OK
void g(void pfa() throw(int)); // OK
typedef int (*pf)() throw(int); // ill-formed
— end example ] A type denoted in an exception-specification shall not denote an incomplete type. A type
denoted in an exception-specification shall not denote a pointer or reference to an incomplete type, other
than void*, const void*, volatile void*, or const volatile void*. A type cv T, “array of T”, or
“function returning T” denoted in an exception-specification is adjusted to type T, “pointer to T”, or “pointer
to function returning T”, respectively.
3 Two exception-specifications are compatible if:
— both are non-throwing (see below), regardless of their form,
— both have the form noexcept(constant-expression) and the constant-expressions are equivalent,
— one exception-specification is a noexcept-specification allowing all exceptions and the other is of the
form throw(type-id-list), or
— both are dynamic-exception-specifications that have the same set of adjusted types.
4 If any declaration of a function has an exception-specification that is not a noexcept-specification allowing
all exceptions, all declarations, including the definition and any explicit specialization, of that function shall
have a compatible exception-specification. If any declaration of a pointer to function, reference to function,
or pointer to member function has an exception-specification, all occurrences of that declaration shall have
a compatible exception-specification In an explicit instantiation an exception-specification may be specified,
but is not required. If an exception-specification is specified in an explicit instantiation directive, it shall be
compatible with the exception-specifications of other declarations of that function. A diagnostic is required
only if the exception-specifications are not compatible within a single translation unit.
5 If a virtual function has an exception-specification, all declarations, including the definition, of any function
that overrides that virtual function in any derived class shall only allow exceptions that are allowed by the
exception-specification of the base class virtual function. [ Example:
struct B {
virtual void f() throw (int, double);
virtual void g();
};
struct D: B {
void f(); // ill-formed
void g() throw (int); // OK
};
§ 15.4 400

 c ISO/IEC N3242=11-0012
The declaration of D::f is ill-formed because it allows all exceptions, whereas B::f allows only int and
double. — end example ] A similar restriction applies to assignment to and initialization of pointers to
functions, pointers to member functions, and references to functions: the target entity shall allow at least
the exceptions allowed by the source value in the assignment or initialization. [ Example:
class A { /∗ ... ∗/ };
void (*pf1)(); // no exception specification
void (*pf2)() throw(A);
void f() {
pf1 = pf2; // OK: pf1 is less restrictive
pf2 = pf1; // error: pf2 is more restrictive
}
— end example ]
6 In such an assignment or initialization, exception-specifications on return types and parameter types shall
be compatible. In other assignments or initializations, exception-specifications shall be compatible.
7 An exception-specification can include the same type more than once and can include classes that are related
by inheritance, even though doing so is redundant. [ Note: An exception-specification can also include the
class std::bad_exception (18.8.2). — end note ]
8 A function is said to allow an exception of type E if its dynamic-exception-specification contains a type T for
which a handler of type T would be a match (15.3) for an exception of type E.
9 Whenever an exception is thrown and the search for a handler (15.3) encounters the outermost block of a
function with an exception-specification that does not allow the exception, then,
— if the exception-specification is a dynamic-exception-specification, the function std::unexpected() is
called (15.5.2),
— otherwise, the function std::terminate() is called (15.5.1).
[ Example:
class X { };
class Y { };
class Z: public X { };
class W { };
void f() throw (X, Y) {
int n = 0;
if (n) throw X(); // OK
if (n) throw Z(); // also OK
throw W(); // will call std::unexpected()
} —
end example ]
10 The function unexpected() may throw an exception that will satisfy the exception-specification for which
it was invoked, and in this case the search for another handler will continue at the call of the function with
this exception-specification (see 15.5.2), or it may call std::terminate().
11 An implementation shall not reject an expression merely because when executed it throws or might throw
an exception that the containing function does not allow. [ Example:
extern void f() throw(X, Y);
§ 15.4 401

 c ISO/IEC N3242=11-0012
void g() throw(X) {
f(); // OK
}
the call to f is well-formed even though when called, f might throw exception Y that g does not allow.
— end example ]
12 A function with no exception-specification or with an exception-specification of the form noexcept(constantexpression ) where the constant-expression yields false allows all exceptions. An exception-specification is
non-throwing if it is of the form throw(), noexcept, or noexcept(constant-expression ) where the constantexpression yields true. A function with a non-throwing exception-specification does not allow any exceptions.
13 An exception-specification is not considered part of a function’s type.
14 An implicitly declared special member function (Clause 12) shall have an exception-specification. If f is
an implicitly declared default constructor, copy constructor, move constructor, destructor, copy assignment
operator, or move assignment operator, its implicit exception-specification specifies the type-id T if and only
if T is allowed by the exception-specification of a function directly invoked by f’s implicit definition; f shall
allow all exceptions if any function it directly invokes allows all exceptions, and f shall allow no exceptions
if every function it directly invokes allows no exceptions. [ Example:
struct A {
A();
A(const A&) throw();
A(A&&) throw();
~A() throw(X);
};
struct B {
B() throw();
B(const B&) throw();
B(B&&) throw(Y);
~B() throw(Y);
};
struct D : public A, public B {
// Implicit declaration of D::D();
// Implicit declaration of D::D(const D&) throw();
// Implicit declaration of D::D(D&&) throw(Y);
// Implicit declaration of D::∼D() throw(X, Y);
};
Furthermore, if A::˜A() or B::˜B() were virtual, D::˜D() would not be as restrictive as that of A::˜A, and
the program would be ill-formed since a function that overrides a virtual function from a base class shall
have an exception-specification at least as restrictive as that in the base class. — end example ]
15 A deallocation function (3.7.4.2) with no explicit exception-specification is treated as if it were specified with
noexcept(true).
16 In a dynamic-exception-specification, a type-id followed by an ellipsis is a pack expansion (14.5.3).
17 [ Note: The use of dynamic-exception-specifications is deprecated (see Annex D). — end note ]
15.5 Special functions [except.special]
1 The functions std::terminate() (15.5.1) and std::unexpected() (15.5.2) are used by the exception handling mechanism for coping with errors related to the exception handling mechanism itself. The function
§ 15.5 402

 c ISO/IEC N3242=11-0012
std::current_exception() (18.8.5) and the class std::nested_exception (18.8.6) can be used by a program to capture the currently handled exception.
15.5.1 The std::terminate() function [except.terminate]
1 In some situations exception handling must be abandoned for less subtle error handling techniques. [ Note:
These situations are:
— when the exception handling mechanism, after completing the initialization of the exception object
but before activation of a handler for the exception (15.1), calls a function that exits via an exception,
or
— when the exception handling mechanism cannot find a handler for a thrown exception (15.3), or
— when the search for a handler (15.3) encounters the outermost block of a function with a noexceptspecification that does not allow the exception (15.4), or
— when the destruction of an object during stack unwinding (15.2) terminates by throwing an exception,
or
— when initialization of a non-local variable with static or thread storage duration (3.6.2) exits via an
exception, or
— when destruction of an object with static or thread storage duration exits via an exception (3.6.3), or
— when execution of a function registered with std::atexit or std::at_quick_exit exits via an exception (18.5), or
— when a throw-expression with no operand attempts to rethrow an exception and no exception is being
handled (15.1), or
— when std::unexpected throws an exception which is not allowed by the previously violated dynamicexception-specification, and std::bad_exception is not included in that dynamic-exception-specification (15.5.2),
or
— when the implementation’s default unexpected exception handler is called (D.11.1), or
— when the function std::nested_exception::rethrow_nested is called for an object that has captured
no exception (18.8.6), or
— when execution of the initial function of a thread exits via an exception (30.3.1.2), or
— when the destructor or the copy assignment operator is invoked on an object of type std::thread
that refers to a joinable thread (30.3.1.3, 30.3.1.4).
— end example ]
2 In such cases, std::terminate() is called (18.8.3). In the situation where no matching handler is found,
it is implementation-defined whether or not the stack is unwound before std::terminate() is called. In
the situation where the search for a handler (15.3) encounters the outermost block of a function with a
noexcept-specification that does not allow the exception (15.4), it is implementation-defined whether the
stack is unwound, unwound partially, or not unwound at all before std::terminate() is called. In all other
situations, the stack shall not be unwound before std::terminate() is called. An implementation is not
permitted to finish stack unwinding prematurely based on a determination that the unwind process will
eventually cause a call to std::terminate().
§ 15.5.1 403

 c ISO/IEC N3242=11-0012
15.5.2 The std::unexpected() function [except.unexpected]
1 If a function with a dynamic-exception-specification throws an exception that is not listed in the dynamicexception-specification, the function std::unexpected() is called (D.11) immediately after completing the
stack unwinding for the former function.
2 [ Note: By default, std::unexpected() calls std::terminate(), but a program can install its own handler
function (D.11.2). In either case, the constraints in the following paragraph apply. — end note ]
3 The std::unexpected() function shall not return, but it can throw (or re-throw) an exception. If it
throws a new exception which is allowed by the exception specification which previously was violated, then
the search for another handler will continue at the call of the function whose exception specification was
violated. If it throws or rethrows an exception that the dynamic-exception-specification does not allow
then the following happens: If the dynamic-exception-specification does not include the class std::bad_-
exception (18.8.2) then the function std::terminate() is called, otherwise the thrown exception is replaced
by an implementation-defined object of the type std::bad_exception and the search for another handler
will continue at the call of the function whose dynamic-exception-specification was violated.
4 Thus, a dynamic-exception-specification guarantees that only the listed exceptions will be thrown. If the
dynamic-exception-specification includes the type std::bad_exception then any exception not on the list
may be replaced by std::bad_exception within the function std::unexpected().
15.5.3 The std::uncaught_exception() function [except.uncaught]
1 The function std::uncaught_exception() returns true after completing the initialization of the exception
object (15.1) until completing the activation of a handler for the exception (15.3, 18.8.4). This includes stack
unwinding. If the exception is rethrown (15.1), std::uncaught_exception() returns true from the point
of rethrow until the rethrown exception is caught again.
§ 15.5.3 404

 c ISO/IEC N3242=11-0012
16 Preprocessing directives [cpp]
1 A preprocessing directive consists of a sequence of preprocessing tokens that satisfies the following constraints:
The first token in the sequence is a # preprocessing token that (at the start of translation phase 4) is either
the first character in the source file (optionally after white space containing no new-line characters) or that
follows white space containing at least one new-line character. The last token in the sequence is the first newline character that follows the first token in the sequence.144 A new-line character ends the preprocessing
directive even if it occurs within what would otherwise be an invocation of a function-like macro.
preprocessing-file:
groupopt
group:
group-part
group group-part
group-part:
if-section
control-line
text-line
# non-directive
if-section:
if-group elif-groupsopt else-groupopt endif-line
if-group:
# if constant-expression new-line groupopt
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt
elif-groups:
elif-group
elif-groups elif-group
elif-group:
# elif constant-expression new-line groupopt
else-group:
# else new-line groupopt
endif-line:
# endif new-line
144) Thus, preprocessing directives are commonly called “lines.” These “lines” have no other syntactic significance, as all white
space is equivalent except in certain situations during preprocessing (see the # character string literal creation operator in 16.3.2,
for example).
405

 c ISO/IEC N3242=11-0012
control-line:
# include pp-tokens new-line
# define identifier replacement-list new-line
# define identifier lparen identifier-listopt) replacement-list new-line
# define identifier lparen ... ) replacement-list new-line
# define identifier lparen identifier-list, ... ) replacement-list new-line
# undef identifier new-line
# line pp-tokens new-line
# error pp-tokensopt new-line
# pragma pp-tokensopt new-line
# new-line
text-line:
pp-tokensopt new-line
non-directive:
pp-tokens new-line
lparen:
a ( character not immediately preceded by white-space
identifier-list:
identifier
identifier-list , identifier
replacement-list:
pp-tokensopt
pp-tokens:
preprocessing-token
pp-tokens preprocessing-token
new-line:
the new-line character
2 A text line shall not begin with a # preprocessing token. A non-directive shall not begin with any of the
directive names appearing in the syntax.
3 When in a group that is skipped (16.1), the directive syntax is relaxed to allow any sequence of preprocessing
tokens to occur between the directive name and the following new-line character.
4 The only white-space characters that shall appear between preprocessing tokens within a preprocessing
directive (from just after the introducing # preprocessing token through just before the terminating new-line
character) are space and horizontal-tab (including spaces that have replaced comments or possibly other
white-space characters in translation phase 3).
5 The implementation can process and skip sections of source files conditionally, include other source files,
and replace macros. These capabilities are called preprocessing, because conceptually they occur before
translation of the resulting translation unit.
6 The preprocessing tokens within a preprocessing directive are not subject to macro expansion unless otherwise stated.
[ Example: In:
#define EMPTY
EMPTY # include <file.h>
406

 c ISO/IEC N3242=11-0012
the sequence of preprocessing tokens on the second line is not a preprocessing directive, because it does not
begin with a # at the start of translation phase 4, even though it will do so after the macro EMPTY has been
replaced. — end example ]
16.1 Conditional inclusion [cpp.cond]
1 The expression that controls conditional inclusion shall be an integral constant expression except that identifiers (including those lexically identical to keywords) are interpreted as described below145 and it may
contain unary operator expressions of the form
defined identifier
or
defined ( identifier )
which evaluate to 1 if the identifier is currently defined as a macro name (that is, if it is predefined or if it
has been the subject of a #define preprocessing directive without an intervening #undef directive with the
same subject identifier), 0 if it is not.
2 Each preprocessing token that remains (in the list of preprocessing tokens that will become the controlling
expression) after all macro replacements have occurred shall be in the lexical form of a token (2.7).
3 Preprocessing directives of the forms
# if constant-expression new-line groupopt
# elif constant-expression new-line groupopt
check whether the controlling constant expression evaluates to nonzero.
4 Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling
constant expression are replaced (except for those macro names modified by the defined unary operator),
just as in normal text. If the token defined is generated as a result of this replacement process or use
of the defined unary operator does not match one of the two specified forms prior to macro replacement,
the behavior is undefined. After all replacements due to macro expansion and the defined unary operator
have been performed, all remaining identifiers and keywords146, except for true and false, are replaced
with the pp-number 0, and then each preprocessing token is converted into a token. The resulting tokens
comprise the controlling constant expression which is evaluated according to the rules of 5.19 using arithmetic
that has at least the ranges specified in 18.3. For the purposes of this token conversion and evaluation all
signed and unsigned integer types act as if they have the same representation as, respectively, intmax_t
or uintmax_t (18.4).147 This includes interpreting character literals, which may involve converting escape
sequences into execution character set members. Whether the numeric value for these character literals
matches the value obtained when an identical character literal occurs in an expression (other than within a
#if or #elif directive) is implementation-defined.148 Also, whether a single-character character literal may
have a negative value is implementation-defined. Each subexpression with type bool is subjected to integral
promotion before processing continues.
145) Because the controlling constant expression is evaluated during translation phase 4, all identifiers either are or are not
macro names — there simply are no keywords, enumeration constants, etc.
146) An alternative token (2.6) is not an identifier, even when its spelling consists entirely of letters and underscores. Therefore
it is not subject to this replacement.
147) Thus on an implementation where std::numeric_limits<int>::max() is 0x7FFF and std::numeric_limits<unsigned
int>::max() is 0xFFFF, the integer literal 0x8000 is signed and positive within a #if expression even though it is unsigned
in translation phase 7 (2.2).
148) Thus, the constant expression in the following #if directive and if statement is not guaranteed to evaluate to the same
value in these two contexts.
#if ’z’ - ’a’ == 25
if (’z’ - ’a’ == 25)
§ 16.1 407

 c ISO/IEC N3242=11-0012
5 Preprocessing directives of the forms
# ifdef identifier new-line groupopt
# ifndef identifier new-line groupopt
check whether the identifier is or is not currently defined as a macro name. Their conditions are equivalent
to #if defined identifier and #if !defined identifier respectively.
6 Each directive’s condition is checked in order. If it evaluates to false (zero), the group that it controls is
skipped: directives are processed only through the name that determines the directive in order to keep track
of the level of nested conditionals; the rest of the directives’ preprocessing tokens are ignored, as are the other
preprocessing tokens in the group. Only the first group whose control condition evaluates to true (nonzero)
is processed. If none of the conditions evaluates to true, and there is a #else directive, the group controlled
by the #else is processed; lacking a #else directive, all the groups until the #endif are skipped.149
16.2 Source file inclusion [cpp.include]
1 A #include directive shall identify a header or source file that can be processed by the implementation.
2 A preprocessing directive of the form
# include < h-char-sequence> new-line
searches a sequence of implementation-defined places for a header identified uniquely by the specified sequence between the < and > delimiters, and causes the replacement of that directive by the entire contents
of the header. How the places are specified or the header identified is implementation-defined.
3 A preprocessing directive of the form
# include " q-char-sequence" new-line
causes the replacement of that directive by the entire contents of the source file identified by the specified
sequence between the " delimiters. The named source file is searched for in an implementation-defined
manner. If this search is not supported, or if the search fails, the directive is reprocessed as if it read
# include < h-char-sequence> new-line
with the identical contained sequence (including > characters, if any) from the original directive.
4 A preprocessing directive of the form
# include pp-tokens new-line
(that does not match one of the two previous forms) is permitted. The preprocessing tokens after include
in the directive are processed just as in normal text (Each identifier currently defined as a macro name is
replaced by its replacement list of preprocessing tokens.). If the directive resulting after all replacements
does not match one of the two previous forms, the behavior is undefined.150 The method by which a sequence
of preprocessing tokens between a < and a > preprocessing token pair or a pair of " characters is combined
into a single header name preprocessing token is implementation-defined.
5 The implementation shall provide unique mappings for sequences consisting of one or more nondigits or
digits (2.11) followed by a period (.) and a single nondigit. The first character shall not be a digit. The
implementation may ignore distinctions of alphabetical case.
149) As indicated by the syntax, a preprocessing token shall not follow a #else or #endif directive before the terminating
new-line character. However, comments may appear anywhere in a source file, including within a preprocessing directive.
150) Note that adjacent string literals are not concatenated into a single string literal (see the translation phases in 2.2); thus,
an expansion that results in two string literals is an invalid directive.
§ 16.2 408

 c ISO/IEC N3242=11-0012
6 A #include preprocessing directive may appear in a source file that has been read because of a #include
directive in another file, up to an implementation-defined nesting limit.
7 [ Note: Although an implementation may provide a mechanism for making arbitrary source files available to
the < > search, in general programmers should use the < > form for headers provided with the implementation, and the " " form for sources outside the control of the implementation. For instance:
#include <stdio.h>
#include <unistd.h>
#include "usefullib.h"
#include "myprog.h"
— end note ]
8 [ Example: This illustrates macro-replaced #include directives:
#if VERSION == 1
#define INCFILE "vers1.h"
#elif VERSION == 2
#define INCFILE "vers2.h" // and so on
#else
#define INCFILE "versN.h"
#endif
#include INCFILE
— end example ]
16.3 Macro replacement [cpp.replace]
1 Two replacement lists are identical if and only if the preprocessing tokens in both have the same number,
ordering, spelling, and white-space separation, where all white-space separations are considered identical.
2 An identifier currently defined as an object-like macro may be redefined by another #define preprocessing
directive provided that the second definition is an object-like macro definition and the two replacement lists
are identical, otherwise the program is ill-formed. Likewise, an identifier currently defined as a function-like
macro may be redefined by another #define preprocessing directive provided that the second definition is a
function-like macro definition that has the same number and spelling of parameters, and the two replacement
lists are identical, otherwise the program is ill-formed.
3 There shall be white-space between the identifier and the replacement list in the definition of an object-like
macro.
4 If the identifier-list in the macro definition does not end with an ellipsis, the number of arguments (including
those arguments consisting of no preprocessing tokens) in an invocation of a function-like macro shall equal
the number of parameters in the macro definition. Otherwise, there shall be more arguments in the invocation
than there are parameters in the macro definition (excluding the ...). There shall exist a ) preprocessing
token that terminates the invocation.
5 The identifier _ _ VA_ARGS _ _ shall occur only in the replacement-list of a function-like macro that uses the
ellipsis notation in the parameters.
6 A parameter identifier in a function-like macro shall be uniquely declared within its scope.
7 The identifier immediately following the define is called the macro name. There is one name space for macro
names. Any white-space characters preceding or following the replacement list of preprocessing tokens are
not considered part of the replacement list for either form of macro.
§ 16.3 409

 c ISO/IEC N3242=11-0012
8 If a # preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing
directive could begin, the identifier is not subject to macro replacement.
9 A preprocessing directive of the form
# define identifier replacement-list new-line
defines an object-like macro that causes each subsequent instance of the macro name151 to be replaced by the
replacement list of preprocessing tokens that constitute the remainder of the directive.152 The replacement
list is then rescanned for more macro names as specified below.
10 A preprocessing directive of the form
# define identifier lparen identifier-listopt) replacement-list new-line
# define identifier lparen ... ) replacement-list new-line
# define identifier lparen identifier-list , ... ) replacement-list new-line
defines a function-like macro with parameters, whose use is similar syntactically to a function call. The
parameters are specified by the optional list of identifiers, whose scope extends from their declaration in the
identifier list until the new-line character that terminates the #define preprocessing directive. Each subsequent instance of the function-like macro name followed by a ( as the next preprocessing token introduces
the sequence of preprocessing tokens that is replaced by the replacement list in the definition (an invocation
of the macro). The replaced sequence of preprocessing tokens is terminated by the matching ) preprocessing
token, skipping intervening matched pairs of left and right parenthesis preprocessing tokens. Within the
sequence of preprocessing tokens making up an invocation of a function-like macro, new-line is considered a
normal white-space character.
11 The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of
arguments for the function-like macro. The individual arguments within the list are separated by comma
preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate
arguments. If there are sequences of preprocessing tokens within the list of arguments that would otherwise
act as preprocessing directives,153 the behavior is undefined.
12 If there is a ... in the identifier-list in the macro definition, then the trailing arguments, including any
separating comma preprocessing tokens, are merged to form a single item: the variable arguments. The
number of arguments so combined is such that, following merger, the number of arguments is one more than
the number of parameters in the macro definition (excluding the ...).
16.3.1 Argument substitution [cpp.subst]
1 After the arguments for the invocation of a function-like macro have been identified, argument substitution
takes place. A parameter in the replacement list, unless preceded by a # or ## preprocessing token or
followed by a ## preprocessing token (see below), is replaced by the corresponding argument after all macros
contained therein have been expanded. Before being substituted, each argument’s preprocessing tokens are
completely macro replaced as if they formed the rest of the preprocessing file; no other preprocessing tokens
are available.
151) Since, by macro-replacement time, all character literals and string literals are preprocessing tokens, not sequences possibly
containing identifier-like subsequences (see 2.2, translation phases), they are never scanned for macro names or parameters.
152) An alternative token (2.6) is not an identifier, even when its spelling consists entirely of letters and underscores. Therefore
it is not possible to define a macro whose name is the same as that of an alternative token.
153) Despite the name, a non-directive is a preprocessing directive.
§ 16.3.1 410

 c ISO/IEC N3242=11-0012
2 An identifier _ _ VA_ARGS _ _ that occurs in the replacement list shall be treated as if it were a parameter,
and the variable arguments shall form the preprocessing tokens used to replace it.
16.3.2 The # operator [cpp.stringize]
1 Each # preprocessing token in the replacement list for a function-like macro shall be followed by a parameter
as the next preprocessing token in the replacement list.
2 A character string literal is a string-literal with no prefix. If, in the replacement list, a parameter is
immediately preceded by a # preprocessing token, both are replaced by a single character string literal
preprocessing token that contains the spelling of the preprocessing token sequence for the corresponding
argument. Each occurrence of white space between the argument’s preprocessing tokens becomes a single
space character in the character string literal. White space before the first preprocessing token and after
the last preprocessing token comprising the argument is deleted. Otherwise, the original spelling of each
preprocessing token in the argument is retained in the character string literal, except for special handling
for producing the spelling of string literals and character literals: a \ character is inserted before each " and
\ character of a character literal or string literal (including the delimiting " characters). If the replacement
that results is not a valid character string literal, the behavior is undefined. The character string literal
corresponding to an empty argument is "". The order of evaluation of # and ## operators is unspecified.
16.3.3 The ## operator [cpp.concat]
1 A ## preprocessing token shall not occur at the beginning or at the end of a replacement list for either form
of macro definition.
2 If, in the replacement list of a function-like macro, a parameter is immediately preceded or followed by
a ## preprocessing token, the parameter is replaced by the corresponding argument’s preprocessing token
sequence; however, if an argument consists of no preprocessing tokens, the parameter is replaced by a
placemarker preprocessing token instead.154
3 For both object-like and function-like macro invocations, before the replacement list is reexamined for more
macro names to replace, each instance of a ## preprocessing token in the replacement list (not from an
argument) is deleted and the preceding preprocessing token is concatenated with the following preprocessing
token. Placemarker preprocessing tokens are handled specially: concatenation of two placemarkers results
in a single placemarker preprocessing token, and concatenation of a placemarker with a non-placemarker
preprocessing token results in the non-placemarker preprocessing token. If the result is not a valid preprocessing token, the behavior is undefined. The resulting token is available for further macro replacement.
The order of evaluation of ## operators is unspecified.
[ Example: In the following fragment:
#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)
char p[] = join(x, y); // equivalent to
// char p[] = "x ## y";
The expansion produces, at various stages:
join(x, y)
in_between(x hash_hash y)
in_between(x ## y)
154) Placemarker preprocessing tokens do not appear in the syntax because they are temporary entities that exist only within
translation phase 4.
§ 16.3.3 411

 c ISO/IEC N3242=11-0012
mkstr(x ## y)
"x ## y"
In other words, expanding hash_hash produces a new token, consisting of two adjacent sharp signs, but this
new token is not the ## operator. — end example ]
16.3.4 Rescanning and further replacement [cpp.rescan]
1 After all parameters in the replacement list have been substituted and # and ## processing has taken
place, all placemarker preprocessing tokens are removed. Then the resulting preprocessing token sequence
is rescanned, along with all subsequent preprocessing tokens of the source file, for more macro names to
replace.
2 If the name of the macro being replaced is found during this scan of the replacement list (not including the
rest of the source file’s preprocessing tokens), it is not replaced. Furthermore, if any nested replacements
encounter the name of the macro being replaced, it is not replaced. These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts
in which that macro name preprocessing token would otherwise have been replaced.
3 The resulting completely macro-replaced preprocessing token sequence is not processed as a preprocessing
directive even if it resembles one, but all pragma unary operator expressions within it are then processed as
specified in 16.9 below.
16.3.5 Scope of macro definitions [cpp.scope]
1 A macro definition lasts (independent of block structure) until a corresponding #undef directive is encountered or (if none is encountered) until the end of the translation unit. Macro definitions have no significance
after translation phase 4.
2 A preprocessing directive of the form
# undef identifier new-line
causes the specified identifier no longer to be defined as a macro name. It is ignored if the specified identifier
is not currently defined as a macro name.
3 [ Note: The simplest use of this facility is to define a “manifest constant,” as in
#define TABSIZE 100
int table[TABSIZE];
— end note ]
4 The following defines a function-like macro whose value is the maximum of its arguments. It has the
advantages of working for any compatible types of the arguments and of generating in-line code without
the overhead of function calling. It has the disadvantages of evaluating one or the other of its arguments a
second time (including side effects) and generating more code than a function if invoked several times. It
also cannot have its address taken, as it has none.
#define max(a, b) ((a) > (b) ? (a) : (b))
The parentheses ensure that the arguments and the resulting expression are bound properly.
5 To illustrate the rules for redefinition and reexamination, the sequence
#define x 3
#define f(a) f(x * (a))
#undef x
§ 16.3.5 412

 c ISO/IEC N3242=11-0012
#define x 2
#define g f
#define z z[0]
#define h g(∼
#define m(a) a(w)
#define w 0,1
#define t(a) a
#define p() int
#define q(x) x
#define r(x,y) x ## y
#define str(x) # x
f(y+1) + f(f(z)) % t(t(g)(0) + t)(1);
g(x+(3,4)-w) | h 5) & m
(f)^m(m);
p() i[q()] = { q(1), r(2,3), r(4,), r(,5), r(,) };
char c[2][6] = { str(hello), str() };
results in
f(2 * (y+1)) + f(2 * (f(2 * (z[0])))) % f(2 * (0)) + t(1);
f(2 * (2+(3,4)-0,1)) | f(2 * (∼ 5)) & f(2 * (0,1))^m(0,1);
int i[] = { 1, 23, 4, 5, };
char c[2][6] = { "hello", "" };
6 To illustrate the rules for creating character string literals and concatenating tokens, the sequence
#define str(s) # s
#define xstr(s) str(s)
#define debug(s, t) printf("x" # s "= %d, x" # t "= %s", \
x ## s, x ## t)
#define INCFILE(n) vers ## n
#define glue(a, b) a ## b
#define xglue(a, b) glue(a, b)
#define HIGHLOW "hello"
#define LOW LOW ", world"
debug(1, 2);
fputs(str(strncmp("abc\0d", "abc", ’\4’) // this goes away
== 0) str(: @\n), s);
#include xstr(INCFILE(2).h)
glue(HIGH, LOW);
xglue(HIGH, LOW)
results in
printf("x" "1" "= %d, x" "2" "= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0" ": @\n", s);
#include "vers2.h" (after macro replacement, before file access)
"hello";
"hello" ", world"
or, after concatenation of the character string literals,
printf("x1= %d, x2= %s", x1, x2);
fputs("strncmp(\"abc\\0d\", \"abc\", ’\\4’) == 0: @\n", s);
#include "vers2.h" (after macro replacement, before file access)
§ 16.3.5 413

 c ISO/IEC N3242=11-0012
"hello";
"hello, world"
Space around the # and ## tokens in the macro definition is optional.
7 To illustrate the rules for placemarker preprocessing tokens, the sequence
#define t(x,y,z) x ## y ## z
int j[] = { t(1,2,3), t(,4,5), t(6,,7), t(8,9,),
t(10,,), t(,11,), t(,,12), t(,,) };
results in
int j[] = { 123, 45, 67, 89,
10, 11, 12, };
8 To demonstrate the redefinition rules, the following sequence is valid.
#define OBJ_LIKE (1-1)
#define OBJ_LIKE /* white space */ (1-1) /* other */
#define FUNC_LIKE(a) ( a )
#define FUNC_LIKE( a )( /* note the white space */ \
a /* other stuff on this line
*/ )
But the following redefinitions are invalid:
#define OBJ_LIKE (0) // different token sequence
#define OBJ_LIKE (1 - 1) // different white space
#define FUNC_LIKE(b) ( a ) // different parameter usage
#define FUNC_LIKE(b) ( b ) // different parameter spelling
9 Finally, to show the variable argument list macro facilities:
#define debug(...) fprintf(stderr, _ _ VA_ARGS _ _)
#define showlist(...) puts(#_ _ VA_ARGS _ _)
#define report(test, ...) ((test) ? puts(#test) : printf(_ _ VA_ARGS _ _))
debug("Flag");
debug("X = %d\n", x);
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);
results in
fprintf(stderr, "Flag");
fprintf(stderr, "X = %d\n", x);
puts("The first, second, and third items.");
((x>y) ? puts("x>y") : printf("x is %d but y is %d", x, y));
— end note ]
16.4 Line control [cpp.line]
1 The string literal of a #line directive, if present, shall be a character string literal.
2 The line number of the current source line is one greater than the number of new-line characters read or
introduced in translation phase 1 (2.2) while processing the source file to the current token.
§ 16.4 414

 c ISO/IEC N3242=11-0012
3 A preprocessing directive of the form
# line digit-sequence new-line
causes the implementation to behave as if the following sequence of source lines begins with a source line
that has a line number as specified by the digit sequence (interpreted as a decimal integer). If the digit
sequence specifies zero or a number greater than 2147483647, the behavior is undefined.
4 A preprocessing directive of the form
# line digit-sequence " s-char-sequenceopt" new-line
sets the presumed line number similarly and changes the presumed name of the source file to be the contents
of the character string literal.
5 A preprocessing directive of the form
# line pp-tokens new-line
(that does not match one of the two previous forms) is permitted. The preprocessing tokens after line
on the directive are processed just as in normal text (each identifier currently defined as a macro name is
replaced by its replacement list of preprocessing tokens). If the directive resulting after all replacements
does not match one of the two previous forms, the behavior is undefined; otherwise, the result is processed
as appropriate.
16.5 Error directive [cpp.error]
1 A preprocessing directive of the form
# error pp-tokensopt new-line
causes the implementation to produce a diagnostic message that includes the specified sequence of preprocessing tokens, and renders the program ill-formed.
16.6 Pragma directive [cpp.pragma]
1 A preprocessing directive of the form
# pragma pp-tokensopt new-line
causes the implementation to behave in an implementation-defined manner. The behavior might cause
translation to fail or cause the translator or the resulting program to behave in a non-conforming manner.
Any pragma that is not recognized by the implementation is ignored.
16.7 Null directive [cpp.null]
1 A preprocessing directive of the form
# new-line
has no effect.
16.8 Predefined macro names [cpp.predefined]
1 The following macro names shall be defined by the implementation:
_ _ cplusplus
The name _ _ cplusplus is defined to the value 201103L when compiling a C++ translation unit.155
155) It is intended that future versions of this standard will replace the value of this macro with a greater value. Non-conforming
compilers should use a value with at most five decimal digits.
§ 16.8 415

 c ISO/IEC N3242=11-0012
_ _ DATE _ _
The date of translation of the source file: a character string literal of the form "Mmm dd yyyy", where
the names of the months are the same as those generated by the asctime function, and the first
character of dd is a space character if the value is less than 10. If the date of translation is not
available, an implementation-defined valid date shall be supplied.
_ _ FILE _ _
The presumed name of the current source file (a character string literal).156
_ _ LINE _ _
The presumed line number (within the current source file) of the current source line (an integer
constant).156
_ _ STDC_HOSTED _ _
The integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if
it is not.
_ _ TIME _ _
The time of translation of the source file: a character string literal of the form "hh:mm:ss" as in the
time generated by the asctime function. If the time of translation is not available, an implementationdefined valid time shall be supplied.
2 The following macro names are conditionally defined by the implementation:
_ _ STDC _ _
Whether _ _ STDC _ _ is predefined and if so, what its value is, are implementation-defined.
_ _ STDC_MB_MIGHT_NEQ_WC _ _
The integer constant 1, intended to indicate that, in the encoding for wchar_t, a member of the basic
character set need not have a code value equal to its value when used as the lone character in an
ordinary character literal.
_ _ STDC_VERSION _ _
Whether _ _ STDC_VERSION _ _ is predefined and if so, what its value is, are implementation-defined.
_ _ STDC_ISO_10646 _ _
An integer constant of the form yyyymmL (for example, 199712L). If this symbol is defined, then every
character in the Unicode required set, when stored in an object of type wchar_t, has the same value
as the short identifier of that character. The Unicode required set consists of all the characters that
are defined by ISO/IEC 10646, along with all amendments and technical corrigenda as of the specified
year and month.
_ _ STDCPP_STRICT_POINTER_SAFETY _ _
Defined, and has the value integer constant 1, if and only if the implementation has strict pointer
safety (3.7.4.3).
3 The values of the predefined macros (except for _ _ FILE _ _ and _ _ LINE _ _) remain constant throughout
the translation unit.
4 If any of the pre-defined macro names in this subclause, or the identifier defined, is the subject of a #define
or a #undef preprocessing directive, the behavior is undefined. Any other predefined macro names shall begin
with a leading underscore followed by an uppercase letter or a second underscore.
156) The presumed source file name and line number can be changed by the #line directive.
§ 16.8 416

 c ISO/IEC N3242=11-0012
16.9 Pragma operator [cpp.pragma.op]
A unary operator expression of the form:
_Pragma ( string-literal )
is processed as follows: The string literal is destringized by deleting the L prefix, if present, deleting the
leading and trailing double-quotes, replacing each escape sequence \" by a double-quote, and replacing
each escape sequence \\ by a single backslash. The resulting sequence of characters is processed through
translation phase 3 to produce preprocessing tokens that are executed as if they were the pp-tokens in a
pragma directive. The original four preprocessing tokens in the unary operator expression are removed.
[ Example:
#pragma listing on "..\listing.dir"
can also be expressed as:
_Pragma ( "listing on \"..\\listing.dir\"" )
The latter form is processed in the same way whether it appears literally as shown, or results from macro
replacement, as in:
#define LISTING(x) PRAGMA(listing on #x)
#define PRAGMA(x) _Pragma(#x)
LISTING( ..\listing.dir )
— end example ]
§ 16.9 417

 c ISO/IEC N3242=11-0012
17 Library introduction [library]
17.1 General [library.general]
1 This Clause describes the contents of the C++ standard library, how a well-formed C++ program makes use
of the library, and how a conforming implementation may provide the entities in the library.
2 The following subclauses describe the definitions (17.3), method of description (17.5), and organization (17.6.1)
of the library. Clause 17.6, Clauses 18 through 30, and Annex D specify the contents of the library, as well as
library requirements and constraints on both well-formed C++ programs and conforming implementations.
3 Detailed specifications for each of the components in the library are in Clauses 18–30, as shown in Table 13.
Table 13 — Library categories
Clause Category
18 Language support library
19 Diagnostics library
20 General utilities library
21 Strings library
22 Localization library
23 Containers library
24 Iterators library
25 Algorithms library
26 Numerics library
27 Input/output library
28 Regular expressions library
29 Atomic operations library
30 Thread support library
4 The language support library (Clause 18) provides components that are required by certain parts of the C++
language, such as memory allocation (5.3.4, 5.3.5) and exception processing (Clause 15).
5 The diagnostics library (Clause 19) provides a consistent framework for reporting errors in a C++ program,
including predefined exception classes.
6 The general utilities library (Clause 20) includes components used by other library elements, such as a
predefined storage allocator for dynamic storage management (3.7.4), and components used as infrastructure
in C++ programs, such as a tuples, function wrappers, and time facilities.
7 The strings library (Clause 21) provides support for manipulating text represented as sequences of type
char, sequences of type char16_t, sequences of type char32_t, sequences of type wchar_t, and sequences
of any other character-like type.
8 The localization library (Clause 22) provides extended internationalization support for text processing.
9 The containers (Clause 23), iterators (Clause 24), and algorithms (Clause 25) libraries provide a C++ program
with access to a subset of the most widely used algorithms and data structures.
10 The numerics library (Clause 26) provides numeric algorithms and complex number components that extend
support for numeric processing. The valarray component provides support for n-at-a-time processing,
§ 17.1 418

 c ISO/IEC N3242=11-0012
potentially implemented as parallel operations on platforms that support such processing. The random
number component provides facilities for generating pseudo-random numbers.
11 The input/output library (Clause 27) provides the iostream components that are the primary mechanism
for C++ program input and output. They can be used with other elements of the library, particularly strings,
locales, and iterators.
12 The regular expressions library (Clause 28) provides regular expression matching and searching.
13 The atomic operations library (Clause 29) allows more fine-grained concurrent access to shared data than
is possible with locks.
14 The thread support library (Clause 30) provides components to create and manage threads, including mutual
exclusion and interthread communication.
17.2 The C standard library [library.c]
1 The C++ standard library also makes available the facilities of the C standard library, suitably adjusted to
ensure static type safety.
2 The descriptions of many library functions rely on the C standard library for the signatures and semantics
of those functions. In all such cases, any use of the restrict qualifier shall be omitted.
17.3 Definitions [definitions]
17.3.1 [defns.arbitrary.stream]
arbitrary-positional stream
a stream (described in Clause 27) that can seek to any integral position within the length of the stream
[ Note: Every arbitrary-positional stream is also a repositional stream. — end note ]
17.3.2 [defns.block]
block
place a thread in the blocked state
17.3.3 [defns.blocked]
blocked thread
a thread that is waiting for some condition (other than the availability of a processor) to be satisfied before
it can continue execution157
17.3.4 [defns.character]
character
<Clauses 21, 22, 27, and 28> any object which, when treated sequentially, can represent text
[ Note: The term does not mean only char, char16_t, char32_t, and wchar_t objects, but any value that
can be represented by a type that provides the definitions specified in these Clauses. — end note ]
17.3.5 [defns.character.container]
character container type
a class or a type used to represent a character
157) This definition is taken from POSIX.
§ 17.3 419

 c ISO/IEC N3242=11-0012
[ Note: It is used for one of the template parameters of the string, iostream, and regular expression class
templates. A character container type is a POD (3.9) type. — end note ]
17.3.6 [defns.comparison]
comparison function
an operator function (13.5) for any of the equality (5.10) or relational (5.9) operators
17.3.7 [defns.component]
component
a group of library entities directly related as members, parameters, or return types
[ Note: For example, the class template basic_string and the non-member function templates that operate
on strings are referred to as the string component. — end note ]
17.3.8 [defns.deadlock]
deadlock
one or more threads are unable to continue execution because each is blocked waiting for one or more of the
others to satisfy some condition
17.3.9 [defns.default.behavior.impl]
default behavior
<implementation> any specific behavior provided by the implementation, within the scope of the required
behavior
17.3.10 [defns.default.behavior.func]
default behavior
<specification> a description of replacement function and handler function semantics
17.3.11 [defns.handler]
handler function
a non-reserved function whose definition may be provided by a C++ program
[ Note: A C++ program may designate a handler function at various points in its execution by supplying a
pointer to the function when calling any of the library functions that install handler functions (Clause 18).
— end note ]
17.3.12 [defns.iostream.templates]
iostream class templates
templates, defined in Clause 27, that take two template arguments
[ Note: The arguments are named charT and traits. The argument charT is a character container class,
and the argument traits is a class which defines additional characteristics and functions of the character
type represented by charT necessary to implement the iostream class templates. — end note ]
17.3.13 [defns.modifier]
modifier function
a class member function (9.3) other than a constructor, assignment operator, or destructor that alters the
state of an object of the class
§ 17.3 420

 c ISO/IEC N3242=11-0012
17.3.14 [defns.move.constr]
move construction
direct-initialization of an object of some type with an rvalue of the same type
17.3.15 [defns.move.assign]
move assignment
assignment of an rvalue of some object type to a modifiable lvalue of the same type
17.3.16 [defns.obj.state]
object state
the current value of all non-static class members of an object (9.2)
[ Note: The state of an object can be obtained by using one or more observer functions. — end note ]
17.3.17 [defns.ntcts]
NTCTS
a sequence of values that have character type that precede the terminating null character type value charT()
17.3.18 [defns.observer]
observer function
a class member function (9.3) that accesses the state of an object of the class but does not alter that state
[ Note: Observer functions are specified as const member functions (9.3.2). — end note ]
17.3.19 [defns.replacement]
replacement function
a non-reserved function whose definition is provided by a C++ program
[ Note: Only one definition for such a function is in effect for the duration of the program’s execution, as the
result of creating the program (2.2) and resolving the definitions of all translation units (3.5). — end note ]
17.3.20 [defns.repositional.stream]
repositional stream
a stream (described in Clause 27) that can seek to a position that was previously encountered
17.3.21 [defns.required.behavior]
required behavior
a description of replacement function and handler function semantics applicable to both the behavior provided by the implementation and the behavior of any such function definition in the program
[ Note: If such a function defined in a C++ program fails to meet the required behavior when it executes,
the behavior is undefined. — end note ]
17.3.22 [defns.reserved.function]
reserved function
a function, specified as part of the C++ standard library, that must be defined by the implementation
[ Note: If a C++ program provides a definition for any reserved function, the results are undefined. — end
note ]
§ 17.3 421

 c ISO/IEC N3242=11-0012
17.3.23 [defns.stable]
stable algorithm
an algorithm that preserves, as appropriate to the particular algorithm, the order of elements
[ Note: Requirements for stable algorithms are given in 17.6.5.7. — end note ]
17.3.24 [defns.traits]
traits class
a class that encapsulates a set of types and functions necessary for class templates and function templates
to manipulate objects of types for which they are instantiated
[ Note: Traits classes defined in Clauses 21, 22 and 27 are character traits, which provide the character
handling support needed by the string and iostream classes. — end note ]
17.3.25 [defns.unblock]
unblock
place a thread in the unblocked state
17.4 Additional definitions [defns.additional]
1 1.3 defines additional terms used elsewhere in this International Standard.
17.5 Method of description (Informative) [description]
1 This subclause describes the conventions used to specify the C++ standard library. 17.5.1 describes the
structure of the normative Clauses 18 through 30 and Annex D. 17.5.2 describes other editorial conventions.
17.5.1 Structure of each clause [structure]
17.5.1.1 Elements [structure.elements]
1 Each library clause contains the following elements, as applicable:158
— Summary
— Requirements
— Detailed specifications
— References to the Standard C library
17.5.1.2 Summary [structure.summary]
1 The Summary provides a synopsis of the category, and introduces the first-level subclauses. Each subclause
also provides a summary, listing the headers specified in the subclause and the library entities provided in
each header.
2 Paragraphs labelled “Note(s):” or “Example(s):” are informative, other paragraphs are normative.
3 The contents of the summary and the detailed specifications include:
— macros
— values
158) To save space, items that do not apply to a Clause are omitted. For example, if a Clause does not specify any requirements,
there will be no “Requirements” subclause.
§ 17.5.1.2 422

 c ISO/IEC N3242=11-0012
— types
— classes and class templates
— functions and function templates
— objects
17.5.1.3 Requirements [structure.requirements]
1 Requirements describe contraints that shall be met by a C++ program that extends the standard library.
Such extensions are generally one of the following:
— Template arguments
— Derived classes
— Containers, iterators, and algorithms that meet an interface convention
2 The string and iostream components use an explicit representation of operations required of template arguments. They use a class template char_traits to define these constraints.
3 Interface convention requirements are stated as generally as possible. Instead of stating “class X has to
define a member function operator++(),” the interface requires “for any object x of class X, ++x is defined.”
That is, whether the operator is a member is unspecified.
4 Requirements are stated in terms of well-defined expressions that define valid terms of the types that satisfy
the requirements. For every set of well-defined expression requirements there is a table that specifies an initial
set of the valid expressions and their semantics. Any generic algorithm (Clause 25) that uses the well-defined
expression requirements is described in terms of the valid expressions for its formal type parameters.
5 Template argument requirements are sometimes referenced by name. See 17.5.2.1.
6 In some cases the semantic requirements are presented as C++ code. Such code is intended as a specification of equivalence of a construct to another construct, not necessarily as the way the construct must be
implemented.159
17.5.1.4 Detailed specifications [structure.specifications]
1 The detailed specifications each contain the following elements:
— name and brief description
— synopsis (class definition or function prototype, as appropriate)
— restrictions on template arguments, if any
— description of class invariants
— description of function semantics
2 Descriptions of class member functions follow the order (as appropriate):160
— constructor(s) and destructor
— copying, moving & assignment functions
159) Although in some cases the code given is unambiguously the optimum implementation.
160) To save space, items that do not apply to a class are omitted. For example, if a class does not specify any comparison
functions, there will be no “Comparison functions” subclause.
§ 17.5.1.4 423

 c ISO/IEC N3242=11-0012
— comparison functions
— modifier functions
— observer functions
— operators and other non-member functions
3 Descriptions of function semantics contain the following elements (as appropriate):161
— Requires: the preconditions for calling the function
— Effects: the actions performed by the function
— Synchronization: the synchronization operations (1.10) applicable to the function
— Postconditions: the observable results established by the function
— Returns: a description of the value(s) returned by the function
— Throws: any exceptions thrown by the function, and the conditions that would cause the exception
— Complexity: the time and/or space complexity of the function
— Remarks: additional semantic constraints on the function
— Error conditions: the error conditions for error codes reported by the function.
— Notes: non-normative comments about the function
4 Whenever the Effects: element specifies that the semantics of some function F are Equivalent to some code
sequence, then the various elements are interpreted as follows. If F’s semantics specifies a Requires: element,
then that requirement is logically imposed prior to the equivalent-to semantics. Next, the semantics of the
code sequence are determined by the Requires:, Effects:, Postconditions:, Returns:, Throws:, Complexity:,
Remarks:, Error conditions:, and Notes: specified for the function invocations contained in the code sequence.
The value returned from F is specified by F’s Returns: element, or if F has no Returns: element, a non-void
return from F is specified by the Returns: elements in the code sequence. If F’s semantics contains a Throws:,
Postconditions:, or Complexity: element, then that supersedes any occurrences of that element in the code
sequence.
5 For non-reserved replacement and handler functions, Clause 18 specifies two behaviors for the functions in
question: their required and default behavior. The default behavior describes a function definition provided
by the implementation. The required behavior describes the semantics of a function definition provided by
either the implementation or a C++ program. Where no distinction is explicitly made in the description,
the behavior described is the required behavior.
6 If the formulation of a complexity requirement calls for a negative number of operations, the actual requirement is zero operations.162
7 Complexity requirements specified in the library clauses are upper bounds, and implementations that provide
better complexity guarantees satisfy the requirements.
8 Error conditions specify conditions where a function may fail. The conditions are listed, together with
a suitable explanation, as the enum class errc constants (19.5) that could be used as an argument to
function make_error_condition (19.5.3.5).
161) To save space, items that do not apply to a function are omitted. For example, if a function does not specify any further
preconditions, there will be no “Requires” paragraph.
162) This simplifies the presentation of complexity requirements in some cases.
§ 17.5.1.4 424

 c ISO/IEC N3242=11-0012
17.5.1.5 C library [structure.see.also]
1 Paragraphs labelled “See also:” contain cross-references to the relevant portions of this International
Standard and the ISO C standard, which is incorporated into this International Standard by reference.
17.5.2 Other conventions [conventions]
1 This subclause describes several editorial conventions used to describe the contents of the C++ standard
library. These conventions are for describing implementation-defined types (17.5.2.1), and member functions (17.5.2.2).
17.5.2.1 Type descriptions [type.descriptions]
17.5.2.1.1 General [type.descriptions.general]
1 The Requirements subclauses may describe names that are used to specify constraints on template arguments.163 These names are used in library Clauses to describe the types that may be supplied as arguments
by a C++ program when instantiating template components from the library.
2 Certain types defined in Clause 27 are used to describe implementation-defined types. They are based on
other types, but with added constraints.
17.5.2.1.2 Enumerated types [enumerated.types]
1 Several types defined in Clause 27 are enumerated types. Each enumerated type may be implemented as an
enumeration or as a synonym for an enumeration.164
2 The enumerated type enumerated can be written:
enum enumerated { V0 , V1 , V2 , V3 , ..... };
static const enumerated C0 (V0 );
static const enumerated C1 (V1 );
static const enumerated C2 (V2 );
static const enumerated C3 (V3 );
.....
3 Here, the names C0, C1, etc. represent enumerated elements for this particular enumerated type. All such
elements have distinct values.
17.5.2.1.3 Bitmask types [bitmask.types]
1 Several types defined in Clauses 18 through 30 and Annex D are bitmask types. Each bitmask type can be implemented as an enumerated type that overloads certain operators, as an integer type, or as a bitset (20.5).
2 The bitmask type bitmask can be written:
// For exposition only.
// int_type is an integral type capable of
// representing all values of the bitmask type.
enum bitmask : int_type {
V0 = 1 << 0, V1 = 1 << 1, V2 = 1 << 2, V3 = 1 << 3, .....
};
163) Examples from 17.6.3 include: EqualityComparable, LessThanComparable, CopyConstructible. Examples from 24.2 include: InputIterator, ForwardIterator, Function, Predicate.
164) Such as an integer type, with constant integer values (3.9.1).
§ 17.5.2.1.3 425

 c ISO/IEC N3242=11-0012
constexpr bitmask C0 (V0);
constexpr bitmask C1 (V1);
constexpr bitmask C2 (V2);
constexpr bitmask C3 (V3);
.....
constexpr bitmask operator&(bitmask X, bitmask Y) {
return static_cast<bitmask>(
static_cast<int_type>(X) & static_cast<int_type>(Y));
}
constexpr bitmask operator|(bitmask X, bitmask Y) {
return static_cast<bitmask>(
static_cast<int_type>(X) | static_cast<int_type>(Y));
}
constexpr bitmask operator^(bitmask X, bitmask Y){
return static_cast<bitmask>(
static_cast<int_type>(X) ^ static_cast<int_type>(Y));
}
constexpr bitmask operator~(bitmask X){
return static_cast<bitmask>(~static_cast<int_type>(X));
}
bitmask& operator&=(bitmask& X, bitmask Y){
X = X & Y; return X;
}
bitmask& operator|=(bitmask& X, bitmask Y) {
X = X | Y; return X;
}
bitmask& operator^=(bitmask& X, bitmask Y) {
X = X ^ Y; return X;
}
3 Here, the names C0, C1, etc. represent bitmask elements for this particular bitmask type. All such elements
have distinct values such that, for any pair Ci and Cj, Ci & Ci is nonzero and Ci & Cj is zero.
4 The following terms apply to objects and values of bitmask types:
— To set a value Y in an object X is to evaluate the expression X |= Y.
— To clear a value Y in an object X is to evaluate the expression X &= ∼Y.
— The value Y is set in the object X if the expression X & Y is nonzero.
17.5.2.1.4 Character sequences [character.seq]
1 The C standard library makes widespread use of characters and character sequences that follow a few uniform
conventions:
— A letter is any of the 26 lowercase or 26 uppercase letters in the basic execution character set.165
— The decimal-point character is the (single-byte) character used by functions that convert between a
(single-byte) character sequence and a value of one of the floating-point types. It is used in the character
sequence to denote the beginning of a fractional part. It is represented in Clauses 18 through 30 and
Annex D by a period, ’.’, which is also its value in the "C" locale, but may change during program
165) Note that this definition differs from the definition in ISO C 7.1.1.
§ 17.5.2.1.4 426

 c ISO/IEC N3242=11-0012
execution by a call to setlocale(int, const char*),166 or by a change to a locale object, as
described in Clauses 22.3 and 27.
— A character sequence is an array object (8.3.4) A that can be declared as T A[N ], where T is any of
the types char, unsigned char, or signed char (3.9.1), optionally qualified by any combination of
const or volatile. The initial elements of the array have defined contents up to and including an
element determined by some predicate. A character sequence can be designated by a pointer value S
that points to its first element.
17.5.2.1.4.1 Byte strings [byte.strings]
1 A null-terminated byte string, or ntbs, is a character sequence whose highest-addressed element with defined
content has the value zero (the terminating null character); no other element in the sequence has the value
zero.167
2 The length of an ntbs is the number of elements that precede the terminating null character. An empty
ntbs has a length of zero.
3 The value of an ntbs is the sequence of values of the elements up to and including the terminating null
character.
4 A static ntbs is an ntbs with static storage duration.168
17.5.2.1.4.2 Multibyte strings [multibyte.strings]
1 A null-terminated multibyte string, or ntmbs, is an ntbs that constitutes a sequence of valid multibyte
characters, beginning and ending in the initial shift state.169
2 A static ntmbs is an ntmbs with static storage duration.
17.5.2.2 Functions within classes [functions.within.classes]
1 For the sake of exposition, Clauses 18 through 30 and Annex D do not describe copy/move constructors,
assignment operators, or (non-virtual) destructors with the same apparent semantics as those that can be
generated by default (12.1, 12.4, 12.8).
2 It is unspecified whether the implementation provides explicit definitions for such member function signatures, or for virtual destructors that can be generated by default.
17.5.2.3 Private members [objects.within.classes]
1 Clauses 18 through 30 and Annex D do not specify the representation of classes, and intentionally omit
specification of class members (9.2). An implementation may define static or non-static class members, or
both, as needed to implement the semantics of the member functions specified in Clauses 18 through 30 and
Annex D.
2 Objects of certain classes are sometimes required by the external specifications of their classes to store data,
apparently in member objects. For the sake of exposition, some subclauses provide representative declarations, and semantic requirements, for private member objects of classes that meet the external specifications
of the classes. The declarations for such member objects and the definitions of related member types are
followed by a comment that ends with exposition only, as in:
166) declared in <clocale> (22.6).
167) Many of the objects manipulated by function signatures declared in <cstring> (21.7) are character sequences or ntbss.
The size of some of these character sequences is limited by a length value, maintained separately from the character sequence.
168) A string literal, such as "abc", is a static ntbs.
169) An ntbs that contains characters only from the basic execution character set is also an ntmbs. Each multibyte character
then consists of a single byte.
§ 17.5.2.3 427

 c ISO/IEC N3242=11-0012
streambuf* sb; // exposition only
3 An implementation may use any technique that provides equivalent external behavior.
17.6 Library-wide requirements [requirements]
1 This subclause specifies requirements that apply to the entire C++ standard library. Clauses 18 through 30
and Annex D specify the requirements of individual entities within the library.
2 Requirements specified in terms of interactions between threads do not apply to programs having only a
single thread of execution.
3 Within this subclause, 17.6.1 describes the library’s contents and organization, 17.6.2 describes how wellformed C++ programs gain access to library entities, 17.6.3 describes constraints on types and functions
used with the C++ standard library, 17.6.4 describes constraints on well-formed C++ programs, and 17.6.5
describes constraints on conforming implementations.
17.6.1 Library contents and organization [organization]
1 17.6.1.1 describes the entities defined in the C++ standard library. 17.6.1.2 lists the standard library headers
and some constraints on those headers. 17.6.1.3 lists requirements for a freestanding implementation of the
C++ standard library.
17.6.1.1 Library contents [contents]
1 The C++ standard library provides definitions for the following types of entities: macros, values, types,
templates, classes, functions, objects.
2 All library entities except macros, operator new and operator delete are defined within the namespace
std or namespaces nested within namespace std.170 It is unspecified whether names declared in a specific
namespace are declared directly in that namespace or in an inline namespace inside that namespace.171
3 Whenever a name x defined in the standard library is mentioned, the name x is assumed to be fully qualified
as ::std::x, unless explicitly described otherwise. For example, if the Effects section for library function F
is described as calling library function G, the function ::std::G is meant.
17.6.1.2 Headers [headers]
1 Each element of the C++ standard library is declared or defined (as appropriate) in a header.172
2 The C++ standard library provides 52 C++ library headers, as shown in Table 14.
3 The facilities of the C standard Library are provided in 26 additional headers, as shown in Table 15.
4 Except as noted in Clauses 18 through 30 and Annex D, the contents of each header cname shall be the same
as that of the corresponding header name.h, as specified in the C standard library (1.2) or the C Unicode
TR, as appropriate, as if by inclusion. In the C++ standard library, however, the declarations (except for
names which are defined as macros in C) are within namespace scope (3.3.6) of the namespace std. It is
unspecified whether these names are first declared within the global namespace scope and are then injected
into namespace std by explicit using-declarations (7.3.3).
170) The C standard library headers (Annex D.5) also define names within the global namespace, while the C++ headers for C
library facilities (17.6.1.2) may also define names within the global namespace.
171) This gives implementors freedom to use inline namespaces to support multiple configurations of the library.
172) A header is not necessarily a source file, nor are the sequences delimited by < and > in header names necessarily valid
source file names (16.2).
§ 17.6.1.2 428

 c ISO/IEC N3242=11-0012
Table 14 — C++ library headers
<algorithm> <fstream> <list> <regex> <typeindex>
<array> <functional> <locale> <set> <typeinfo>
<atomic> <future> <map> <sstream> <type_traits>
<bitset> <initializer_list> <memory> <stack> <unordered_map>
<chrono> <iomanip> <mutex> <stdexcept> <unordered_set>
<codecvt> <ios> <new> <streambuf> <utility>
<complex> <iosfwd> <numeric> <string> <valarray>
<condition_variable> <iostream> <ostream> <strstream> <vector>
<deque> <istream> <queue> <system_error>
<exception> <iterator> <random> <thread>
<forward_list> <limits> <ratio> <tuple>
Table 15 — C++ headers for C library facilities
<cassert> <cinttypes> <csignal> <cstdio> <cwchar>
<ccomplex> <ciso646> <cstdalign> <cstdlib> <cwctype>
<cctype> <climits> <cstdarg> <cstring>
<cerrno> <clocale> <cstdbool> <ctgmath>
<cfenv> <cmath> <cstddef> <ctime>
<cfloat> <csetjmp> <cstdint> <cuchar>
5 Names which are defined as macros in C shall be defined as macros in the C++ standard library, even if
C grants license for implementation as functions. [ Note: The names defined as macros in C include the
following: assert, offsetof, setjmp, va_arg, va_end, and va_start. — end note ]
6 Names that are defined as functions in C shall be defined as functions in the C++ standard library.173
7 Identifiers that are keywords or operators in C++ shall not be defined as macros in C++ standard library
headers.174
8 D.5, C standard library headers, describes the effects of using the name.h (C header) form in a C++ program.175
17.6.1.3 Freestanding implementations [compliance]
1 Two kinds of implementations are defined: hosted and freestanding (1.4). For a hosted implementation, this
International Standard describes the set of available headers.
2 A freestanding implementation has an implementation-defined set of headers. This set shall include at least
the headers shown in Table 16.
3 The supplied version of the header <cstdlib> shall declare at least the functions abort, atexit, at_-
quick_exit, exit, and quick_exit (18.5). The supplied version of the header <thread> shall meet the
173) This disallows the practice, allowed in C, of providing a masking macro in addition to the function prototype. The only
way to achieve equivalent inline behavior in C++ is to provide a definition as an extern inline function.
174) In particular, including the standard header <iso646.h> or <ciso646> has no effect.
175) The ".h" headers dump all their names into the global namespace, whereas the newer forms keep their names in namespace
std. Therefore, the newer forms are the preferred forms for all uses except for C++ programs which are intended to be strictly
compatible with C.
§ 17.6.1.3 429

 c ISO/IEC N3242=11-0012
Table 16 — C++ headers for freestanding implementations
Subclause Header(s)
18.2 Types <cstddef>
18.3 Implementation properties <limits>
18.5 Start and termination <cstdlib>
18.6 Dynamic memory management <new>
18.7 Type identification <typeinfo>
18.8 Exception handling <exception>
18.9 Initializer lists <initializer_list>
18.10 Other runtime support <cstdarg>
20.9 Type traits <type_traits>
29 Atomics <atomic>
30.3 Threads <thread>
same requirements as for a hosted implementation or including it shall have no effect. The other headers
listed in this table shall meet the same requirements as for a hosted implementation.
17.6.2 Using the library [using]
17.6.2.1 Overview [using.overview]
1 This section describes how a C++ program gains access to the facilities of the C++ standard library. 17.6.2.2
describes effects during translation phase 4, while 17.6.2.3 describes effects during phase 8 (2.2).
17.6.2.2 Headers [using.headers]
1 The entities in the C++ standard library are defined in headers, whose contents are made available to a
translation unit when it contains the appropriate #include preprocessing directive (16.2).
2 A translation unit may include library headers in any order (Clause 2). Each may be included more than
once, with no effect different from being included exactly once, except that the effect of including either
<cassert> or <assert.h> depends each time on the lexically current definition of NDEBUG.176
3 A translation unit shall include a header only outside of any external declaration or definition, and shall
include the header lexically before the first reference in that translation unit to any of the entities declared
in that header.
17.6.2.3 Linkage [using.linkage]
1 Entities in the C++ standard library have external linkage (3.5). Unless otherwise specified, objects and
functions have the default extern "C++" linkage (7.5).
2 Whether a name from the C standard library declared with external linkage has extern "C" or extern
"C++" linkage is implementation-defined. It is recommended that an implementation use extern "C++"
linkage for this purpose.177
176) This is the same as the Standard C library.
177) The only reliable way to declare an object or function signature from the Standard C library is by including the header
that declares it, notwithstanding the latitude granted in 7.1.7 of the C Standard.
§ 17.6.2.3 430

 c ISO/IEC N3242=11-0012
3 Objects and functions defined in the library and required by a C++ program are included in the program
prior to program startup.
See also: replacement functions (17.6.4.6), run-time changes (17.6.4.7).
17.6.3 Requirements on types and expressions [utility.requirements]
Moved from Clause 20.
1 17.6.3.1 describes requirements on types and expressions used to instantiate templates defined in the C++
standard library. 17.6.3.2 describes the requirements on swappable types and swappable expressions. 17.6.3.3
describes the requirements on pointer-like types that support null values. 17.6.3.4 describes the requirements
on hash function objects. 17.6.3.5 describes the requirements on storage allocators.
17.6.3.1 Template argument requirements [utility.arg.requirements]
1 The template definitions in the C++ standard library refer to various named requirements whose details are
set out in tables 17–24. In these tables, T is an object or reference type to be supplied by a C++ program
instantiating a template; a, b, and c are values of type (possibly const) T; s and t are modifiable lvalues of
type T; u denotes an identifier; rv is an rvalue of type T; and v is an lvalue of type (possibly const) T or an
rvalue of type const T.
2 In general, a default constructor is not required. Certain container class member function signatures specify
T() as a default argument. T() shall be a well-defined expression (8.5) if one of those signatures is called
using the default argument (8.3.6).
Table 17 — EqualityComparable requirements [equalitycomparable]
Expression Return type Requirement
a == b convertible to bool == is an equivalence relation, that is, it has the
following properties:
— For all a, a == a.
— If a == b, then b == a.
— If a == b and b == c, then a == c.
Table 18 — LessThanComparable requirements [lessthancomparable]
Expression Return type Requirement
a < b convertible to bool < is a strict weak ordering relation (25.4)
Table 19 — DefaultConstructible requirements [defaultconstructible]
Expression Post-condition
T t; object t is default-initialized
T u{}; object u is value-initialized
T() a temporary object of type T is value-initialized
T{}
§ 17.6.3.1 431

 c ISO/IEC N3242=11-0012
Table 20 — MoveConstructible requirements [moveconstructible]
Expression Post-condition
T u = rv; u is equivalent to the value of rv before the construction
T(rv) T(rv) is equivalent to the value of rv before the construction
[ Note: rv remains a valid object. Its state is unspecified — end note ]
Table 21 — CopyConstructible requirements (in addition to MoveConstructible) [copyconstructible]
Expression Post-condition
T u = v; the value of v is unchanged and is equivalent to u
T(v) the value of v is unchanged and is equivalent to T(v)
Table 22 — MoveAssignable requirements [moveassignable]
Expression Return type Return value Post-condition
t = rv T& t t is equivalent to the value of rv before the assignment
[ Note: rv remains a valid object. Its state is unspecified. — end note ]
Table 23 — CopyAssignable requirements(in addition to MoveAssignable) [copyassignable]
Expression Return type Return value Post-condition
t = v T& t t is equivalent to v, the value of v is unchanged
Table 24 — Destructible requirements [destructible]
Expression Post-condition
u.∼T() All resources owned by u are reclaimed, no exception is propagated.
§ 17.6.3.1 432

 c ISO/IEC N3242=11-0012
17.6.3.2 Swappable requirements [swappable.requirements]
1 This subclause provides definitions for swappable types and expressions. In these definitions, let t denote
an expression of type T, and let u denote an expression of type U.
2 An object t is swappable with an object u if and only if:
— the expressions swap(t, u) and swap(u, t) are valid when evaluated in the context described below,
and
— these expressions have the following effects:
— the object referred to by t has the value originally held by u and
— the object referred to by u has the value originally held by t.
3 The context in which swap(t, u) and swap(u, t) are evaluated shall ensure that a binary non-member
function named “swap” is selected via overload resolution (13.3) on a candidate set that includes:
— the two swap function templates defined in <utility> (20.2) and
— the lookup set produced by argument-dependent lookup (3.4.2).
[ Note: If T and U are both fundamental types or arrays of fundamental types and the declarations from the
header <utility> are in scope, the overall lookup set described above is equivalent to that of the qualified
name lookup applied to the expression std::swap(t, u) or std::swap(u, t) as appropriate. — end note ]
[ Note: It is unspecified whether a library component that has a swappable requirement includes the header
<utility> to ensure an appropriate evaluation context. — end note ]
4 An rvalue or lvalue t is swappable if and only if t is swappable with any rvalue or lvalue, respectively, of
type T.
5 A type X satisfying any of the iterator requirements (24.2) is ValueSwappable if, for any dereferenceable
object x of type X, *x is swappable.
[ Example: User code can ensure that the evaluation of swap calls is performed in an appropriate context
under the various conditions as follows:
#include <utility>
// Requires: std::forward<T>(t) shall be swappable with std::forward<U>(u).
template <class T, class U>
void value_swap(T&& t, U&& u) {
using std::swap;
swap(std::forward<T>(t), std::forward<U>(u)); // OK: uses “swappable with” conditions
// for rvalues and lvalues
}
// Requires: lvalues of T shall be swappable.
template <class T>
void lv_swap(T& t1 T& t2) {
using std::swap;
swap(t1, t2); // OK: uses swappable conditions for
} // lvalues of type T
namespace N {
struct A { int m; };
struct Proxy { A *a; };
Proxy proxy(A& a) { return Proxy{ &a }; }
§ 17.6.3.2 433

 c ISO/IEC N3242=11-0012
void swap(A& x, Proxy p) {
std::swap(x.m, p.a->m); // OK: uses context equivalent to swappable
// conditions for fundamental types
}
void swap(Proxy p, A& x) { swap(x, p); } // satisfy symmetry contraint
}
int main() {
int i = 1, j = 2;
lv_swap(i, j);
assert(i == 2 && j == 1);
N::A a1 = { 5 }, a2 = { -5 };
value_swap(a1, proxy(a2));
assert(a1.m == -5 && a2.m == 5);
}
— end example ]
17.6.3.3 NullablePointer requirements [nullablepointer.requirements]
1 A NullablePointer type is a pointer-like type that supports null values. A type P meets the requirements
of NullablePointer if:
— P satisfies the requirements of EqualityComparable, DefaultConstructible, CopyConstructible,
CopyAssignable, and Destructible,
— lvalues of type P are swappable (17.6.3.2),
— the expressions shown in Table 25 are valid and have the indicated semantics, and
— P satisfies all the other requirements of this subclause.
2 A value-initialized object of type P produces the null value of the type. The null value shall be equivalent
only to itself. A default-initialized object of type P may have an indeterminate value. [ Note: Operations
involving indeterminate values may cause undefined behavior. — end note ]
3 An object p of type P can be contextually converted to bool (Clause 4). The effect shall be as if p !=
nullptr had been evaluated in place of p.
4 No operation which is part of the NullablePointer requirements shall exit via an exception.
5 In Table 25, u denotes an identifier, t denotes a non-const lvalue of type P, a and b denote values of type
(possibly const) P, and np denotes a value of type (possibly const) std::nullptr_t.
17.6.3.4 Hash requirements [hash.requirements]
1 A type H meets the Hash requirements if:
— it is a function object type (20.8),
— it satisfies the requirements of CopyConstructible and Destructible (17.6.3.1),
— the expressions shown in the following Table 26 are valid and have the indicated semantics, and
— it satisfies all other requirements in this subclause.
§ 17.6.3.4 434

 c ISO/IEC N3242=11-0012
Table 25 — NullablePointer requirements [nullablepointer]
Expression Return type Operational semantics
P u(np); post: u == nullptr
P u = np;
P(np) post: P(np) == nullptr
t = np P& post: t == nullptr
a != b contextually convertible to bool !(a == b)
a == np contextually convertible to bool a == P()
np == a
a != np contextually convertible to bool !(a == np)
np != a
2 Given Key is an argument type for function objects of type H, in Table 26 h is a value of type (possibly
const) H, u is an lvalue of type Key, and k is a value of a type convertible to (possibly const) Key.
Table 26 — Hash requirements [tab:hash]
Expression Return type Requirement
h(k) size_t Shall not throw exceptions. The value returned shall depend
only on the argument k. [ Note: Thus all evaluations of
the expression h(k) with the same value for k yield the
same result. — end note ] [ Note: For two different values
t1 and t2, the probability that h(t1) and h(t2) compare
equal should be very small, approaching 1.0 / numeric_-
limits<size_t>::max(). — end note ]
h(u) size_t Shall not modify u.
17.6.3.5 Allocator requirements [allocator.requirements]
1 The library describes a standard set of requirements for allocators, which are class-type objects that encapsulate the information about an allocation model. This information includes the knowledge of pointer types,
the type of their difference, the type of the size of objects in this allocation model, as well as the memory allocation and deallocation primitives for it. All of the string types (Clause 21), containers (Clause 23) (except
array), string buffers and string streams (Clause 27), and match_results (Clause 28) are parameterized in
terms of allocators.
2 The template struct allocator_traits (20.6.8) supplies a uniform interface to all allocator types. Table 27
describes the types manipulated through allocators. Table 28 describes the requirements on allocator types
and thus on types used to instantiate allocator_traits. A requirement is optional if the last column of
Table 28 specifies a default for a given expression. Within the standard library allocator_traits template,
an optional requirement that is not supplied by an allocator is replaced by the specified default expression.
A user specialization of allocator_traits may provide different defaults and may provide defaults for
different requirements than the primary template. Within Tables 27 and 28, the use of move and forward
always refers to std::move and std::forward, respectively.
Table 27 — Descriptive variable definitions
Variable Definition
T, U, C any non-const, non-reference object type
§ 17.6.3.5 435

 c ISO/IEC N3242=11-0012
Table 27 — Descriptive variable definitions (continued)
Variable Definition
V a type convertible to T
X an Allocator class for type T
Y the corresponding Allocator class for type U
XX the type allocator_traits<X>
YY the type allocator_traits<Y>
t a value of type const T&
a, a1, a2 values of type X&
a3 an rvalue of type X
b a value of type Y
c a dereferenceable pointer of type C*
p a value of type XX::pointer, obtained by calling
a1.allocate, where a1 == a
q a value of type XX::const_pointer obtained by
conversion from a value p.
w a value of type XX::void_pointer obtained by conversion
from a value p
z a value of type XX::const_void_pointer obtained by
conversion from a value q or a value w
r a value of type T& obtained by the expression *p.
s a value of type const T& obtained by the expression *q or
by conversion from a value r.
u a value of type YY::const_pointer obtained by calling
YY::allocate, or else nullptr.
v a value of type V
n a value of type XX::size_type.
Args a template parameter pack
args a function parameter pack with the pattern Args&&
§ 17.6.3.5 436

 c ISO/IEC N3242=11-0012
Table 28 — Allocator requirements
Expression Return type Assertion/note Default
pre-/post-condition
X::pointer T*
X::const_pointer X::pointer is convertible to
X::const_pointer
pointer-
_traits<X
::pointer> ::
rebind<const
T>
X::void_pointer
Y::void_pointer
X::pointer is convertible to
X::void_pointer.
X::void_pointer and
Y::void_pointer are the same
type.
pointer_-
traits<X
::pointer>::
rebind<void>
X::const_void_-
pointer
Y::const_void_-
pointer
X::pointer,
X::const_pointer, and
X::void_pointer are
convertible to
X::const_void_pointer.
X::const_void_pointer and
Y::const_void_pointer are
the same type.
pointer-
_traits<X
::pointer> ::
rebind<const
void>
X::value_type Identical to T
X::size_type unsigned integral
integer type
a type that can represent the
size of the largest object in the
allocation model.
make_-
unsigned<
X::difference_-
type>::type
X::difference_type signed integral integer
type
a type that can represent the
difference between any two
pointers in the allocation
model.
pointer_-
traits<
X::pointer>::
difference_-
type
typename
X::template
rebind<U>::other
Y For all U (including T),
Y::template
rebind<T>::other is X.
See Note A,
below.
*p T&
*q const T& *q refers to the same object as
*p
p->m type of T::m pre: (*p).m is well-defined.
equivalent to (*p).m
q->m type of T::m pre: (*q).m is well-defined.
equivalent to (*q).m
static_-
cast<X::pointer>(w)
X::pointer static_cast<X::pointer>(w)
== p
static_cast<X
::const_pointer>(z)
X::const_pointer static_cast<X
::const_pointer>(z) == q
§ 17.6.3.5 437

 c ISO/IEC N3242=11-0012
Table 28 — Allocator requirements (continued)
Expression Return type Assertion/note Default
pre-/post-condition
a.allocate(n) X::pointer Memory is allocated for n
objects of type T but objects
are not constructed. allocate
may raise an appropriate
exception.178[ Note: If n == 0,
the return value is unspecified.
— end note ]
a.allocate(n, u) X::pointer Same as a.allocate(n). The
use of u is unspecified, but it is
intended as an aid to locality.
a.allocate(n)
a.deallocate(p,n) (not used) All n T objects in the area
pointed to by p shall be
destroyed prior to this call. n
shall match the value passed to
allocate to obtain this
memory. Does not throw
exceptions. [ Note:p shall not be
singular. — end note ]
a.max_size() X::size_type the largest value that can
meaningfully be passed to
X::allocate()
numeric_-
limits<size_-
type>::max()
a1 == a2 bool returns true only if storage
allocated from each can be
deallocated via the other.
operator== shall be reflexive,
symmetric, and transitive, and
shall not exit via an exception.
a1 != a2 bool same as !(a1 == a2)
a == b bool same as a ==
Y::rebind<T>::other(b)
a != b bool same as !(a == b)
X a1(a); Shall not exit via an exception.
post: a1 == a
X a(b); Shall not exit via an exception.
post: Y(a) == b, a == X(b)
X a1(move(a)); Shall not exit via an exception.
post: a1 equals the prior value
of a.
X a(move(b)); Shall not exit via an exception.
post: a equals the prior value of
X(b).
a.construct(c,
args)
(not used) Effect: Constructs an object of
type C at c
::new
((void*)c)
C(forward<
Args>(args)...)
a.destroy(c) (not used) Effect: Destroys the object at c c->~C()
§ 17.6.3.5 438

 c ISO/IEC N3242=11-0012
Table 28 — Allocator requirements (continued)
Expression Return type Assertion/note Default
pre-/post-condition
a.select_on_-
container_copy_-
construction()
X Typically returns either a or
X()
return a;
X::propagate_on_-
container_copy_-
assignment
Identical to or derived
from true_type or
false_type
true_type only if an allocator
of type X should be copied when
the client container is
copy-assigned.
false_type
X::propagate_on_-
container_move_-
assignment
Identical to or derived
from true_type or
false_type
true_type only if an allocator
of type X should be moved
when the client container is
move-assigned.
false_type
X::propagate_on_-
container_swap
Identical to or derived
from true_type or
false_type
true_type only if an allocator
of type X should be swapped
when the client container is
swapped.
false_type
3 Note A: The member class template rebind in the table above is effectively a typedef template. [ Note: In
general, if the name Allocator is bound to SomeAllocator<T>, then Allocator::rebind<U>::other is the
same type as SomeAllocator<U>, where SomeAllocator<T>::value_type is T and SomeAllocator<U>::value_-
type is U. — end note ] If Allocator is a class template instantiation of the form SomeAllocator<T, Args>,
where Args is zero or more type arguments, and Allocator does not supply a rebind member template, the
standard allocator_traits template uses SomeAllocator<U, Args> in place of Allocator::rebind<U>::other
by default. For allocator types that are not template instantiations of the above form, no default is provided.
4 The X::pointer, X::const_pointer, X::void_pointer, and X::const_void_pointer types shall satisfy
the requirements of NullablePointer (17.6.3.3). No constructor, comparison operator, copy operation,
move operation, or swap operation on these types shall exit via an exception. X::pointer and X::const_-
pointer shall also satisfy the requirements for a random access iterator (24.2).
5 An allocator may constrain the types on which it can be instantiated and the arguments for which its
construct member may be called. If a type cannot be used with a particular allocator, the allocator class
or the call to construct may fail to instantiate.
[ Example: the following is an allocator class template supporting the minimal interface that satisfies the
requirements of Table 28:
template <class Tp>
struct SimpleAllocator {
typedef Tp value_type;
SimpleAllocator(ctor args);
template <class T> SimpleAllocator(const SimpleAllocator<T>& other);
Tp *allocate(std::size_t n);
void deallocate(Tp *p, std::size_t n);
};
178) It is intended that a.allocate be an efficient means of allocating a single object of type T, even when sizeof(T) is small.
That is, there is no need for a container to maintain its own free list.
§ 17.6.3.5 439

 c ISO/IEC N3242=11-0012
— end example ]
6 If the alignment associated with a specific over-aligned type is not supported by an allocator, instantiation
of the allocator for that type may fail. The allocator also may silently ignore the requested alignment.
[ Note: Additionally, the member function allocate for that type may fail by throwing an object of type
std::bad_alloc. — end note ]
17.6.4 Constraints on programs [constraints]
17.6.4.1 Overview [constraints.overview]
1 This section describes restrictions on C++ programs that use the facilities of the C++ standard library.
The following subclauses specify constraints on the program’s use of namespaces (17.6.4.2.1), its use of
various reserved names (17.6.4.3), its use of headers (17.6.4.4), its use of standard library classes as base
classes (17.6.4.5), its definitions of replacement functions (17.6.4.6), and its installation of handler functions
during execution (17.6.4.7).
17.6.4.2 Namespace use [namespace.constraints]
17.6.4.2.1 Namespace std [namespace.std]
1 The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a
namespace within namespace std unless otherwise specified. A program may add a template specialization
for any standard library template to namespace std only if the declaration depends on a user-defined type
and the specialization meets the standard library requirements for the original template and is not explicitly
prohibited.179
2 The behavior of a C++ program is undefined if it declares
— an explicit specialization of any member function of a standard library class template, or
— an explicit specialization of any member function template of a standard library class or class template,
or
— an explicit or partial specialization of any member class template of a standard library class or class
template.
A program may explicitly instantiate a template defined in the standard library only if the declaration
depends on the name of a user-defined type and the instantiation meets the standard library requirements
for the original template.
3 A translation unit shall not declare namespace std to be an inline namespace (7.3.1).
17.6.4.2.2 Namespace posix [namespace.posix]
1 The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to
a namespace within namespace posix unless otherwise specified. The namespace posix is reserved for use
by ISO/IEC 9945 and other POSIX standards.
17.6.4.3 Reserved names [reserved.names]
1 The C++ standard library reserves the following kinds of names:
— macros
179) Any library code that instantiates other library templates must be prepared to work adequately with any user-supplied
specialization that meets the minimum requirements of the Standard.
§ 17.6.4.3 440

 c ISO/IEC N3242=11-0012
— global names
— names with external linkage
2 If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by
this Clause, its behavior is undefined.
17.6.4.3.1 Macro names [macro.names]
1 A translation unit that includes a standard library header shall not #define or #undef names declared in
any standard library header.
2 A translation unit shall not #define or #undef names lexically identical to keywords.
17.6.4.3.2 Global names [global.names]
1 Certain sets of names and function signatures are always reserved to the implementation:
— Each name that contains a double underscore _ _ or begins with an underscore followed by an uppercase
letter (2.12) is reserved to the implementation for any use.
— Each name that begins with an underscore is reserved to the implementation for use as a name in the
global namespace.
17.6.4.3.3 External linkage [extern.names]
1 Each name declared as an object with external linkage in a header is reserved to the implementation to
designate that library object with external linkage,180 both in namespace std and in the global namespace.
2 Each global function signature declared with external linkage in a header is reserved to the implementation
to designate that function signature with external linkage. 181
3 Each name from the Standard C library declared with external linkage is reserved to the implementation
for use as a name with extern "C" linkage, both in namespace std and in the global namespace.
4 Each function signature from the Standard C library declared with external linkage is reserved to the
implementation for use as a function signature with both extern "C" and extern "C++" linkage, 182 or as
a name of namespace scope in the global namespace.
17.6.4.3.4 Types [extern.types]
1 For each type T from the Standard C library,183 the types ::T and std::T are reserved to the implementation
and, when defined, ::T shall be identical to std::T.
17.6.4.3.5 User-defined literal suffixes [usrlit.suffix]
1 Literal suffix identifiers that do not start with an underscore are reserved for future standardization.
17.6.4.4 Headers [alt.headers]
1 If a file with a name equivalent to the derived file name for one of the C++ standard library headers is not
180) The list of such reserved names includes errno, declared or defined in <cerrno>.
181) The list of such reserved function signatures with external linkage includes setjmp(jmp_buf), declared or defined in
<csetjmp>, and va_end(va_list), declared or defined in <cstdarg>.
182) The function signatures declared in <cuchar>, <cwchar>, and <cwctype> are always reserved, notwithstanding the restrictions imposed in subclause 4.5.1 of Amendment 1 to the C Standard for these headers.
183) These types are clock_t, div_t, FILE, fpos_t, lconv, ldiv_t, mbstate_t, ptrdiff_t, sig_atomic_t, size_t, time_t, tm,
va_list, wctrans_t, wctype_t, and wint_t.
§ 17.6.4.4 441

 c ISO/IEC N3242=11-0012
provided as part of the implementation, and a file with that name is placed in any of the standard places
for a source file to be included (16.2), the behavior is undefined.
17.6.4.5 Derived classes [derived.classes]
1 Virtual member function signatures defined for a base class in the C++ standard library may be overridden
in a derived class defined in the program (10.3).
17.6.4.6 Replacement functions [replacement.functions]
1 Clauses 18 through 30 and Annex D describe the behavior of numerous functions defined by the C++ standard
library. Under some circumstances, however, certain of these function descriptions also apply to replacement
functions defined in the program (17.3).
2 A C++ program may provide the definition for any of eight dynamic memory allocation function signatures
declared in header <new> (3.7.4, 18.6):
— operator new(std::size_t)
— operator new(std::size_t, const std::nothrow_t&)
— operator new[](std::size_t)
— operator new[](std::size_t, const std::nothrow_t&)
— operator delete(void*)
— operator delete(void*, const std::nothrow_t&)
— operator delete[](void*)
— operator delete[](void*, const std::nothrow_t&)
3 The program’s definitions are used instead of the default versions supplied by the implementation (18.6).
Such replacement occurs prior to program startup (3.2, 3.6). The program’s definitions shall not be specified
as inline. No diagnostic is required.
17.6.4.7 Handler functions [handler.functions]
1 The C++ standard library provides default versions of the following handler functions (Clause 18):
— unexpected_handler
— terminate_handler
2 A C++ program may install different handler functions during execution, by supplying a pointer to a function
defined in the program or the library as an argument to (respectively):
— set_new_handler
— set_unexpected
— set_terminate
See also: subclauses 18.6.2, Storage allocation errors, and 18.8, Exception handling.
3 A C++ program can get a pointer to the current handler function by calling the following functions:
— get_new_handler
— get_unexpected
§ 17.6.4.7 442

 c ISO/IEC N3242=11-0012
— get_terminate
4 Calling the set_* and get_* functions shall not incur a data race. A call to any of the set_* functions shall
synchronize with subsequent calls to the same set_* function and to the corresponding get_* function.
17.6.4.8 Other functions [res.on.functions]
1 In certain cases (replacement functions, handler functions, operations on types used to instantiate standard
library template components), the C++ standard library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the
implementation.
2 In particular, the effects are undefined in the following cases:
— for replacement functions (18.6.1), if the installed replacement function does not implement the semantics of the applicable Required behavior: paragraph.
— for handler functions (18.6.2.3, 18.8.3.1, D.11.1), if the installed handler function does not implement
the semantics of the applicable Required behavior: paragraph
— for types used as template arguments when instantiating a template component, if the operations on
the type do not implement the semantics of the applicable Requirements subclause (17.6.3.5, 23.2,
24.2, 26.2). Operations on such types can report a failure by throwing an exception unless otherwise
specified.
— if any replacement function or handler function or destructor operation exits via an exception, unless
specifically allowed in the applicable Required behavior: paragraph.
— if an incomplete type (3.9) is used as a template argument when instantiating a template component,
unless specifically allowed for that component.
17.6.4.9 Function arguments [res.on.arguments]
1 Each of the following applies to all arguments to functions defined in the C++ standard library, unless
explicitly stated otherwise.
— If an argument to a function has an invalid value (such as a value outside the domain of the function
or a pointer invalid for its intended use), the behavior is undefined.
— If a function argument is described as being an array, the pointer actually passed to the function shall
have a value such that all address computations and accesses to objects (that would be valid if the
pointer did point to the first element of such an array) are in fact valid.
— If a function argument binds to an rvalue reference parameter, the implementation may assume that
this parameter is a unique reference to this argument. [ Note: If the parameter is a generic parameter of
the form T&& and an lvalue of type A is bound, the argument binds to an lvalue reference (14.8.2.1) and
thus is not covered by the previous sentence. — end note ] [ Note: If a program casts an lvalue to an
xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument
move(x)), the program is effectively asking that function to treat that lvalue as a temporary. The
implementation is free to optimize away aliasing checks which might be needed if the argument was
an lvalue. — end note ]
17.6.4.10 Shared objects and the library [res.on.objects]
1 The behavior of a program is undefined if calls to standard library functions from different threads may
introduce a data race. The conditions under which this may occur are specified in 17.6.5.9. [ Note: Modifying
§ 17.6.4.10 443

 c ISO/IEC N3242=11-0012
an object of a standard library type that is shared between threads risks undefined behavior unless objects
of that type are explicitly specified as being sharable without data races or the user supplies a locking
mechanism. — end note ]
2 [ Note: In particular, the program is required to ensure that completion of the constructor of any object of
a class type defined in the standard library happens before any other member function invocation on that
object and, unless otherwise specified, to ensure that completion of any member function invocation other
than destruction on such an object happens before destruction of that object. This applies even to objects
such as mutexes intended for thread synchronization. — end note ]
17.6.4.11 Requires paragraph [res.on.required]
1 Violation of the preconditions specified in a function’s Requires: paragraph results in undefined behavior
unless the function’s Throws: paragraph specifies throwing an exception when the precondition is violated.
17.6.5 Conforming implementations [conforming]
17.6.5.1 Overview [conforming.overview]
1 This section describes the constraints upon, and latitude of, implementations of the C++ standard library.
2 An implementation’s use of headers is discussed in 17.6.5.2, its use of macros in 17.6.5.3, global functions
in 17.6.5.4, member functions in 17.6.5.5, data race avoidance in 17.6.5.9, access specifiers in 17.6.5.10, class
derivation in 17.6.5.11, and exceptions in 17.6.5.12.
17.6.5.2 Headers [res.on.headers]
1 A C++ header may include other C++ headers. A C++ header shall provide the declarations and definitions
that appear in its synopsis. A C++ header shown in its synopsis as including other C++ headers shall provide
the declarations and definitions that appear in the synopses of those other headers.
2 Certain types and macros are defined in more than one header. Every such entity shall be defined such that
any header that defines it may be included after any other header that also defines it (3.2).
3 The C standard headers (D.5) shall include only their corresponding C++ standard header, as described
in 17.6.1.2.
17.6.5.3 Restrictions on macro definitions [res.on.macro.definitions]
1 The names and global function signatures described in 17.6.1.1 are reserved to the implementation.
2 All object-like macros defined by the C standard library and described in this Clause as expanding to
integral constant expressions are also suitable for use in #if preprocessing directives, unless explicitly stated
otherwise.
17.6.5.4 Global and non-member functions [global.functions]
1 It is unspecified whether any global or non-member functions in the C++ standard library are defined as
inline (7.1.2).
2 A call to a global or non-member function signature described in Clauses 18 through 30 and Annex D shall
behave as if the implementation declared no additional global or non-member function signatures.184
3 An implementation shall not declare a global or non-member function signature with additional default
arguments.
184) A valid C++ program always calls the expected library global or non-member function. An implementation may also
define additional global or non-member functions that would otherwise not be called by a valid C++ program.
§ 17.6.5.4 444

 c ISO/IEC N3242=11-0012
4 Unless otherwise specified, global and non-member functions in the standard library shall not use functions
from another namespace which are found through argument-dependent name lookup (3.4.2). [ Note: The
phrase “unless otherwise specified” is intended to allow argument-dependent lookup in cases like that of
ostream_iterators: Effects:
*out_stream << value;
if (delim != 0)
*out_stream << delim;
return (*this);
— end note ]
17.6.5.5 Member functions [member.functions]
1 It is unspecified whether any member functions in the C++ standard library are defined as inline (7.1.2).
2 An implementation may declare additional non-virtual member function signatures within a class:
— by adding arguments with default values to a member function signature;185 [ Note: An implementation
may not add arguments with default values to virtual, global, or non-member functions. — end note ]
— by replacing a member function signature with default values by two or more member function signatures with equivalent behavior; and
— by adding a member function signature for a member function name.
3 A call to a member function signature described in the C++ standard library behaves as if the implementation
declares no additional member function signatures.186
17.6.5.6 constexpr functions and constructors [constexpr.functions]
1 Within any header that provides any non-defining declarations of constexpr functions or constructors an
implementation shall provide corresponding definitions.
17.6.5.7 Requirements for stable algorithms [algorithm.stable]
1 When the requirements for an algorithm state that it is “stable” without further elaboration, it means:
— For the sort algorithms the relative order of equivalent elements is preserved.
— For the remove algorithms the relative order of the elements that are not removed is preserved.
— For the merge algorithms, for equivalent elements in the original two ranges, the elements from the
first range precede the elements from the second range.
17.6.5.8 Reentrancy [reentrancy]
1 Except where explicitly specified in this standard, it is implementation-defined which functions in the Standard C++ library may be recursively reentered.
17.6.5.9 Data race avoidance [res.on.data.races]
1 This section specifies requirements that implementations shall meet to prevent data races (1.10). Every
standard library function shall meet each requirement unless otherwise specified. Implementations may
prevent data races in cases other than those specified below.
185) Hence, the address of a member function of a class in the C++ standard library has an unspecified type.
186) A valid C++ program always calls the expected library member function, or one with equivalent behavior. An implementation may also define additional member functions that would otherwise not be called by a valid C++ program.
§ 17.6.5.9 445

 c ISO/IEC N3242=11-0012
2 A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s arguments, including this.
3 A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function’s nonconst arguments, including this.
4 [ Note: This means, for example, that implementations can’t use a static object for internal purposes without
synchronization because it could cause a data race even in programs that do not explicitly share objects
between threads. — end note ]
5 A C++ standard library function shall not access objects indirectly accessible via its arguments or via
elements of its container arguments except by invoking functions required by its specification on those
container elements.
6 Operations on iterators obtained by calling a standard library container or string member function may
access the underlying container, but shall not modify it. [ Note: In particular, container operations that
invalidate iterators conflict with operations on iterators associated with that container. — end note ]
7 Implementations may share their own internal objects between threads if the objects are not visible to users
and are protected against data races.
8 Unless otherwise specified, C++ standard library functions shall perform all operations solely within the
current thread if those operations have effects that are visible (1.10) to users.
9 [ Note: This allows implementations to parallelize operations if there are no visible s. — end note ]
17.6.5.10 Protection within classes [protection.within.classes]
1 It is unspecified whether any function signature or class described in Clauses 18 through 30 and Annex D is
a friend of another class in the C++ standard library.
17.6.5.11 Derived classes [derivation]
1 An implementation may derive any class in the C++ standard library from a class with a name reserved to
