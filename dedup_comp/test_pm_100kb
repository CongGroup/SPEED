§ 1.4 5

 c ISO/IEC N3242=11-0012
7 Two kinds of implementations are defined: a hosted implementation and a freestanding implementation. For
a hosted implementation, this International Standard defines the set of available libraries. A freestanding
implementation is one in which execution may take place without the benefit of an operating system, and
has an implementation-defined set of libraries that includes certain language-support libraries (17.6.1.3).
8 A conforming implementation may have extensions (including additional library functions), provided they do
not alter the behavior of any well-formed program. Implementations are required to diagnose programs that
use such extensions that are ill-formed according to this International Standard. Having done so, however,
they can compile and execute such programs.
9 Each implementation shall include documentation that identifies all conditionally-supported constructs that
it does not support and defines all locale-specific characteristics.3
1.5 Structure of this International Standard [intro.structure]
1 Clauses 2 through 16 describe the C++ programming language. That description includes detailed syntactic
specifications in a form described in 1.6. For convenience, Annex A repeats all such syntactic specifications.
2 Clauses 18 through 30 and Annex D (the library clauses) describe the Standard C++ library. That description
includes detailed descriptions of the templates, classes, functions, constants, and macros that constitute the
library, in a form described in Clause 17.
3 Annex B recommends lower bounds on the capacity of conforming implementations.
4 Annex C summarizes the evolution of C++ since its first published description, and explains in detail the
differences between C++ and C. Certain features of C++ exist solely for compatibility purposes; Annex D
describes those features.
5 Throughout this International Standard, each example is introduced by “[ Example:” and terminated by
“ — end example ]”. Each note is introduced by “[ Note:” and terminated by “ — end note ]”. Examples and
notes may be nested.
1.6 Syntax notation [syntax]
1 In the syntax notation used in this International Standard, syntactic categories are indicated by italic type,
and literal words and characters in constant width type. Alternatives are listed on separate lines except in
a few cases where a long set of alternatives is marked by the phrase “one of.” If the text of an alternative is
too long to fit on a line, the text is continued on subsequent lines indented from the first one. An optional
terminal or nonterminal symbol is indicated by the subscript “opt ”, so
{ expressionopt}
indicates an optional expression enclosed in braces.
2 Names for syntactic categories have generally been chosen according to the following rules:
— X-name is a use of an identifier in a context that determines its meaning (e.g., class-name, typedefname).
— X-id is an identifier with no context-dependent meaning (e.g., qualified-id).
— X-seq is one or more X’s without intervening delimiters (e.g., declaration-seq is a sequence of declarations).
— X-list is one or more X’s separated by intervening commas (e.g., expression-list is a sequence of
expressions separated by commas).
3) This documentation also defines implementation-defined behavior; see 1.9.
§ 1.6 6

 c ISO/IEC N3242=11-0012
1.7 The C++ memory model [intro.memory]
1 The fundamental storage unit in the C++ memory model is the byte. A byte is at least large enough to contain
any member of the basic execution character set (2.3) and the eight-bit code units of the Unicode UTF-8
encoding form and is composed of a contiguous sequence of bits, the number of which is implementationdefined. The least significant bit is called the low-order bit; the most significant bit is called the high-order
bit. The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every
byte has a unique address.
2 [ Note: The representation of types is described in 3.9. — end note ]
3 A memory location is either an object of scalar type or a maximal sequence of adjacent bit-fields all having
non-zero width. [ Note: Various features of the language, such as references and virtual functions, might
involve additional memory locations that are not accessible to programs but are managed by the implementation. — end note ] Two threads of execution (1.10) can update and access separate memory locations
without interfering with each other.
4 [ Note: Thus a bit-field and an adjacent non-bit-field are in separate memory locations, and therefore can be
concurrently updated by two threads of execution without interference. The same applies to two bit-fields,
if one is declared inside a nested struct declaration and the other is not, or if the two are separated by
a zero-length bit-field declaration, or if they are separated by a non-bit-field declaration. It is not safe to
concurrently update two bit-fields in the same struct if all fields between them are also bit-fields of non-zero
width. — end note ]
5 [ Example: A structure declared as
struct {
char a;
int b:5,
c:11,
:0,
d:8;
struct {int ee:8;} e;
}
contains four separate memory locations: The field a and bit-fields d and e.ee are each separate memory
locations, and can be modified concurrently without interfering with each other. The bit-fields b and c
together constitute the fourth memory location. The bit-fields b and c cannot be concurrently modified, but
b and a, for example, can be. — end example ]
1.8 The C++ object model [intro.object]
1 The constructs in a C++ program create, destroy, refer to, access, and manipulate objects. An object is a
region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the
way that objects do. — end note ] An object is created by a definition (3.1), by a new-expression (5.3.4) or
by the implementation (12.2) when needed. The properties of an object are determined when the object is
created. An object can have a name (Clause 3). An object has a storage duration (3.7) which influences
its lifetime (3.8). An object has a type (3.9). The term object type refers to the type with which the object
is created. Some objects are polymorphic (10.3); the implementation generates information associated with
each such object that makes it possible to determine that object’s type during program execution. For other
objects, the interpretation of the values found therein is determined by the type of the expressions (Clause 5)
used to access them.
§ 1.8 7

 c ISO/IEC N3242=11-0012
2 Objects can contain other objects, called subobjects. A subobject can be a member subobject (9.2), a base
class subobject (Clause 10), or an array element. An object that is not a subobject of any other object is
called a complete object.
3 For every object x, there is some object called the complete object of x, determined as follows:
— If x is a complete object, then x is the complete object of x.
— Otherwise, the complete object of x is the complete object of the (unique) object that contains x.
4 If a complete object, a data member (9.2), or an array element is of class type, its type is considered the
most derived class, to distinguish it from the class type of any base class subobject; an object of a most
derived class type or of a non-class type is called a most derived object.
5 Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more
bytes of storage. Base class subobjects may have zero size. An object of trivially copyable or standard-layout
type (3.9) shall occupy contiguous bytes of storage.
6 Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address
of the first byte it occupies. Two distinct objects that are neither bit-fields nor base class subobjects of zero
size shall have distinct addresses.4
[ Example:
static const char test1 = ’x’;
static const char test2 = ’x’;
const bool b = &test1 != &test2; // always true
— end example ]
7 [ Note: C++ provides a variety of built-in types and several ways of composing new types from existing
types (3.9). — end note ]
1.9 Program execution [intro.execution]
1 The semantic descriptions in this International Standard define a parameterized nondeterministic abstract
machine. This International Standard places no requirement on the structure of conforming implementations.
In particular, they need not copy or emulate the structure of the abstract machine. Rather, conforming
implementations are required to emulate (only) the observable behavior of the abstract machine as explained
below.5
2 Certain aspects and operations of the abstract machine are described in this International Standard as
implementation-defined (for example, sizeof(int)). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these
respects.6 Such documentation shall define the instance of the abstract machine that corresponds to that
implementation (referred to as the “corresponding instance” below).
3 Certain other aspects and operations of the abstract machine are described in this International Standard as
unspecified (for example, order of evaluation of arguments to a function). Where possible, this International
Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract
4) Under the “as-if” rule an implementation is allowed to store two objects at the same machine address or not store an
object at all if the program cannot observe the difference (1.9).
5) This provision is sometimes called the “as-if” rule, because an implementation is free to disregard any requirement of this
International Standard as long as the result is as if the requirement had been obeyed, as far as can be determined from the
observable behavior of the program. For instance, an actual implementation need not evaluate part of an expression if it can
deduce that its value is not used and that no side effects affecting the observable behavior of the program are produced.
6) This documentation also includes conditonally-supported constructs and locale-specific behavior. See 1.4.
§ 1.9 8

 c ISO/IEC N3242=11-0012
machine. An instance of the abstract machine can thus have more than one possible execution for a given
program and a given input.
4 Certain other operations are described in this International Standard as undefined (for example, the effect
of attempting to modify a const object). [ Note: This International Standard imposes no requirements on
the behavior of programs that contain undefined behavior. — end note ]
5 A conforming implementation executing a well-formed program shall produce the same observable behavior
as one of the possible executions of the corresponding instance of the abstract machine with the same program
and the same input. However, if any such execution contains an undefined operation, this International
Standard places no requirement on the implementation executing that program with that input (not even
with regard to operations preceding the first undefined operation).
6 When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects which
are neither
— of type volatile std::sig_atomic_t nor
— lock-free atomic objects (29.4)
are unspecified during the execution of the signal handler, and the value of any object not in either of these
two categories that is modified by the handler becomes undefined.
7 An instance of each object with automatic storage duration (3.7.3) is associated with each entry into its
block. Such an object exists and retains its last-stored value during the execution of the block and while the
block is suspended (by a call of a function or receipt of a signal).
8 The least requirements on a conforming implementation are:
— Access to volatile objects are evaluated strictly according to the rules of the abstract machine.
— At program termination, all data written into files shall be identical to one of the possible results that
execution of the program according to the abstract semantics would have produced.
— The input and output dynamics of interactive devices shall take place in such a fashion that prompting
output is actually delivered before a program waits for input. What constitutes an interactive device
is implementation-defined.
These collectively are referred to as the observable behavior of the program. [ Note: More stringent correspondences between abstract and actual semantics may be defined by each implementation. — end note ]
9 [ Note: Operators can be regrouped according to the usual mathematical rules only where the operators
really are associative or commutative.7 For example, in the following fragment
int a, b;
/∗
... ∗/
a = a + 32760 + b + 5;
the expression statement behaves exactly the same as
a = (((a + 32760) + b) + 5);
due to the associativity and precedence of these operators. Thus, the result of the sum (a + 32760) is next
added to b, and that result is then added to 5 which results in the value assigned to a. On a machine in which
overflows produce an exception and in which the range of values representable by an int is [-32768,+32767],
the implementation cannot rewrite this expression as
a = ((a + b) + 32765);
7) Overloaded operators are never assumed to be associative or commutative.
§ 1.9 9

 c ISO/IEC N3242=11-0012
since if the values for a and b were, respectively, -32754 and -15, the sum a + b would produce an exception
while the original expression would not; nor can the expression be rewritten either as
a = ((a + 32765) + b);
or
a = (a + (b + 32765));
since the values for a and b might have been, respectively, 4 and -8 or -17 and 12. However on a machine in
which overflows do not produce an exception and in which the results of overflows are reversible, the above
expression statement can be rewritten by the implementation in any of the above ways because the same
result will occur. — end note ]
10 A full-expression is an expression that is not a subexpression of another expression. If a language construct
is defined to produce an implicit call of a function, a use of the language construct is considered to be an
expression for the purposes of this definition. A call to a destructor generated at the end of the lifetime of
an object other than a temporary object is an implicit full-expression. Conversions applied to the result of
an expression in order to satisfy the requirements of the language construct in which the expression appears
are also considered to be part of the full-expression.
[ Example:
struct S {
S(int i): I(i) { }
int& v() { return I; }
private:
int I;
};
S s1(1); // full-expression is call of S::S(int)
S s2 = 2; // full-expression is call of S::S(int)
void f() {
if (S(3).v()) // full-expression includes lvalue-to-rvalue and
// int to bool conversions, performed before
// temporary is deleted at end of full-expression
{ }
} —
end example ]
11 [ Note: The evaluation of a full-expression can include the evaluation of subexpressions that are not lexically
part of the full-expression. For example, subexpressions involved in evaluating default arguments (8.3.6) are
considered to be created in the expression that calls the function, not the expression that defines the default
argument. — end note ]
12 Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O
function, or calling a function that does any of those operations are all side effects, which are changes in the
state of the execution environment. Evaluation of an expression (or a sub-expression) in general includes
both value computations (including determining the identity of an object for glvalue evaluation and fetching
a value previously assigned to an object for prvalue evaluation) and initiation of side effects. When a call
to a library I/O function returns or an access to a volatile object is evaluated the side effect is considered
complete, even though some external actions implied by the call (such as the I/O itself) or by the volatile
access may not have completed yet.
§ 1.9 10

 c ISO/IEC N3242=11-0012
13 Sequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single
thread (1.10), which induces a partial order among those evaluations. Given any two evaluations A and B, if
A is sequenced before B, then the execution of A shall precede the execution of B. If A is not sequenced before
B and B is not sequenced before A, then A and B are unsequenced. [ Note: The execution of unsequenced
evaluations can overlap. — end note ] Evaluations A and B are indeterminately sequenced when either A
is sequenced before B or B is sequenced before A, but it is unspecified which. [ Note: Indeterminately
sequenced evaluations cannot overlap, but either could be executed first. — end note ]
14 Every value computation and side effect associated with a full-expression is sequenced before every value
computation and side effect associated with the next full-expression to be evaluated.8.
15 Except where noted, evaluations of operands of individual operators and of subexpressions of individual
expressions are unsequenced. [ Note: In an expression that is evaluated more than once during the execution
of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be
performed consistently in different evaluations. — end note ] The value computations of the operands of an
operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar
object is unsequenced relative to either anotherside effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined.
[ Example:
void f(int, int);
void g(int i, int* v) {
i = v[i++]; // the behavior is undefined
i = 7, i++, i++; // i becomes 9
i = i++ + 1; // the behavior is undefined
i = i + 1; // the value of i is incremented
f(i = -1, i = -1); // the behavior is undefined
}
— end example ]
When calling a function (whether or not the function is inline), every value computation and side effect
associated with any argument expression, or with the postfix expression designating the called function, is
sequenced before execution of every expression or statement in the body of the called function. [ Note: Value
computations and side effects associated with different argument expressions are unsequenced. — end note ]
Every evaluation in the calling function (including other function calls) that is not otherwise specifically
sequenced before or after the execution of the body of the called function is indeterminately sequenced with
respect to the execution of the called function.9 Several contexts in C++ cause evaluation of a function call,
even though no corresponding function call syntax appears in the translation unit. [ Example: Evaluation of
a new expression invokes one or more allocation and constructor functions; see 5.3.4. For another example,
invocation of a conversion function (12.3.2) can arise in contexts in which no function call syntax appears.
— end example ] The sequencing constraints on the execution of the called function (as described above)
are features of the function calls as evaluated, whatever the syntax of the expression that calls the function
might be.
1.10 Multi-threaded executions and data races [intro.multithread]
1 A thread of execution (also known as a thread) is a single flow of control within a program, including the initial
8) As specified in 12.2, after a full-expression is evaluated, a sequence of zero or more invocations of destructor functions for
temporary objects takes place, usually in reverse order of the construction of each temporary object.
9) In other words, function executions do not interleave with each other.
§ 1.10 11

 c ISO/IEC N3242=11-0012
invocation of a specific top-level function, and recursively including every function invocation subsequently
executed by the thread. [ Note: When one thread creates another, the initial call to the top-level function of
the new thread is executed by the new thread, not by the creating thread. — end note ] Every thread in a
program can potentially access every object and function in a program.10 Under a hosted implementation, a
C++ program can have more than one thread running concurrently. The execution of each thread proceeds
as defined by the remainder of this standard. The execution of the entire program consists of an execution of
all of its threads. [ Note: Usually the execution can be viewed as an interleaving of all its threads. However,
some kinds of atomic operations, for example, allow executions inconsistent with a simple interleaving, as
described below. — end note ] Under a freestanding implementation, it is implementation-defined whether
a program can have more than one thread of execution.
2 Implementations should ensure that all unblocked threads eventually make progress. [ Note: Standard
library functions may silently block on I/O or locks. Factors in the execution environment, including
externally-imposed thread priorities, may prevent an implementation from making certain guarantees of
forward progress. — end note ]
3 The value of an object visible to a thread T at a particular point is the initial value of the object, a value
assigned to the object by T , or a value assigned to the object by another thread, according to the rules
below. [ Note: In some cases, there may instead be undefined behavior. Much of this section is motivated
by the desire to support atomic operations with explicit and detailed visibility constraints. However, it also
implicitly supports a simpler view for more restricted programs. — end note ]
4 Two expression evaluations conflict if one of them modifies a memory location1.7 and the other one accesses
or modifies the same memory location.
5 The library defines a number of atomic operations (Clause 29) and operations on mutexes (Clause 30)
that are specially identified as synchronization operations. These operations play a special role in making
assignments in one thread visible to another. A synchronization operation on one or more memory locations
is either a consume operation, an acquire operation, a release operation, or both an acquire and release
operation. A synchronization operation without an associated memory location is a fence and can be either
an acquire fence, a release fence, or both an acquire and release fence. In addition, there are relaxed atomic
operations, which are not synchronization operations, and atomic read-modify-write operations, which have
special characteristics. [ Note: For example, a call that acquires a mutex will perform an acquire operation
on the locations comprising the mutex. Correspondingly, a call that releases the same mutex will perform a
release operation on those same locations. Informally, performing a release operation on A forces prior side
effects on other memory locations to become visible to other threads that later perform a consume or an
acquire operation on A. “Relaxed” atomic operations are not synchronization operations even though, like
synchronization operations, they cannot contribute to data races. — end note ]
6 All modifications to a particular atomic object M occur in some particular total order, called the modification
order of M . If A and B are modifications of an atomic object M and A happens before (as defined below) B,
then A shall precede B in the modification order of M , which is defined below. [ Note: This states that the
modification orders must respect the “happens before” relationship. — end note ] [ Note: There is a separate
order for each atomic object. There is no requirement that these can be combined into a single total order for
all objects. In general this will be impossible since different threads may observe modifications to different
objects in inconsistent orders. — end note ]
7 A release sequence from a release operation A on an atomic object M is a maximal contiguous sub-sequence
of side effects in the modification order of M , where the first operation is A, and every subsequent operation
— is performed by the same thread that performed A, or
10) An object with automatic or thread storage duration (3.7) is associated with one specific thread, and can be accessed by
a different thread only indirectly through a pointer or reference (3.9.2).
§ 1.10 12

 c ISO/IEC N3242=11-0012
— is an atomic read-modify-write operation.
8 Certain library calls synchronize with other library calls performed by another thread. For example, an
atomic store-release synchronizes with a load-acquire that takes its value from the store (29.3). [ Note:
Except in the specified cases, reading a later value does not necessarily ensure visibility as described below.
Such a requirement would sometimes interfere with efficient implementation. — end note ] [ Note: The
specifications of the synchronization operations define when one reads the value written by another. For
atomic objects, the definition is clear. All operations on a given mutex occur in a single total order. Each
mutex acquisition “reads the value written” by the last mutex release. — end note ]
9 An evaluation A carries a dependency to an evaluation B if
— the value of A is used as an operand of B, unless:
— B is an invocation of any specialization of std::kill_dependency (29.3), or
— A is the left operand of a built-in logical AND (&&, see 5.14) or logical OR (||, see 5.15) operator,
or
— A is the left operand of a conditional (?:, see 5.16) operator, or
— A is the left operand of the built-in comma (,) operator (5.18);
or
— A writes a scalar object or bit-field M , B reads the value written by A from M , and A is sequenced
before B, or
— for some evaluation X, A carries a dependency to X, and X carries a dependency to B.
[ Note: “Carries a dependency to” is a subset of “is sequenced before”, and is similarly strictly intra-thread.
— end note ]
10 An evaluation A is dependency-ordered before an evaluation B if
— A performs a release operation on an atomic object M , and, on another thread, B performs a consume
operation on M and reads a value written by any side effect in the release sequence headed by A, or
— for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.
[ Note: The relation “is dependency-ordered before” is analogous to “synchronizes with”, but uses release/-
consume in place of release/acquire. — end note ]
11 An evaluation A inter-thread happens before an evaluation B if
— A synchronizes with B, or
— A is dependency-ordered before B, or
— for some evaluation X
— A synchronizes with X and X is sequenced before B, or
— A is sequenced before X and X inter-thread happens before B, or
— A inter-thread happens before X and X inter-thread happens before B.
[ Note: The “inter-thread happens before” relation describes arbitrary concatenations of “sequenced before”,
“synchronizes with” and “dependency-ordered before” relationships, with two exceptions. The first exception
is that a concatenation is not permitted to end with “dependency-ordered before” followed by “sequenced
before”. The reason for this limitation is that a consume operation participating in a “dependency-ordered
before” relationship provides ordering only with respect to operations to which this consume operation
§ 1.10 13

 c ISO/IEC N3242=11-0012
actually carries a dependency. The reason that this limitation applies only to the end of such a concatenation
is that any subsequent release operation will provide the required ordering for a prior consume operation.
The second exception is that a concatenation is not permitted to consist entirely of “sequenced before”.
The reasons for this limitation are (1) to permit “inter-thread happens before” to be transitively closed and
(2) the “happens before” relation, defined below, provides for relationships consisting entirely of “sequenced
before”. — end note ]
12 An evaluation A happens before an evaluation B if:
— A is sequenced before B, or
— A inter-thread happens before B.
The implementation shall ensure that no program execution demonstrates a cycle in the “happens before”
relation. [ Note: This cycle would otherwise be possible only through the use of consume operations. — end
note ]
13 A visible side effect A on a scalar object or bit-field M with respect to a value computation B of M satisfies
the conditions:
— A happens before B and
— there is no other side effect X to M such that A happens before X and X happens before B.
The value of a non-atomic scalar object or bit-field M , as determined by evaluation B, shall be the value
stored by the visible side effect A. [ Note: If there is ambiguity about which side effect to a non-atomic
object or bit-field is visible, then the behavior is either unspecified or undefined. — end note ] [ Note: This
states that operations on ordinary objects are not visibly reordered. This is not actually detectable without
data races, but it is necessary to ensure that data races, as defined [CA 17] herebelow, and with suitable
restrictions on the use of atomics, correspond to data races in a simple interleaved (sequentially consistent)
execution. — end note ]
14 The visible sequence of side effects on an atomic object M , with respect to a value computation B of M , is
a maximal contiguous sub-sequence of side effects in the modification order of M , where the first side effect
is visible with respect to B, and for every side effect, it is not the case that B happens before it. The value
of an atomic object M , as determined by evaluation B, shall be the value stored by some operation in the
visible sequence of M with respect to B. [ Note: It can be shown that the visible sequence of side effects of
a value computation is unique given the coherence requirements below. — end note ]
15 If an operation A that modifies an atomic object M happens before an operation B that modifies M , then
A shall be earlier than B in the modification order of M . [ Note: This requirement is known as write-write
coherence. — end note ]
16 If a value computation A of an atomic object M happens before a value computation B of M , and A takes
its value from a side effect X on M , then the value computed by B shall either be the value stored by X or
the value stored by a side effect Y on M , where Y follows X in the modification order of M . [ Note: This
requirement is known as read-read coherence. — end note ]
17 If a value computation A of an atomic object M happens before an operation B on M , then A shall take
its value from a side effect X on M , where X precedes B in the modification order of M . [ Note: This
requirement is known as read-write coherence. — end note ]
18 If a side effect X on an atomic object M happens before a value computation B of M , then the evaluation
B shall take its value from X or from a side effect Y that follows X in the modification order of M . [ Note:
This requirement is known as write-read coherence. — end note ]
§ 1.10 14

 c ISO/IEC N3242=11-0012
19 [ Note: The four preceding coherence requirements effectively disallow compiler reordering of atomic operations to a single object, even if both operations are relaxed loads. This effectively makes the cache coherence
guarantee provided by most hardware available to C++ atomic operations. — end note ]
20 [ Note: The visible sequence of side effects depends on the “happens before” relation, which depends on the
values observed by loads of atomics, which we are restricting here. The intended reading is that there must
exist an association of atomic loads with modifications they observe that, together with suitably chosen
modification orders and the “happens before” relation derived as described above, satisfy the resulting
constraints as imposed here. — end note ]
21 The execution of a program contains a data race if it contains two conflicting actions in different threads,
at least one of which is not atomic, and neither happens before the other. Any such data race results in
undefined behavior. [ Note: It can be shown that programs that correctly use mutexes and memory_order_-
seq_cst operations to prevent all data races and use no other synchronization operations behave as if the
operations executed by their constituent threads were simply interleaved, with each value computation of an
object being taken from the last side effect on that object in that interleaving. This is normally referred to as
“sequential consistency”. However, this applies only to data-race-free programs, and data-race-free programs
cannot observe most program transformations that do not change single-threaded program semantics. In
fact, most single-threaded program transformations continue to be allowed, since any program that behaves
differently as a result must perform an undefined operation. — end note ]
22 [ Note: Compiler transformations that introduce assignments to a potentially shared memory location that
would not be modified by the abstract machine are generally precluded by this standard, since such an
assignment might overwrite another assignment by a different thread in cases in which an abstract machine
execution would not have encountered a data race. This includes implementations of data member assignment that overwrite adjacent members in separate memory locations. Reordering of atomic loads in cases
in which the atomics in question may alias is also generally precluded, since this may violate the “visible
sequence” rules. — end note ]
23 [ Note: Transformations that introduce a speculative read of a potentially shared memory location may not
preserve the semantics of the C++ program as defined in this standard, since they potentially introduce a
data race. However, they are typically valid in the context of an optimizing compiler that targets a specific
machine with well-defined semantics for data races. They would be invalid for a hypothetical machine that
is not tolerant of races or provides hardware race detection. — end note ]
24 The implementation may assume that any thread will eventually do one of the following:
— terminate,
— make a call to a library I/O function,
— access or modify a volatile object, or
— perform a synchronization operation or an atomic operation.
[ Note: This is intended to allow compiler transformations such as removal of empty loops, even when
termination cannot be proven. — end note ]
25 An implementation should ensure that the last value (in modification order) assigned by an atomic or
synchronization operation will become visible to all other threads in a finite period of time.
1.11 Acknowledgments [intro.ack]
1 The C++ programming language as described in this International Standard is based on the language as
described in Chapter R (Reference Manual) of Stroustrup: The C++ Programming Language (second edition,
Addison-Wesley Publishing Company, ISBN 0-201-53992-6, copyright 
 c 1991 AT&T). That, in turn, is based
§ 1.11 15

 c ISO/IEC N3242=11-0012
on the C programming language as described in Appendix A of Kernighan and Ritchie: The C Programming
Language (Prentice-Hall, 1978, ISBN 0-13-110163-3, copyright 
 c 1978 AT&T).
2 Portions of the library Clauses of this International Standard are based on work by P.J. Plauger, which was
published as The Draft Standard C++ Library (Prentice-Hall, ISBN 0-13-117003-1, copyright 
 c 1995 P.J.
Plauger).
3 POSIX
 R is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.
4 All rights in these originals are reserved.
§ 1.11 16

 c ISO/IEC N3242=11-0012
2 Lexical conventions [lex]
2.1 Separate translation [lex.separate]
1 The text of the program is kept in units called source files in this International Standard. A source file
together with all the headers (17.6.1.2) and source files included (16.2) via the preprocessing directive
#include, less any source lines skipped by any of the conditional inclusion (16.1) preprocessing directives, is
called a translation unit. [ Note: A C++ program need not all be translated at the same time. — end note ]
2 [ Note: Previously translated translation units and instantiation units can be preserved individually or in
libraries. The separate translation units of a program communicate (3.5) by (for example) calls to functions
whose identifiers have external linkage, manipulation of objects whose identifiers have external linkage, or
manipulation of data files. Translation units can be separately translated and then later linked to produce
an executable program (3.5). — end note ]
2.2 Phases of translation [lex.phases]
1 The precedence among the syntax rules of translation is specified by the following phases.11
1. Physical source file characters are mapped, in an implementation-defined manner, to the basic source
character set (introducing new-line characters for end-of-line indicators) if necessary. The set of physical source file characters accepted is implementation-defined. Trigraph sequences (2.4) are replaced
by corresponding single-character internal representations. Any source file character not in the basic
source character set (2.3) is replaced by the universal-character-name that designates that character. (An implementation may use any internal encoding, so long as an actual extended character
encountered in the source file, and the same extended character expressed in the source file as a
universal-character-name (i.e., using the \uXXXX notation), are handled equivalently except where this
replacement is reverted in a raw string literal.)
2. Each instance of a backslash character (\) immediately followed by a new-line character is deleted,
splicing physical source lines to form logical source lines. Only the last backslash on any physical
source line shall be eligible for being part of such a splice. If, as a result, a character sequence that
matches the syntax of a universal-character-name is produced, the behavior is undefined. A source file
that is not empty and that does not end in a new-line character, or that ends in a new-line character
immediately preceded by a backslash character before any such splicing takes place, shall be processed
as if an additional new-line character were appended to the file.
3. The source file is decomposed into preprocessing tokens (2.5) and sequences of white-space characters
(including comments). A source file shall not end in a partial preprocessing token or in a partial comment.12 Each comment is replaced by one space character. New-line characters are retained. Whether
each nonempty sequence of white-space characters other than new-line is retained or replaced by one
space character is unspecified. The process of dividing a source file’s characters into preprocessing tokens is context-dependent. [ Example: see the handling of < within a #include preprocessing directive.
— end example ]
11) Implementations must behave as if these separate phases occur, although in practice different phases might be folded
together.
12) A partial preprocessing token would arise from a source file ending in the first portion of a multi-character token that
requires a terminating sequence of characters, such as a header-name that is missing the closing " or >. A partial comment
would arise from a source file ending with an unclosed /* comment.
§ 2.2 17

 c ISO/IEC N3242=11-0012
4. Preprocessing directives are executed, macro invocations are expanded, and _Pragma unary operator
expressions are executed. If a character sequence that matches the syntax of a universal-character-name
is produced by token concatenation (16.3.3), the behavior is undefined. A #include preprocessing directive causes the named header or source file to be processed from phase 1 through phase 4, recursively.
All preprocessing directives are then deleted.
5. Each source character set member in a character literal or a string literal, as well as each escape
sequence and universal-character-name in a character literal or a non-raw string literal, is converted to
the corresponding member of the execution character set (2.14.3, 2.14.5); if there is no corresponding
member, it is converted to an implementation-defined member other than the null (wide) character.13
6. Adjacent string literal tokens are concatenated.
7. White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit. [ Note: The process of analyzing and translating the tokens may occasionally
result in one token being replaced by a sequence of other tokens (14.2). — end note ] [ Note: Source
files, translation units and translated translation units need not necessarily be stored as files, nor need
there be any one-to-one correspondence between these entities and any external representation. The
description is conceptual only, and does not specify any particular implementation. — end note ]
8. Translated translation units and instantiation units are combined as follows: [ Note: Some or all of
these may be supplied from a library. — end note ] Each translated translation unit is examined to
produce a list of required instantiations. [ Note: This may include instantiations which have been
explicitly requested (14.7.2). — end note ] The definitions of the required templates are located.
It is implementation-defined whether the source of the translation units containing these definitions
is required to be available. [ Note: An implementation could encode sufficient information into the
translated translation unit so as to ensure the source is not required here. — end note ] All the required
instantiations are performed to produce instantiation units. [ Note: These are similar to translated
translation units, but contain no references to uninstantiated templates and no template definitions.
— end note ] The program is ill-formed if any instantiation fails.
9. All external entity references are resolved. Library components are linked to satisfy external references
to entities not defined in the current translation. All such translator output is collected into a program
image which contains information needed for execution in its execution environment.
2.3 Character sets [lex.charset]
1 The basic source character set consists of 96 characters: the space character, the control characters representing horizontal tab, vertical tab, form feed, and new-line, plus the following 91 graphical characters:14
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
0 1 2 3 4 5 6 7 8 9
_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ∼ ! = , \ " ’
13) An implementation need not convert all non-corresponding source characters to the same execution character.
14) The glyphs for the members of the basic source character set are intended to identify characters from the subset of
ISO/IEC 10646 which corresponds to the ASCII character set. However, because the mapping from source file characters to the
source character set (described in translation phase 1) is specified as implementation-defined, an implementation is required to
document how the basic source characters are represented in source files.
§ 2.3 18

 c ISO/IEC N3242=11-0012
2 The universal-character-name construct provides a way to name other characters.
hex-quad:
hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
universal-character-name:
\u hex-quad
\U hex-quad hex-quad
The character designated by the universal-character-name \UNNNNNNNN is that character whose character
short name in ISO/IEC 10646 is NNNNNNNN; the character designated by the universal-character-name \uNNNN
is that character whose character short name in ISO/IEC 10646 is 0000NNNN. If the hexadecimal value for a
universal-character-name corresponds to a surrogate code point (in the range 0xD800–0xDFFF, inclusive),
the program is ill-formed. Additionally, if the hexadecimal value for a universal-character-name outside the
c-char-sequence, s-char-sequence, or r-char-sequence of a character or string literal corresponds to a control
character (in either of the ranges 0x00–0x1F or 0x7F–0x9F, both inclusive) or to a character in the basic
source character set, the program is ill-formed.15
3 The basic execution character set and the basic execution wide-character set shall each contain all the
members of the basic source character set, plus control characters representing alert, backspace, and carriage
return, plus a null character (respectively, null wide character), whose representation has all zero bits. For
each basic execution character set, the values of the members shall be non-negative and distinct from one
another. In both the source and execution basic character sets, the value of each character after 0 in the
above list of decimal digits shall be one greater than the value of the previous. The execution character set
and the execution wide-character set are implementation-defined supersets of the basic execution character
set and the basic execution wide-character set, respectively. The values of the members of the execution
character sets and the sets of additional members are locale-specific.
2.4 Trigraph sequences [lex.trigraph]
1 Before any other processing takes place, each occurrence of one of the following sequences of three characters
(“trigraph sequences”) is replaced by the single character indicated in Table 1.
Table 1 — Trigraph sequences
Trigraph Replacement Trigraph Replacement Trigraph Replacement
??= # ??( [ ??< {
??/ \ ??) ] ??> }
??’ ˆ ??! | ??- ∼
2 [ Example:
??=define arraycheck(a,b) a??(b??) ??!??! b??(a??)
becomes
#define arraycheck(a,b) a[b] || b[a]
— end example ]
3 No other trigraph sequence exists. Each ? that does not begin one of the trigraphs listed above is not
changed.
15) A sequence of characters resembling a universal-character-name in an r-char-sequence (2.14.5) does not form a universalcharacter-name.
§ 2.4 19

 c ISO/IEC N3242=11-0012
2.5 Preprocessing tokens [lex.pptoken]
preprocessing-token:
header-name
identifier
pp-number
character-literal
user-defined-character-literal
string-literal
user-defined-string-literal
preprocessing-op-or-punc
each non-white-space character that cannot be one of the above
1 Each preprocessing token that is converted to a token (2.7) shall have the lexical form of a keyword, an
identifier, a literal, an operator, or a punctuator.
2 A preprocessing token is the minimal lexical element of the language in translation phases 3 through 6. The
categories of preprocessing token are: header names, identifiers, preprocessing numbers, character literals
(including user-defined character literals), string literals (including user-defined string literals), preprocessing
operators and punctuators, and single non-white-space characters that do not lexically match the other
preprocessing token categories. If a ’ or a " character matches the last category, the behavior is undefined.
Preprocessing tokens can be separated by white space; this consists of comments (2.8), or white-space
characters (space, horizontal tab, new-line, vertical tab, and form-feed), or both. As described in Clause 16,
in certain circumstances during translation phase 4, white space (or the absence thereof) serves as more
than preprocessing token separation. White space can appear within a preprocessing token only as part of
a header name or between the quotation characters in a character literal or string literal.
3 If the input stream has been parsed into preprocessing tokens up to a given character:
— If the next character begins a sequence of characters that could be the prefix and initial double quote of
a raw string literal, such as R", the next preprocessing token shall be a raw string literal. Between the
initial and final double quote characters of the raw string, any transformations performed in phases 1
and 2 (trigraphs, universal-character-names, and line splicing) are reverted; this reversion shall apply
before any d-char, r-char, or delimiting parenthesis is identified. The raw string literal is defined as
the shortest sequence of characters that matches the raw-string pattern
encoding-prefixoptR raw-string
— Otherwise, if the next three characters are <:: and the subsequent character is neither : nor >, the <
is treated as a preprocessor token by itself and not as the first character of the alternative token <:.
— Otherwise, the next preprocessing token is the longest sequence of characters that could constitute a
preprocessing token, even if that would cause further lexical analysis to fail.
[ Example:
#define R "x"
const char* s = R"y"; // ill-formed raw string, not "x" "y"
— end example ]
4 [ Example: The program fragment 1Ex is parsed as a preprocessing number token (one that is not a valid
floating or integer literal token), even though a parse as the pair of preprocessing tokens 1 and Ex might
produce a valid expression (for example, if Ex were a macro defined as +1). Similarly, the program fragment
1E1 is parsed as a preprocessing number (one that is a valid floating literal token), whether or not E is a
macro name. — end example ]
§ 2.5 20

 c ISO/IEC N3242=11-0012
5 [ Example: The program fragment x+++++y is parsed as x ++ ++ + y, which, if x and y are of built-in types,
violates a constraint on increment operators, even though the parse x ++ + ++ y might yield a correct
expression. — end example ]
2.6 Alternative tokens [lex.digraph]
1 Alternative token representations are provided for some operators and punctuators.16
2 In all respects of the language, each alternative token behaves the same, respectively, as its primary token,
except for its spelling.17 The set of alternative tokens is defined in Table 2.
Table 2 — Alternative tokens
Alternative Primary Alternative Primary Alternative Primary
<% { and && and_eq &=
%> } bitor | or_eq |=
<: [ or || xor_eq ˆ=
:> ] xor ˆ not !
%: # compl ∼ not_eq !=
%:%: ## bitand &
2.7 Tokens [lex.token]
token:
identifier
keyword
literal
operator
punctuator
1 There are five kinds of tokens: identifiers, keywords, literals,18 operators, and other separators. Blanks,
horizontal and vertical tabs, newlines, formfeeds, and comments (collectively, “white space”), as described
below, are ignored except as they serve to separate tokens. [ Note: Some white space is required to separate otherwise adjacent identifiers, keywords, numeric literals, and alternative tokens containing alphabetic
characters. — end note ]
2.8 Comments [lex.comment]
1 The characters /* start a comment, which terminates with the characters */. These comments do not
nest. The characters // start a comment, which terminates with the next new-line character. If there is a
form-feed or a vertical-tab character in such a comment, only white-space characters shall appear between it
and the new-line that terminates the comment; no diagnostic is required. [ Note: The comment characters
16) These include “digraphs” and additional reserved words. The term “digraph” (token consisting of two characters) is not
perfectly descriptive, since one of the alternative preprocessing-tokens is %:%: and of course several primary tokens contain two
characters. Nonetheless, those alternative tokens that aren’t lexical keywords are colloquially known as “digraphs”.
17) Thus the “stringized” values (16.3.2) of [ and <: will be different, maintaining the source spelling, but the tokens can
otherwise be freely interchanged.
18) Literals include strings and character and numeric literals.
§ 2.8 21

 c ISO/IEC N3242=11-0012
//, /*, and */ have no special meaning within a // comment and are treated just like other characters.
Similarly, the comment characters // and /* have no special meaning within a /* comment. — end note ]
2.9 Header names [lex.header]
header-name:
< h-char-sequence >
" q-char-sequence "
h-char-sequence:
h-char
h-char-sequence h-char
h-char:
any member of the source character set except new-line and >
q-char-sequence:
q-char
q-char-sequence q-char
q-char:
any member of the source character set except new-line and "
1 Header name preprocessing tokens shall only appear within a #include preprocessing directive (16.2). The
sequences in both forms of header-names are mapped in an implementation-defined manner to headers or
to external source file names as specified in 16.2.
2 The appearance of either of the characters ’ or \ or of either of the character sequences /* or // in a
q-char-sequence or an h-char-sequence is conditionally supported with implementation-defined semantics, as
is the appearance of the character " in an h-char-sequence.19
2.10 Preprocessing numbers [lex.ppnumber]
pp-number:
digit
. digit
pp-number digit
pp-number identifier-nondigit
pp-number e sign
pp-number E sign
pp-number .
1 Preprocessing number tokens lexically include all integral literal tokens (2.14.2) and all floating literal tokens (2.14.4).
2 A preprocessing number does not have a type or a value; it acquires both after a successful conversion to an
integral literal token or a floating literal token.
2.11 Identifiers [lex.name]
identifier:
identifier-nondigit
identifier identifier-nondigit
identifier digit
identifier-nondigit:
nondigit
universal-character-name
other implementation-defined characters
19) Thus, a sequence of characters that resembles an escape sequence might result in an error, be interpreted as the character
corresponding to the escape sequence, or have a completely different meaning, depending on the implementation.
§ 2.11 22

 c ISO/IEC N3242=11-0012
nondigit: one of
a b c d e f g h i j k l m
n o p q r s t u v w x y z
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z _
digit: one of
0 1 2 3 4 5 6 7 8 9
1 An identifier is an arbitrarily long sequence of letters and digits. Each universal-character-name in an
identifier shall designate a character whose encoding in ISO 10646 falls into one of the ranges specified
in E.1. The initial element shall not be a universal-character-name designating a character whose encoding
falls into one of the ranges specified in E.2. Upper- and lower-case letters are different. All characters are
significant.20
2 The identifiers in Table 3 have a special meaning when appearing in a certain context. When referred to
in the grammar, these identifiers are used explicitly rather than using the identifier grammar production.
any ambiguity as to whether a given identifier has a special meaning is resolved to interpret the token as a
regular identifier.
Table 3 — Identifiers with special meaning
override final
3 In addition, some identifiers are reserved for use by C++ implementations and standard libraries (17.6.4.3.2)
and shall not be used otherwise; no diagnostic is required.
2.12 Keywords [lex.key]
1 The identifiers shown in Table 4 are reserved for use as keywords (that is, they are unconditionally treated
as keywords in phase 7) except in an attribute-token (7.6.1) [ Note: The export keyword is unused but is
reserved for future use. — end note ]:
2 Furthermore, the alternative representations shown in Table 5 for certain operators and punctuators (2.6)
are reserved and shall not be used otherwise:
2.13 Operators and punctuators [lex.operators]
1 The lexical representation of C++ programs includes a number of preprocessing tokens which are used in
the syntax of the preprocessor or are converted into tokens for operators and punctuators:
preprocessing-op-or-punc: one of
{ } [ ] # ## ( )
<: :> <% %> %: %:%: ; : ...
new delete ? :: . .*
+ - * / % ˆ & | ~
! = < > += -= *= /= %=
ˆ= &= |= << >> >>= <<= == !=
<= >= && || ++ -- , ->* ->
and and_eq bitand bitor compl not not_eq
or or_eq xor xor_eq
20) On systems in which linkers cannot accept extended characters, an encoding of the universal-character-name may be used
in forming valid external identifiers. For example, some otherwise unused character or sequence of characters may be used to
encode the \u in a universal-character-name. Extended characters may produce a long external identifier, but C++ does not
place a translation limit on significant characters for external identifiers. In C++, upper- and lower-case letters are considered
different for all identifiers, including external identifiers.
§ 2.13 23

 c ISO/IEC N3242=11-0012
Table 4 — Keywords
alignas continue friend register true
alignof decltype goto reinterpret_cast try
asm default if return typedef
auto delete inline short typeid
bool double int signed typename
break do long sizeof union
case dynamic_cast mutable static unsigned
catch else namespace static_assert using
char enum new static_cast virtual
char16_t explicit noexcept struct void
char32_t export nullptr switch volatile
class extern operator template wchar_t
const false private this while
constexpr float protected thread_local
const_cast for public throw
Table 5 — Alternative representations
and and_eq bitand bitor compl not
not_eq or or_eq xor xor_eq
Each preprocessing-op-or-punc is converted to a single token in translation phase 7 (2.2).
2.14 Literals [lex.literal]
2.14.1 Kinds of literals [lex.literal.kinds]
1 There are several kinds of literals.21
literal:
integer-literal
character-literal
floating-literal
string-literal
boolean-literal
pointer-literal
user-defined-literal
2.14.2 Integer literals [lex.icon]
integer-literal:
decimal-literal integer-suffixopt
octal-literal integer-suffixopt
hexadecimal-literal integer-suffixopt
decimal-literal:
nonzero-digit
decimal-literal digit
octal-literal:
0
octal-literal octal-digit
21) The term “literal” generally designates, in this International Standard, those tokens that are called “constants” in ISO C.
§ 2.14.2 24

 c ISO/IEC N3242=11-0012
hexadecimal-literal:
0x hexadecimal-digit
0X hexadecimal-digit
hexadecimal-literal hexadecimal-digit
nonzero-digit: one of
1 2 3 4 5 6 7 8 9
octal-digit: one of
0 1 2 3 4 5 6 7
hexadecimal-digit: one of
0 1 2 3 4 5 6 7 8 9
a b c d e f
A B C D E F
integer-suffix:
unsigned-suffix long-suffixopt
unsigned-suffix long-long-suffixopt
long-suffix unsigned-suffixopt
long-long-suffix unsigned-suffixopt
unsigned-suffix: one of
u U
long-suffix: one of
l L
long-long-suffix: one of
ll LL
1 An integer literal is a sequence of digits that has no period or exponent part. An integer literal may have
a prefix that specifies its base and a suffix that specifies its type. The lexically first digit of the sequence
of digits is the most significant. A decimal integer literal (base ten) begins with a digit other than 0 and
consists of a sequence of decimal digits. An octal integer literal (base eight) begins with the digit 0 and
consists of a sequence of octal digits.22 A hexadecimal integer literal (base sixteen) begins with 0x or 0X and
consists of a sequence of hexadecimal digits, which include the decimal digits and the letters a through f
and A through F with decimal values ten through fifteen. [ Example: the number twelve can be written 12,
014, or 0XC. — end example ]
2 The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be
represented.
3 If an integer literal cannot be represented by any type in its list and an extended integer type (3.9.1) can
represent its value, it may have that extended integer type. If all of the types in the list for the literal are
signed, the extended integer type shall be signed. If all of the types in the list for the literal are unsigned, the
extended integer type shall be unsigned. If the list contains both signed and unsigned types, the extended
integer type may be signed or unsigned. A program is ill-formed if one of its translation units contains an
integer literal that cannot be represented by any of the allowed types.
2.14.3 Character literals [lex.ccon]
character-literal:
’ c-char-sequence ’
u’ c-char-sequence ’
U’ c-char-sequence ’
L’ c-char-sequence ’
c-char-sequence:
c-char
c-char-sequence c-char
22) The digits 8 and 9 are not octal digits.
§ 2.14.3 25

 c ISO/IEC N3242=11-0012
Table 6 — Types of integer constants
Suffix Decimal constant Octal or hexadecimal constant
none int int
long int unsigned int
long long int long int
unsigned long int
long long int
unsigned long long int
u or U unsigned int unsigned int
unsigned long int unsigned long int
unsigned long long int unsigned long long int
l or L long int long int
long long int unsigned long int
long long int
unsigned long long int
Both u or U unsigned long int unsigned long int
and l or L unsigned long long int unsigned long long int
ll or LL long long int long long int
unsigned long long int
Both u or U unsigned long long int unsigned long long int
and ll or LL
c-char:
any member of the source character set except
the single-quote ’, backslash \, or new-line character
escape-sequence
universal-character-name
escape-sequence:
simple-escape-sequence
octal-escape-sequence
hexadecimal-escape-sequence
simple-escape-sequence: one of
\’ \" \? \\
\a \b \f \n \r \t \v
octal-escape-sequence:
\ octal-digit
\ octal-digit octal-digit
\ octal-digit octal-digit octal-digit
hexadecimal-escape-sequence:
\x hexadecimal-digit
hexadecimal-escape-sequence hexadecimal-digit
1 A character literal is one or more characters enclosed in single quotes, as in ’x’, optionally preceded by
one of the letters u, U, or L, as in u’y’, U’z’, or L’x’, respectively. A character literal that does not begin
with u, U, or L is an ordinary character literal, also referred to as a narrow-character literal. An ordinary
character literal that contains a single c-char has type char, with value equal to the numerical value of the
encoding of the c-char in the execution character set. An ordinary character literal that contains more than
one c-char is a multicharacter literal. A multicharacter literal has type int and implementation-defined
value.
§ 2.14.3 26

 c ISO/IEC N3242=11-0012
2 A character literal that begins with the letter u, such as u’y’, is a character literal of type char16_t. The
value of a char16_t literal containing a single c-char is equal to its ISO 10646 code point value, provided that
the code point is representable with a single 16-bit code unit. (That is, provided it is a basic multi-lingual
plane code point.) If the value is not representable within 16 bits, the program is ill-formed. A char16_t
literal containing multiple c-chars is ill-formed. A character literal that begins with the letter U, such as
U’z’, is a character literal of type char32_t. The value of a char32_t literal containing a single c-char is
equal to its ISO 10646 code point value. A char32_t literal containing multiple c-chars is ill-formed. A
character literal that begins with the letter L, such as L’x’, is a wide-character literal. A wide-character
literal has type wchar_t.23 The value of a wide-character literal containing a single c-char has value equal
to the numerical value of the encoding of the c-char in the execution wide-character set, unless the c-char
has no representation in the execution wide-character set, in which case the value is implementation-defined.
[ Note: The type wchar_t is able to represent all members of the execution wide-character set (see 3.9.1).
— end note ]. The value of a wide-character literal containing multiple c-chars is implementation-defined.
3 Certain nongraphic characters, the single quote ’, the double quote ", the question mark ?,24 and the
backslash \, can be represented according to Table 7. The double quote " and the question mark ?, can
be represented as themselves or by the escape sequences \" and \? respectively, but the single quote ’
and the backslash \ shall be represented by the escape sequences \’ and \\ respectively. Escape sequences
in which the character following the backslash is not listed in Table 7 are conditionally-supported, with
implementation-defined semantics. An escape sequence specifies a single character.
Table 7 — Escape sequences
new-line NL(LF) \n
horizontal tab HT \t
vertical tab VT \v
backspace BS \b
carriage return CR \r
form feed FF \f
alert BEL \a
backslash \ \\
question mark ? \?
single quote ’ \’
double quote " \"
octal number ooo \ooo
hex number hhh \xhhh
4 The escape \ooo consists of the backslash followed by one, two, or three octal digits that are taken to specify
the value of the desired character. The escape \xhhh consists of the backslash followed by x followed by one
or more hexadecimal digits that are taken to specify the value of the desired character. There is no limit to
the number of digits in a hexadecimal sequence. A sequence of octal or hexadecimal digits is terminated by
the first character that is not an octal digit or a hexadecimal digit, respectively. The value of a character
literal is implementation-defined if it falls outside of the implementation-defined range defined for char (for
literals with no prefix), char16_t (for literals prefixed by ’u’), char32_t (for literals prefixed by ’U’), or
wchar_t (for literals prefixed by ’L’).
5 A universal-character-name is translated to the encoding, in the appropriate execution character set, of the
character named. If there is no such encoding, the universal-character-name is translated to an implementationdefined encoding. [ Note: In translation phase 1, a universal-character-name is introduced whenever an actual
extended character is encountered in the source text. Therefore, all extended characters are described in
23) They are intended for character sets where a character does not fit into a single byte.
24) Using an escape sequence for a question mark can avoid accidentally creating a trigraph.
§ 2.14.3 27

 c ISO/IEC N3242=11-0012
terms of universal-character-names. However, the actual compiler implementation may use its own native
character set, so long as the same results are obtained. — end note ]
2.14.4 Floating literals [lex.fcon]
floating-literal:
fractional-constant exponent-partopt floating-suffixopt
digit-sequence exponent-part floating-suffixopt
fractional-constant:
digit-sequenceopt. digit-sequence
digit-sequence .
exponent-part:
e signopt digit-sequence
E signopt digit-sequence
sign: one of
+ -
digit-sequence:
digit
digit-sequence digit
floating-suffix: one of
f l F L
1 A floating literal consists of an integer part, a decimal point, a fraction part, an e or E, an optionally signed
integer exponent, and an optional type suffix. The integer and fraction parts both consist of a sequence of
decimal (base ten) digits. Either the integer part or the fraction part (not both) can be omitted; either the
decimal point or the letter e (or E ) and the exponent (not both) can be omitted. The integer part, the
optional decimal point and the optional fraction part form the significant part of the floating literal. The
exponent, if present, indicates the power of 10 by which the significant part is to be scaled. If the scaled
value is in the range of representable values for its type, the result is the scaled value if representable, else the
larger or smaller representable value nearest the scaled value, chosen in an implementation-defined manner.
The type of a floating literal is double unless explicitly specified by a suffix. The suffixes f and F specify
float, the suffixes l and L specify long double. If the scaled value is not in the range of representable
values for its type, the program is ill-formed.
2.14.5 String literals [lex.string]
string-literal:
encoding-prefixopt" s-char-sequenceopt"
encoding-prefixoptR raw-string
encoding-prefix:
u8
uUL
s-char-sequence:
s-char
s-char-sequence s-char
s-char:
any member of the source character set except
the double-quote ", backslash \, or new-line character
escape-sequence
universal-character-name
§ 2.14.5 28

 c ISO/IEC N3242=11-0012
raw-string:
" d-char-sequenceopt( r-char-sequenceopt) d-char-sequenceopt"
r-char-sequence:
r-char
r-char-sequence r-char
r-char:
any member of the source character set, except
a right parenthesis ) followed by the initial d-char-sequence
(which may be empty) followed by a double quote ".
d-char-sequence:
d-char
d-char-sequence d-char
d-char:
any member of the basic source character set except:
space, the left parenthesis (, the right parenthesis ), the backslash \,
and the control characters representing horizontal tab,
vertical tab, form feed, and newline.
1 A string literal is a sequence of characters (as defined in 2.14.3) surrounded by double quotes, optionally
prefixed by R, u8, u8R, u, uR, U, UR, L, or LR, as in "...", R"(...)", u8"...", u8R"**(...)**", u"...",
uR"*~(...)*~", U"...", UR"zzz(...)zzz", L"...", or LR"(...)", respectively.
2 A string literal that has an R in the prefix is a raw string literal. The d-char-sequence serves as a delimiter.
The terminating d-char-sequence of a raw-string is the same sequence of characters as the initial d-charsequence. A d-char-sequence shall consist of at most 16 characters.
3 [ Note: The characters ’(’ and ’)’ are permitted in a raw-string. Thus, R"delimiter((a|b))delimiter"
is equivalent to "(a|b)". — end note ]
4 [ Note: A source-file new-line in a raw string literal results in a new-line in the resulting execution stringliteral. Assuming no whitespace at the beginning of lines in the following example, the assert will succeed:
const char *p = R"(a\
b
c)";
assert(std::strcmp(p, "a\\\nb\nc") == 0);
— end note ]
5 [ Example: The raw string
R"a(
)\
a"
)a"
is equivalent to "\n)\\\na\"\n". The raw string
R"(??)"
is equivalent to "\?\?". The raw string
R"#(
)??="
)#"
§ 2.14.5 29

 c ISO/IEC N3242=11-0012
is equivalent to "\n)\?\?=\"\n". — end example ]
6 After translation phase 6, a string literal that does not begin with an encoding-prefix is an ordinary string
literal, and is initialized with the given characters.
7 A string literal that begins with u8, such as u8"asdf", is a UTF-8 string literal and is initialized with the
given characters as encoded in UTF-8.
8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow
string literal has type “array of n const char”, where n is the size of the string as defined below, and has
static storage duration (3.7).
9 A string literal that begins with u, such as u"asdf", is a char16_t string literal. A char16_t string literal
has type “array of n const char16_t”, where n is the size of the string as defined below; it has static storage
duration and is initialized with the given characters. A single c-char may produce more than one char16_t
character in the form of surrogate pairs.
10 A string literal that begins with U, such as U"asdf", is a char32_t string literal. A char32_t string literal
has type “array of n const char32_t”, where n is the size of the string as defined below; it has static storage
duration and is initialized with the given characters.
11 A string literal that begins with L, such as L"asdf", is a wide string literal. A wide string literal has type
“array of n const wchar_t”, where n is the size of the string as defined below; it has static storage duration
and is initialized with the given characters.
12 Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementationdefined. The effect of attempting to modify a string literal is undefined.
13 In translation phase 6 (2.2), adjacent string literals are concatenated. If both string literals have the same
encoding-prefix, the resulting concatenated string literal has that encoding-prefix. If one string literal has
no encoding-prefix, it is treated as a string literal of the same encoding-prefix as the other operand. If a
UTF-8 string literal token is adjacent to a wide string literal token, the program is ill-formed. Any other
concatenations are conditionally supported with implementation-defined behavior. [ Note: This concatenation is an interpretation, not a conversion. Because the interpretation happens in translation phase 6 (after
each character from a literal has been translated into a value from the appropriate character set), a string
literal’s initial rawness has no effect on the interpretation or well-formedness of the concatenation. — end
note ] Table 8 has some examples of valid concatenations.
Table 8 — String literal concatenations
Source Means Source Means Source Means
u"a" u"b" u"ab" U"a" U"b" U"ab" L"a" L"b" L"ab"
u"a" "b" u"ab" U"a" "b" U"ab" L"a" "b" L"ab"
"a" u"b" u"ab" "a" U"b" U"ab" "a" L"b" L"ab"
Characters in concatenated strings are kept distinct.
[ Example:
"\xA" "B"
contains the two characters ’\xA’ and ’B’ after concatenation (and not the single hexadecimal character
’\xAB’). — end example ]
14 After any necessary concatenation, in translation phase 7 (2.2), ’\0’ is appended to every string literal so
that programs that scan a string can find its end.
§ 2.14.5 30

 c ISO/IEC N3242=11-0012
15 Escape sequences and universal-character-names in non-raw string literals have the same meaning as in
character literals (2.14.3), except that the single quote ’ is representable either by itself or by the escape
sequence \’, and the double quote " shall be preceded by a \. In a narrow string literal, a universal-charactername may map to more than one char element due to multibyte encoding. The size of a char32_t or wide
string literal is the total number of escape sequences, universal-character-names, and other characters, plus
one for the terminating U’\0’ or L’\0’. The size of a char16_t string literal is the total number of escape
sequences, universal-character-names, and other characters, plus one for each character requiring a surrogate
pair, plus one for the terminating u’\0’. [ Note: The size of a char16_t string literal is the number of code
units, not the number of characters. — end note ] Within char32_t and char16_t literals, any universalcharacter-names shall be within the range 0x0 to 0x10FFFF. The size of a narrow string literal is the total
number of escape sequences and other characters, plus at least one for the multibyte encoding of each
universal-character-name, plus one for the terminating ’\0’.
2.14.6 Boolean literals [lex.bool]
boolean-literal:
false
true
1 The Boolean literals are the keywords false and true. Such literals are prvalues and have type bool.
2.14.7 Pointer literals [lex.nullptr]
pointer-literal:
nullptr
1 The pointer literal is the keyword nullptr. It is a prvalue of type std::nullptr_t. [ Note: std::nullptr_t
is a distinct type that is neither a pointer type nor a pointer to member type; rather, a prvalue of this type is
a null pointer constant and can be converted to a null pointer value or null member pointer value. See 4.10
and 4.11. — end note ]
2.14.8 User-defined literals [lex.ext]
user-defined-literal:
user-defined-integer-literal
user-defined-floating-literal
user-defined-string-literal
user-defined-character-literal
user-defined-integer-literal:
decimal-literal ud-suffix
octal-literal ud-suffix
hexadecimal-literal ud-suffix
user-defined-floating-literal:
fractional-constant exponent-partopt ud-suffix
digit-sequence exponent-part ud-suffix
user-defined-string-literal:
string-literal ud-suffix
user-defined-character-literal:
character-literal ud-suffix
ud-suffix:
identifier
1 If a token matches both user-defined-literal and another literal kind, it is treated as the latter. [ Example:
123_km, 1.2LL, "Hello"s are all user-defined-literals, but 12LL is an integer-literal. — end example ]
§ 2.14.8 31

 c ISO/IEC N3242=11-0012
2 A user-defined-literal is treated as a call to a literal operator or literal operator template (13.5.8). To
determine the form of this call for a given user-defined-literal L with ud-suffix X, the literal-operator-id
whose literal suffix identifier is X is looked up in the context of L using the rules for unqualified name
lookup (3.4.1). Let S be the set of declarations found by this lookup. S shall not be empty.
3 If L is a user-defined-integer-literal, let n be the literal without its ud-suffix. If S contains a literal operator
with parameter type unsigned long long, the literal L is treated as a call of the form
operator "" X (n ULL)
Otherwise, S shall contain a raw literal operator or a literal operator template (13.5.8) but not both. If S
contains a raw literal operator, the literal L is treated as a call of the form
operator "" X ("n")
Otherwise (S contains a literal operator template), L is treated as a call of the form
operator "" X <’c1’, ’c2’, ... ’ck’>()
where n is the source character sequence c1c2...ck. [ Note: The sequence c1c2...ck can only contain characters
from the basic source character set. — end note ]
4 If L is a user-defined-floating-literal, let f be the literal without its ud-suffix. If S contains a literal operator
with parameter type long double, the literal L is treated as a call of the form
operator "" X (f L)
Otherwise, S shall contain a raw literal operator or a literal operator template (13.5.8) but not both. If S
contains a raw literal operator, the literal L is treated as a call of the form
operator "" X ("f")
Otherwise (S contains a literal operator template), L is treated as a call of the form
operator "" X <’c1’, ’c2’, ... ’ck’>()
where f is the source character sequence c1c2...ck. [ Note: The sequence c1c2...ck can only contain characters
from the basic source character set. — end note ]
5 If L is a user-defined-string-literal, let str be the literal without its ud-suffix and let len be the number of
code units in str (i.e., its length excluding the terminating null character). The literal L is treated as a call
of the form
operator "" X (str, len)
6 If L is a user-defined-character-literal, let ch be the literal without its ud-suffix. S shall contain a literal
operator (13.5.8) whose only parameter has the type ch and the literal L is treated as a call of the form
operator "" X (ch)
7 [ Example:
long double operator "" w(long double);
std::string operator "" w(const char16_t*, size_t);
unsigned operator "" w(const char*);
int main() {
1.2w; // calls operator "" w(1.2L)
u"one"w; // calls operator "" w(u"one", 3)
§ 2.14.8 32

 c ISO/IEC N3242=11-0012
12w; // calls operator "" w("12")
"two"w; // error: no applicable literal operator
}
— end example ]
8 In translation phase 6 (2.2), adjacent string literals are concatenated and user-defined-string-literals are
considered string literals for that purpose. During concatenation, ud-suffixes are removed and ignored and
the concatenation process occurs as described in 2.14.5. At the end of phase 6, if a string literal is the result
of a concatenation involving at least one user-defined-string-literal, all the participating user-defined-stringliterals shall have the same ud-suffix and that suffix is applied to the result of the concatenation.
9 [ Example:
int main() {
L"A" "B" "C"x; // OK: same as L"ABC"x
"P"x "Q" "R"y; // error: two different ud-suffixes
}
— end example ]
§ 2.14.8 33

 c ISO/IEC N3242=11-0012
3 Basic concepts [basic]
1 [ Note: This Clause presents the basic concepts of the C++ language. It explains the difference between an
object and a name and how they relate to the value categories for expressions. It introduces the concepts
of a declaration and a definition and presents C++’s notion of type, scope, linkage, and storage duration.
The mechanisms for starting and terminating a program are discussed. Finally, this Clause presents the
fundamental types of the language and lists the ways of constructing compound types from these. — end
note ]
2 [ Note: This Clause does not cover concepts that affect only a single part of the language. Such concepts
are discussed in the relevant Clauses. — end note ]
3 An entity is a value, object, reference, function, enumerator, type, class member, template, template specialization, namespace, parameter pack, or this.
4 A name is a use of an identifier (2.11), operator-function-id (13.5), literal-operator-id (13.5.8), conversionfunction-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).
5 Every name that denotes an entity is introduced by a declaration. Every name that denotes a label is
introduced either by a goto statement (6.6.4) or a labeled-statement (6.1).
6 A variable is introduced by the declaration of a reference other than a non-static data member or of an
object. The variable’s name denotes the reference or object.
7 Some names denote types or templates. In general, whenever a name is encountered it is necessary to
determine whether that name denotes one of these entities before continuing to parse the program that
contains it. The process that determines this is called name lookup (3.4).
8 Two names are the same if
— they are identifiers composed of the same character sequence, or
— they are operator-function-ids formed with the same operator, or
— they are conversion-function-ids formed with the same type, or
— they are template-ids that refer to the same class or function (14.4), or
— they are the names of literal operators (13.5.8) formed with the same literal suffix identifier.
9 A name used in more than one translation unit can potentially refer to the same entity in these translation
units depending on the linkage (3.5) of the name specified in each translation unit.
3.1 Declarations and definitions [basic.def]
1 A declaration (Clause 7) may introduce one or more names into a translation unit or redeclare names
introduced by previous declarations. If so, the declaration specifies the interpretation and attributes of these
names. A declaration may also have effects including:
— a static assertion (Clause 7),
— controlling template instantiation (14.7.2),
— use of attributes (Clause 7), and
§ 3.1 34

 c ISO/IEC N3242=11-0012
— nothing (in the case of an empty-declaration).
2 A declaration is a definition unless it declares a function without specifying the function’s body (8.4),
it contains the extern specifier (7.1.1) or a linkage-specification25 (7.5) and neither an initializer nor a
function-body, it declares a static data member in a class definition (9.4), it is a class name declaration (9.1),
it is an opaque-enum-declaration (7.2), or it is a typedef declaration (7.1.3), a using-declaration (7.3.3), a
static_assert-declaration (Clause 7), an attribute-declaration (Clause 7), an empty-declaration (Clause 7),
or a using-directive (7.3.4).
[ Example: all but one of the following are definitions:
int a; // defines a
extern const int c = 1; // defines c
int f(int x) { return x+a; } // defines f and defines x
struct S { int a; int b; }; // defines S, S::a, and S::b
struct X { // defines X
int x; // defines non-static data member x
static int y; // declares static data member y
X(): x(0) { } // defines a constructor of X
};
int X::y = 1; // defines X::y
enum { up, down }; // defines up and down
namespace N { int d; } // defines N and N::d
namespace N1 = N; // defines N1
X anX; // defines anX
whereas these are just declarations:
extern int a; // declares a
extern const int c; // declares c
int f(int); // declares f
struct S; // declares S
typedef int Int; // declares Int
extern X anotherX; // declares anotherX
using N::d; // declares d
— end example ]
3 [ Note: In some circumstances, C++ implementations implicitly define the default constructor (12.1), copy
constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4) member functions. — end note ] [ Example: given
#include <string>
struct C {
std::string s; // std::string is the standard library class (Clause 21)
};
int main() {
C a;
C b = a;
b = a;
}
25) Appearing inside the braced-enclosed declaration-seq in a linkage-specification does not affect whether a declaration is a
definition.
§ 3.1 35

 c ISO/IEC N3242=11-0012
the implementation will implicitly define functions to make the definition of C equivalent to
struct C {
std::string s;
C() : s() { }
C(const C& x): s(x.s) { }
C(C&& x): s(static_cast<std::string&&>(x.s)) { }
// : s(std::move(x.s)) { }
C& operator=(const C& x) { s = x.s; return *this; }
C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
// { s = std::move(x.s); return *this; }
~C() { }
};
— end example ]
4 [ Note: A class name can also be implicitly declared by an elaborated-type-specifier (7.1.6.3). — end note ]
5 A program is ill-formed if the definition of any object gives the object an incomplete type (3.9).
3.2 One definition rule [basic.def.odr]
1 No translation unit shall contain more than one definition of any variable, function, class type, enumeration
type, or template.
2 An expression is potentially evaluated unless it is an unevaluated operand (Clause 5) or a subexpression
thereof. A variable or non-overloaded function whose name appears as a potentially-evaluated expression is
odr-used unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and
the lvalue-to-rvalue conversion (4.1) is immediately applied. this is odr-used if it appears as a potentiallyevaluated expression (including as the result of the implicit transformation in the body of a non-static
member function (9.3.1)). A virtual member function is odr-used if it is not pure. A member of a set of
candidate functions is odr-used if it is selected by overload resolution when referred to from a potentiallyevaluated expression. [ Note: This covers calls to named functions (5.2.2), operator overloading (Clause 13),
user-defined conversions (12.3.2), allocation function for placement new (5.3.4), as well as non-default initialization (8.5). A copy constructor or move constructor is odr-used even if the call is actually elided by
the implementation. — end note ] An allocation or deallocation function for a class is odr-used by a new
expression appearing in a potentially-evaluated expression as specified in 5.3.4 and 12.5. A deallocation
function for a class is odr-used by a delete expression appearing in a potentially-evaluated expression as
specified in 5.3.5 and 12.5. A non-placement allocation or deallocation function for a class is odr-used by
the definition of a constructor of that class. A non-placement deallocation function for a class is odr-used
by the definition of the destructor of that class, or by being selected by the lookup at the point of definition
of a virtual destructor (12.4).26 A copy-assignment function for a class is odr-used by an implicitly-defined
copy-assignment function for another class as specified in 12.8. A move-assignment function for a class is
odr-used by an implicitly-defined move-assignment function for another class as specified in 12.8. A default constructor for a class is odr-used by default initialization or value initialization as specified in 8.5. A
constructor for a class is odr-used as specified in 8.5. A destructor for a class is odr-used as specified in 12.4.
3 Every program shall contain exactly one definition of every non-inline function or variable that is odr-used
in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found
in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and
12.8). An inline function shall be defined in every translation unit in which it is odr-used.
26) An implementation is not required to call allocation and deallocation functions from constructors or destructors; however,
this is a permissible implementation technique.
§ 3.2 36

 c ISO/IEC N3242=11-0012
4 Exactly one definition of a class is required in a translation unit if the class is used in a way that requires the
class type to be complete. [ Example: the following complete translation unit is well-formed, even though it
never defines X:
struct X; // declare X as a struct type
struct X* x1; // use X in pointer formation
X* x2; // use X in pointer formation
— end example ] [ Note: The rules for declarations and expressions describe in which contexts complete class
types are required. A class type T must be complete if:
— an object of type T is defined (3.1), or
— a non-static class data member of type T is declared (9.2), or
— T is used as the object type or array element type in a new-expression (5.3.4), or
— an lvalue-to-rvalue conversion is applied to a glvalue referring to an object of type T (4.1), or
— an expression is converted (either implicitly or explicitly) to type T (Clause 4, 5.2.3, 5.2.7, 5.2.9, 5.4),
or
— an expression that is not a null pointer constant, and has type other than void*, is converted to the
type pointer to T or reference to T using an implicit conversion (Clause 4), a dynamic_cast (5.2.7) or
a static_cast (5.2.9), or
— a class member access operator is applied to an expression of type T (5.2.5), or
— the typeid operator (5.2.8) or the sizeof operator (5.3.3) is applied to an operand of type T, or
— a function with a return type or argument type of type T is defined (3.1) or called (5.2.2), or
— a class with a base class of type T is defined (Clause 10), or
— an lvalue of type T is assigned to (5.17), or
— the type T is the subject of an alignof expression (5.3.6), or
— an exception-declaration has type T, reference to T, or pointer to T (15.3).
— end note ]
5 There can be more than one definition of a class type (Clause 9), enumeration type (7.2), inline function with
external linkage (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member
of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for
which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition
appears in a different translation unit, and provided the definitions satisfy the following requirements. Given
such an entity named D defined in more than one translation unit, then
— each definition of D shall consist of the same sequence of tokens; and
— in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined
within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after
matching of partial template specialization (14.8.3), except that a name can refer to a const object
with internal or no linkage if the object has the same literal type in all definitions of D, and the object
is initialized with a constant expression (5.19), and the value (but not the address) of the object is
used, and the object has the same value in all definitions of D; and
— in each definition of D, corresponding entities shall have the same language linkage; and
§ 3.2 37

 c ISO/IEC N3242=11-0012
— in each definition of D, the overloaded operators referred to, the implicit calls to conversion functions,
constructors, operator new functions and operator delete functions, shall refer to the same function,
or to a function defined within the definition of D; and
— in each definition of D, a default argument used by an (implicit or explicit) function call is treated as
if its token sequence were present in the definition of D; that is, the default argument is subject to
the three requirements described above (and, if the default argument has sub-expressions with default
arguments, this requirement applies recursively).27
— if D is a class with an implicitly-declared constructor (12.1), it is as if the constructor was implicitly
defined in every translation unit where it is odr-used, and the implicit definition in every translation
unit shall call the same constructor for a base class or a class member of D. [ Example:
//translation unit 1:
struct X {
X(int);
X(int, int);
};
X::X(int = 0) { }
class D: public X { };
D d2; // X(int) called by D()
//translation unit 2:
struct X {
X(int);
X(int, int);
};
X::X(int = 0, int = 0) { }
class D: public X { }; // X(int, int) called by D();
// D()’s implicit definition
// violates the ODR
— end example ]
If D is a template and is defined in more than one translation unit, then the last four requirements from the
list above shall apply to names from the template’s enclosing scope used in the template definition (14.6.3),
and also to dependent names at the point of instantiation (14.6.2). If the definitions of D satisfy all these
requirements, then the program shall behave as if there were a single definition of D. If the definitions of D
do not satisfy these requirements, then the behavior is undefined.
3.3 Scope [basic.scope]
3.3.1 Declarative regions and scopes [basic.scope.declarative]
1 Every name is introduced in some portion of program text called a declarative region, which is the largest part
of the program in which that name is valid, that is, in which that name may be used as an unqualified name
to refer to the same entity. In general, each particular name is valid only within some possibly discontiguous
portion of program text called its scope. To determine the scope of a declaration, it is sometimes convenient
to refer to the potential scope of a declaration. The scope of a declaration is the same as its potential scope
unless the potential scope contains another declaration of the same name. In that case, the potential scope
of the declaration in the inner (contained) declarative region is excluded from the scope of the declaration
in the outer (containing) declarative region.
27) 8.3.6 describes how default argument names are looked up.
§ 3.3.1 38

 c ISO/IEC N3242=11-0012
2 [ Example: in
int j = 24;
int main() {
int i = j, j;
j = 42;
}
the identifier j is declared twice as a name (and used twice). The declarative region of the first j includes
the entire example. The potential scope of the first j begins immediately after that j and extends to the
end of the program, but its (actual) scope excludes the text between the , and the }. The declarative region
of the second declaration of j (the j immediately before the semicolon) includes all the text between { and
}, but its potential scope excludes the declaration of i. The scope of the second declaration of j is the same
as its potential scope. — end example ]
3 The names declared by a declaration are introduced into the scope in which the declaration occurs, except
that the presence of a friend specifier (11.3), certain uses of the elaborated-type-specifier (7.1.6.3), and
using-directives (7.3.4) alter this general behavior.
4 Given a set of declarations in a single declarative region, each of which specifies the same unqualified name,
— they shall all refer to the same entity, or all refer to functions and function templates; or
— exactly one declaration shall declare a class name or enumeration name that is not a typedef name
and the other declarations shall all refer to the same variable or enumerator, or all refer to functions
and function templates; in this case the class name or enumeration name is hidden (3.3.10). [ Note: A
namespace name or a class template name must be unique in its declarative region (7.3.2, Clause 14).
— end note ]
[ Note: These restrictions apply to the declarative region into which a name is introduced, which is not necessarily the same as the region in which the declaration occurs. In particular, elaborated-type-specifiers (7.1.6.3)
and friend declarations (11.3) may introduce a (possibly not visible) name into an enclosing namespace; these
restrictions apply to that region. Local extern declarations (3.5) may introduce a name into the declarative
region where the declaration appears and also introduce a (possibly not visible) name into an enclosing
namespace; these restrictions apply to both regions. — end note ]
5 [ Note: The name lookup rules are summarized in 3.4. — end note ]
3.3.2 Point of declaration [basic.scope.pdecl]
1 The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its
initializer (if any), except as noted below. [ Example:
int x = 12;
{ int x = x; }
Here the second x is initialized with its own (indeterminate) value. — end example ]
2 [ Note: a name from an outer scope remains visible up to the point of declaration of the name that hides
it.[ Example:
const int i = 2;
{ int i[i]; }
declares a block-scope array of two integers. — end example ] — end note ]
§ 3.3.2 39

 c ISO/IEC N3242=11-0012
3 The point of declaration for a class or class template first declared by a class-specifier is immediately after
the identifier or simple-template-id (if any) in its class-head (Clause 9). The point of declaration for an
enumeration is immediately after the identifier (if any) in either its enum-specifier (7.2) or its first opaqueenum-declaration (7.2), whichever comes first. The point of declaration of [FI 11] a template aliasan alias
template immediately follows the identifier for the alias being declared.
4 The point of declaration for an enumerator is immediately after its enumerator-definition.[ Example:
const int x = 12;
{ enum { x = x }; }
Here, the enumerator x is initialized with the value of the constant x, namely 12. — end example ]
5 After the point of declaration of a class member, the member name can be looked up in the scope of its
class. [ Note: this is true even if the class is an incomplete class. For example,
struct X {
enum E { z = 16 };
int b[X::z]; // OK
};
— end note ]
6 The point of declaration of a class first declared in an elaborated-type-specifier is as follows:
— for a declaration of the form
class-key attribute-specifier-seqopt identifier ;
the identifier is declared to be a class-name in the scope that contains the declaration, otherwise
— for an elaborated-type-specifier of the form
class-key identifier
if the elaborated-type-specifier is used in the decl-specifier-seq or parameter-declaration-clause of a
function defined in namespace scope, the identifier is declared as a class-name in the namespace that
contains the declaration; otherwise, except as a friend declaration, the identifier is declared in the
smallest non-class, non-function-prototype scope that contains the declaration. [ Note: These rules
also apply within templates. — end note ] [ Note: Other forms of elaborated-type-specifier do not
declare a new name, and therefore must refer to an existing type-name. See 3.4.4 and 7.1.6.3. — end
note ]
7 The point of declaration for an injected-class-name (Clause 9) is immediately following the opening brace
of the class definition.
8 The point of declaration for a function-local predefined variable (8.4) is immediately before the function-body
of a function definition.
9 The point of declaration for a template parameter is immediately after its complete template-parameter.
[ Example:
typedef unsigned char T;
template<class T
= T // lookup finds the typedef name of unsigned char
, T // lookup finds the template parameter
N = 0> struct A { };
§ 3.3.2 40

 c ISO/IEC N3242=11-0012
— end example ]
10 [ Note: Friend declarations refer to functions or classes that are members of the nearest enclosing namespace,
but they do not introduce new names into that namespace (7.3.1.2). Function declarations at block scope
and variable declarations with the extern specifier at block scope refer to declarations that are members of
an enclosing namespace, but they do not introduce new names into that scope. — end note ]
11 [ Note: For point of instantiation of a template, see 14.6.4.1. — end note ]
3.3.3 Block scope [basic.scope.local]
1 A name declared in a block (6.3) is local to that block; it has block scope. Its potential scope begins at its
point of declaration (3.3.2) and ends at the end of its block. A variable declared at block scope is a local
variable.
2 The potential scope of a function parameter name (including one appearing in a lambda-declarator) or of
a function-local predefined variable in a function definition (8.4) begins at its point of declaration. If the
function has a function-try-block the potential scope of a parameter or of a function-local predefined variable
ends at the end of the last associated handler, otherwise it ends at the end of the outermost block of
the function definition. A parameter name shall not be redeclared in the outermost block of the function
definition nor in the outermost block of any handler associated with a function-try-block.
3 The name declared in an exception-declaration is local to the handler and shall not be redeclared in the
outermost block of the handler.

4 Names declared in the for-init-statement, the for-range-declaration, and in the condition of if, while, for,
and switch statements are local to the if, while, for, or switch statement (including the controlled
statement), and shall not be redeclared in a subsequent condition of that statement nor in the outermost
block (or, for the if statement, any of the outermost blocks) of the controlled statement; see 6.4.
3.3.4 Function prototype scope [basic.scope.proto]
1 In a function declaration, or in any function declarator except the declarator of a function definition (8.4),
names of parameters (if supplied) have function prototype scope, which terminates at the end of the nearest
enclosing function declarator.
3.3.5 Function scope [basic.funscope]
1 Labels (6.1) have function scope and may be used anywhere in the function in which they are declared. Only
labels have function scope.

3.3.6 Namespace scope [basic.scope.namespace]
1 The declarative region of a namespace-definition is its namespace-body. The potential scope denoted by
an original-namespace-name is the concatenation of the declarative regions established by each of the
namespace-definitions in the same declarative region with that original-namespace-name. 