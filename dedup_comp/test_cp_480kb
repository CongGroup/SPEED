30 Remarks: The expression inside noexcept is equivalent to:
is_nothrow_assignable<T1&, U&&>::value &&
is_nothrow_assignable<T2&, V&&>::value
31 Requires: is_assignable<first_type&, U&&>::value is true and is_assignable<second_type&,
V&&>::value is true.
32 Effects: Assigns to first with std::forward<first_typeU>(p.first) and to second with
std::forward<second_typeV >(p.second).
33 Returns: *this.
void swap(pair& p) noexcept;
34 Remarks: The expression inside noexcept is equivalent to:
noexcept(swap(first, p.first)) &&
noexcept(swap(second, p.second))
35 Requires: first shall be swappable with (17.6.3.2) p.first and second shall be swappable with
p.second.
36 Effects: Swaps first with p.first and second with p.second.
20.3.3 Specialized algorithms [pairs.spec]
template <class T1, class T2>
bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
1 Returns: x.first == y.first && x.second == y.second.
template <class T1, class T2>
bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
2 Returns: x.first < y.first || (!(y.first < x.first) && x.second < y.second).
template <class T1, class T2>
bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);
3 Returns: !(x == y)
template <class T1, class T2>
bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);
4 Returns: y < x
template <class T1, class T2>
bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);
5 Returns: !(x < y)
template <class T1, class T2>
bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);
6 Returns: !(y < x)
template<class T1, class T2> void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
7 Effects: x.swap(y)
§ 20.3.3 501

 c ISO/IEC N3242=11-0012
template <class T1, class T2>
pair<V1, V2> make_pair(T1&& x, T2&& y) noexcept;
8 The expression inside noexcept is equivalent to:
is_nothrow_constructible<V1, T1&&>::value &&
is_nothrow_constructible<V2, T2&&>::value
9 Returns: pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y));
where V1 and V2 are determined as follows: Let Ui be decay<Ti>::type for each Ti. Then each Vi is
X& if Ui equals reference_wrapper<X>, otherwise Vi is Ui.
10 [ Example: In place of:
return pair<int, double>(5, 3.1415926); // explicit types
a C++ program may contain:
return make_pair(5, 3.1415926); // types are deduced
— end example ]
20.3.4 Tuple-like access to pair [pair.astuple]
tuple_size<pair<T1, T2> >::value
1 Returns: Integral constant expression.
2 Value: 2.
tuple_element<0, pair<T1, T2> >::type
3 Value: the type T1.
tuple_element<1, pair<T1, T2> >::type
4 Value: the type T2.
template<size_t I, class T1, class T2>
typename tuple_element<I, std::pair<T1, T2> >::type& get(pair<T1, T2>&) noexcept;
template<size_t I, class T1, class T2>
const typename tuple_element<I, std::pair<T1, T2> >::type& get(const pair<T1, T2>&) noexcept;
5 Returns: If I == 0 returns p.first; if I == 1 returns p.second; otherwise the program is ill-formed.
template<size_t I, class T1, class T2>
typename tuple_element<I, std::pair<T1, T2> >::type&& get(std::pair<T1, T2>&&) noexcept;
6 Returns: If I == 0 returns std::forward<T1&&>(p.first); if I == 1 returns std::forward<T2&&>(p.second);
otherwise the program is ill-formed.
20.3.5 Piecewise construction [pair.piecewise]
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
§ 20.3.5 502

 c ISO/IEC N3242=11-0012
1 The struct piecewise_construct_t is an empty structure type used as a unique type to disambiguate
constructor and function overloading. Specifically, pair has a constructor with piecewise_construct_t as
the first argument, immediately followed by two tuple (20.4) arguments used for piecewise construction of
the elements of the pair object.
20.4 Tuples [tuple]
20.4.1 In general [tuple.general]
1 This subclause describes the tuple library that provides a tuple type as the class template tuple that can
be instantiated with any number of arguments. Each template argument specifies the type of an element
in the tuple. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of
tuple with two arguments is similar to an instantiation of pair with the same two arguments. See 20.3.
2 Header <tuple> synopsis
namespace std {
// 20.4.2, class template tuple:
template <class... Types> class tuple;
// 20.4.2.4, tuple creation functions:
const unspecified ignore;
template <class... Types>
tuple<VTypes...> make_tuple(Types&&...);
template <class... Types>
tuple<Types...> forward_as_tuple(Types&&...) noexcept;
template<class... Types>
tuple<Types&...> tie(Types&...) noexcept;
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>&, const tuple<UTypes...>&);
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&&, const tuple<UTypes...>&);
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>&, tuple<UTypes...>&&);
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&&, tuple<UTypes...>&&);
// 20.4.2.5, tuple helper classes:
template <class T> class tuple_size; // undefined
template <class T> class tuple_size<const T>;
template <class T> class tuple_size<volatile T>;
template <class T> class tuple_size<const volatile T>;
template <class... Types> class tuple_size<tuple<Types...> >;
template <size_t I, class T> class tuple_element; // undefined
template <size_t I, class T> class tuple_element<I, const T>;
template <size_t I, class T> class tuple_element<I, volatile T>;
template <size_t I, class T> class tuple_element<I, const volatile T>;
template <size_t I, class... Types> class tuple_element<I, tuple<Types...> >;
// 20.4.2.6, element access:
§ 20.4.1 503

 c ISO/IEC N3242=11-0012
template <size_t I, class... Types>
typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>&) noexcept;
template <size_t I, class... types>
typename tuple_element<I, tuple<Types...> >::type&& get(tuple<Types...>&&) noexcept;
template <size_t I, class... types>
typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>&) noexcept;
// 20.4.2.7, relational operators:
template<class... TTypes, class... UTypes>
bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, class... UTypes>
bool operator<(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, class... UTypes>
bool operator!=(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, class... UTypes>
bool operator>(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, class... UTypes>
bool operator<=(const tuple<TTypes...>&, const tuple<UTypes...>&);
template<class... TTypes, class... UTypes>
bool operator>=(const tuple<TTypes...>&, const tuple<UTypes...>&);
// 20.4.2.8, allocator-related traits
template <class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc>;
// 20.4.2.9, specialized algorithms:
template <class... Types>
void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept;
}
20.4.2 Class template tuple [tuple.tuple]
namespace std {
template <class... Types>
class tuple {
public:
// 20.4.2.1, tuple construction
constexpr tuple();
explicit tuple(const Types&...);
template <class... UTypes>
explicit tuple(UTypes&&...) noexcept;
tuple(const tuple&) = default;
tuple(tuple&&) = default;
template <class... UTypes>
tuple(const tuple<UTypes...>&);
template <class... UTypes>
tuple(tuple<UTypes...>&&) noexcept;
template <class U1, class U2>
tuple(const pair<U1, U2>&); // iff sizeof...(Types) == 2
template <class U1, class U2>
tuple(pair<U1, U2>&&) noexcept; // iff sizeof...(Types) == 2
§ 20.4.2 504

 c ISO/IEC N3242=11-0012
// allocator-extended constructors
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, const Types&...);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, const UTypes&&...);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, const tuple&);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, tuple&&);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template <class Alloc, class U1, class U2>
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template <class Alloc, class U1, class U2>
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
// 20.4.2.2, tuple assignment
tuple& operator=(const tuple&);
tuple& operator=(tuple&&) noexcept;
template <class... UTypes>
tuple& operator=(const tuple<UTypes...>&);
template <class... UTypes>
tuple& operator=(tuple<UTypes...>&&) noexcept;
template <class U1, class U2>
tuple& operator=(const pair<U1, U2>&); // iff sizeof...(Types) == 2
template <class U1, class U2>
tuple& operator=(pair<U1, U2>&&) noexcept; // iff sizeof...(Types) == 2
// 20.4.2.3, tuple swap
void swap(tuple&) noexcept;
};
}
20.4.2.1 Construction [tuple.cnstr]
1 For each tuple constructor, an exception is thrown only if the construction of one of the types in Types
throws an exception.
2 In the constructor descriptions that follow, let i be in the range [0,sizeof...(Types)) in order, Ti be the
ith type in Types, and Ui be the ith type in a template parameter pack named UTypes, where indexing is
zero-based.
constexpr tuple();
3 Requires: is_default_constructible<Ti>::value is true for all i.
4 Effects: Value initializes each element.
explicit tuple(const Types&...);
§ 20.4.2.1 505

 c ISO/IEC N3242=11-0012
5 Requires: is_copy_constructible<Ti>::value is true for all i.
6 Effects: Initializes each element with the value of the corresponding parameter.
template <class... UTypes>
explicit tuple(UTypes&&... u) noexcept;
7 Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:
is_nothrow_constructible<Ti, Ui&&>::value
where Ti is the ith type in Types and Ui is the ith type in UTypes.
8 Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, Ui&&>::value is true
for all i.
9 Effects: Initializes the elements in the tuple with the corresponding value in std::forward<UTypes>(u).
10 Remark: This constructor shall not participate in overload resolution unless each type in UTypes is
implicitly convertible to its corresponding type in Types.
tuple(const tuple& u) = default;
11 Requires: is_copy_constructible<Ti>::value is true for all i.
12 Effects: Initializes each element of *this with the corresponding element of u.
tuple(tuple&& u) = default;
13 Requires: is_move_constructible<Ti>::value is true for all i.
14 Effects: For all i, initializes the ith element of *this with std::forward<Ti>(get<i>(u)).
template <class... UTypes> tuple(const tuple<UTypes...>& u);
15 Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, const Ui&>::value
is true for all i.
16 Effects: Constructs each element of *this with the corresponding element of u.
17 Remark: This constructor shall not participate in overload resolution unless const Ui& is implicitly
convertible to Ti for all i.
template <class... UTypes> tuple(tuple<UTypes...>&& u) noexcept;
18 Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:
is_nothrow_constructible<Ti, Ui&&>::value
where Ti is the ith type in Types and Ui is the ith type in UTypes.
19 Requires: sizeof...(Types) == sizeof...(UTypes). is_constructible<Ti, UI&&>::value is true
for all i.
20 Effects: For all i, initializes the ith element of *this with std::forward<Ui>(get<i>(u)).
21 Remark: This constructor shall not participate in overload resolution unless each type in UTypes is
implicitly convertible to its corresponding type in Types.
template <class U1, class U2> tuple(const pair<U1, U2>& u);
§ 20.4.2.1 506

 c ISO/IEC N3242=11-0012
22 Requires: sizeof...(Types) == 2. is_constructible<T0, const U1&>::value is true for the first
type T0 in Types and is_constructible<T1, const U2&>::value is true for the second type T1 in
Types.
23 Effects: Constructs the first element with u.first and the second element with u.second.
24 Remark: This constructor shall not participate in overload resolution unless const U1& is implicitly
convertible to T0 and const U2& is implicitly convertible to T1.
template <class U1, class U2> tuple(pair<U1, U2>&& u) noexcept;
25 Remark: The expression inside noexcept is equivalent to:
is_nothrow_constructible<T1, U1&&>::value &&
is_nothrow_constructible<T2, U2&&>::value
where T1 and T2 are the first and second types, respectively, in Types.
26 Requires: sizeof...(Types) == 2. is_constructible<T0, U1&&>::value is true for the first type
T0
in Types and is_constructible<T1, U2&&>::value is true for the second type T1 in Types.
27 Effects: Initializes the first element with std::forward<U1>(u.first) and the second element with
std::forward<U2>(u.second).
28 Remark: This constructor shall not participate in overload resolution unless U1 is implicitly convertible
to T0 and U2 is implicitly convertible to T1.
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, const Types&...);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, const UTypes&&...);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, const tuple&);
template <class Alloc>
tuple(allocator_arg_t, const Alloc& a, tuple&&);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
template <class Alloc, class... UTypes>
tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
template <class Alloc, class U1, class U2>
tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
template <class Alloc, class U1, class U2>
tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
29 Requires: Alloc shall meet the requirements for an Allocator (17.6.3.5).
30 Effects: Equivalent to the preceding constructors except that each element is constructed with usesallocator construction (20.6.7.2).
20.4.2.2 Assignment [tuple.assign]
1 For each tuple assignment operator, an exception is thrown only if the assignment of one of the types in
Types throws an exception. In the function descriptions that follow, let i be in the range [0,sizeof...(Types)
) in order, Ti be the ith type in Types, and Ui be the ith type in a template parameter pack named UTypes,
where indexing is zero-based.
§ 20.4.2.2 507

 c ISO/IEC N3242=11-0012
tuple& operator=(const tuple& u);
2 Requires: is_copy_assignable<Ti>::value is true for all i.
3 Effects: Assigns each element of u to the corresponding element of *this.
4 Returns: *this
tuple& operator=(tuple&& u) noexcept;
5 Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:
is_nothrow_move_assignable<Ti>::value
where Ti is the ith type in Types.
6 Requires: is_move_assignable<Ti>::value is true for all i.
7 Effects: For all i, assigns std::forward<Ti>(get<i>(u)) to get<i>(*this).
8 Returns: *this.
template <class... UTypes>
tuple& operator=(const tuple<UTypes...>& u);
9 Requires: sizeof...(Types) == sizeof...(UTypes) and is_assignable<Ti&, const Ui&>::value
is true for all i.
10 Effects: Assigns each element of u to the corresponding element of *this.
11 Returns: *this
template <class... UTypes>
tuple& operator=(tuple<UTypes...>&& u) noexcept;
12 Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:
is_nothrow_assignable<Ti&, Ui&&>::value
where Ti is the ith type in Types and Ui is the ith type in UTypes.
13 Requires: Each type in Types shall satisfy the requirements of MoveAssignable (Table 22) from the
corresponding type in UTypes. is_assignable<Ti&, Ui&&>::value == true for all i. sizeof...(Types)
== sizeof...(UTypes).
14 Effects: For all i, assigns std::forward<Ui>(get<i)>(u)) to get<i>(*this).
15 Returns: *this.
template <class U1, class U2> tuple& operator=(const pair<U1, U2>& u);
16 Requires: sizeof...(Types) == 2. is_assignable<T0&, const U1&>::value is true for the first
type T0 in Types and is_assignable<T1&, const U2&>::value is true for the second type T1 in
Types.
17 Effects: Assigns u.first to the first element of *this and u.second to the second element of *this.
18 Returns: *this
template <class U1, class U2> tuple& operator=(pair<U1, U2>&& u) noexcept;
19 The expression inside noexcept is equivalent to:
§ 20.4.2.2 508

 c ISO/IEC N3242=11-0012
is_nothrow_assignable<T1&, U1&&>::value &&
is_nothrow_assignable<T2&, U2&&>::value
where T1 and T2 are the first and second types, respectively, in Types.
20 Requires: sizeof...(Types) == 2. is_assignable<T0&, U1&&>::value is true for the first type T0
in Types and is_assignable<T1&, U2&&>::value is true for the second type T1 in Types.
21 Effects: Assigns std::forward<U1>(u.first) to the first element of *this and
std::forward<U2>(u.second) to the second element of *this.
22 Returns: *this.
20.4.2.3 swap [tuple.swap]
void swap(tuple& rhs) noexcept;
1 Remark: The expression inside noexcept is equivalent to the logical and of the following expressions:
noexcept(swap(declval<Ti&>>(), declval<Ti&>()))
where T1 is the ith type in Types.
2 Requires: Each element in *this shall be swappable with (17.6.3.2) the corresponding element in rhs.
3 Effects: Calls swap for each element in *this and its corresponding element in rhs.
4 Throws: Nothing unless one of the element-wise swap calls throws an exception.
20.4.2.4 Tuple creation functions [tuple.creation]
1 In the function descriptions that follow, let i be in the range [0,sizeof...(TTypes)) in order and let Ti
be the ith type in a template parameter pack named TTypes; let j be in the range [0,sizeof...(UTypes))
in order and U
j be the jth type in a template parameter pack named UTypes, where indexing is zero-based.
template<class... Types>
tuple<VTypes...> make_tuple(Types&&... t);
2 Let Ui be decay<Ti>::type for each Ti in Types. Then each Vi in VTypes is X& if Ui equals
reference_wrapper<X>, otherwise Vi is Ui.
3 Returns: tuple<VTypes...>(std::forward<Types>(t)...).
4 [ Example:
int i; float j;
make_tuple(1, ref(i), cref(j))
creates a tuple of type
tuple<int, int&, const float&>
— end example ]
template<class... Types>
tuple<Types&&...> forward_as_tuple(Types&&... t) noexcept;
§ 20.4.2.4 509

 c ISO/IEC N3242=11-0012
5 Effects: Constructs a tuple of references to the arguments in t suitable for forwarding as arguments to
a function. Because the result may contain references to temporary variables, a program shall ensure
that the return value of this function does not outlive any of its arguments. (e.g., the program should
typically not store the result in a named variable).
6 Returns: tuple<Types&&...>(std::forward<Types>(t)...)
template<class... Types>
tuple<Types&...> tie(Types&... t) noexcept;
7 Returns: tuple<Types&>(t...). When an argument in t is ignore, assigning any value to the
corresponding tuple element has no effect.
8 [ Example: tie functions allow one to create tuples that unpack tuples into variables. ignore can be
used for elements that are not needed:
int i; std::string s;
tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
// i == 42, s == "C++"
— end example ]
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
9 Requires: is_copy_constructible<Ti>::value is true for all i and is_copy_constructible<Uj>::value
is true for all j.
10 Returns: A tuple object constructed by initializing its first sizeof...(TTypes) elements from the corresponding elements of t and initializing its last sizeof...(UTypes) elements from the corresponding
elements of u.
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&& t, const tuple<UTypes...>& u);
11 Requires: is_move_constructible<Ti>::value is true for all i and is_copy_constructible<Uj>::value
is true for all j.
12 Returns: A tuple object constructed by initializing the ith element with std::forward<Ti>(get<i>(t))
for all i and initializing the (j + sizeof ...(TTypes))th element with get<j>(u) for all j.
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>& t, tuple<UTypes...>&& u);
13 Requires: is_copy_constructible<Ti>::value is true for all i and is_move_constructible<Uj>::value
is true for all j.
14 Returns: A tuple object constructed by initializing the ith element with get<i>(t) for all i and
initializing the (j + sizeof ...(TTypes))th element with std::forward<Uj>(get<j>(u)) for all j.
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(tuple<TTypes...>&& t, tuple<UTypes...>&& u);
15 Requires: is_move_constructible<Ti>::value is true for all i and is_move_constructible<Uj>::value
is true for all j.
16 Returns: A tuple object constructed by initializing the ith element with std::forward<Ti>(get<i>(t))
for all i and initializing the (j + sizeof ...(TTypes))th element with std::forward<Uj>(get<j>(u)) for
all j.
§ 20.4.2.4 510

 c ISO/IEC N3242=11-0012
20.4.2.5 Tuple helper classes [tuple.helper]
template <class... Types>
class tuple_size<tuple<Types...> >
: public integral_constant<size_t, sizeof...(Types)> { };
template <size_t I, class... Types>
class tuple_element<I, tuple<Types...> > {
public:
typedef TI type;
};
1 Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
2 Type: TI is the type of the Ith element of Types, where indexing is zero-based.
template <class T> class tuple_size<const T>;
template <class T> class tuple_size<volatile T>;
template <class T> class tuple_size<const volatile T>;
3 Let TS denote tuple_size<T> of the cv-unqualified type T. Then each of the three templates shall
meet the UnaryTypeTrait requirements (20.9.1) with a BaseCharacteristic of
integral_constant<remove_cv<decltype(TS::value)>::type, TS::value>
template <size_t I, class T> class tuple_element<I, const T>;
template <size_t I, class T> class tuple_element<I, volatile T>;
template <size_t I, class T> class tuple_element<I, const volatile T>;
Let TE denote tuple_element<I, T> of the cv-unqualified type T. Then each of the three templates
shall meet the TransformationTrait requirements (20.9.1) with a member typedef type that names
the following type:
— for the first specialization, add_const<TE::type>::type,
— for the second specialization, add_volatile<TE::type>::type, and
— for the third specialization, add_cv<TE::type>::type.
20.4.2.6 Element access [tuple.elem]
template <size_t I, class... Types>
typename tuple_element<I, tuple<Types...> >::type& get(tuple<Types...>& t) noexcept;
1 Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
2 Returns: A reference to the Ith element of t, where indexing is zero-based.
template <size_t I, class... types>
typename tuple_element<I, tuple<Types...> >::type&& get(tuple<Types...>&& t) noexcept;
3 Effects: Equivalent to return std::forward<typename tuple_element<I, tuple<Types...> >
::type&&>(get<I>(t));
4 Note: if a T in Types is some reference type X&, the return type is X&, not X&&. However, if the element
type is a non-reference type T, the return type is T&&.
template <size_t I, class... Types>
typename tuple_element<I, tuple<Types...> >::type const& get(const tuple<Types...>& t) noexcept;
§ 20.4.2.6 511

 c ISO/IEC N3242=11-0012
5 Requires: I < sizeof...(Types). The program is ill-formed if I is out of bounds.
6 Returns: A const reference to the Ith element of t, where indexing is zero-based.
7 [ Note: Constness is shallow. If a T in Types is some reference type X&, the return type is X&, not
const X&. However, if the element type is non-reference type T, the return type is const T&. This is
consistent with how constness is defined to work for member variables of reference type. — end note ]
8 [ Note: The reason get is a nonmember function is that if this functionality had been provided as a
member function, code where the type depended on a template parameter would have required using
the template keyword. — end note ]
20.4.2.7 Relational operators [tuple.rel]
template<class... TTypes, class... UTypes>
bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
1 Requires: For all i, where 0 <= i and i < sizeof...(Types), get<i>(t) == get<i>(u) is a valid
expression returning a type that is convertible to bool. sizeof...(TTypes) == sizeof...(UTypes).
2 Returns: true iff get<i>(t) == get<i>(u) for all i. For any two zero-length tuples e and f, e == f
returns true.
3 Effects: The elementary comparisons are performed in order from the zeroth index upwards. No
comparisons or element accesses are performed after the first equality comparison that evaluates to
false.
template<class... TTypes, class... UTypes>
bool operator<(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
4 Requires: For all i, where 0 <= i and i < sizeof...(Types), get<i>(t) < get<i>(u) and get<i>(u)
< get<i>(t) are valid expressions returning types that are convertible to bool. sizeof...(TTypes)
== sizeof...(UTypes).
5 Returns: The result of a lexicographical comparison between t and u. The result is defined as:
(bool)(get<0>(t) < get<0>(u)) || (!(bool)(get<0>(u) < get<0>(t)) && ttail < utail), where
rtail for some tuple r is a tuple containing all but the first element of r. For any two zero-length tuples
e and f, e < f returns false.
template<class... TTypes, class... UTypes>
bool operator!=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
6 Returns: !(t == u).
template<class... TTypes, class... UTypes>
bool operator>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
7 Returns: u < t.
template<class... TTypes, class... UTypes>
bool operator<=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
8 Returns: !(u < t)
template<class... TTypes, class... UTypes>
bool operator>=(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
9 Returns: !(t < u)
§ 20.4.2.7 512

 c ISO/IEC N3242=11-0012
10 [ Note: The above definitions for comparison operators do not require ttail (or utail) to be constructed. It may
not even be possible, as t and u are not required to be copy constructible. Also, all comparison operators
are short circuited; they do not perform element accesses beyond what is required to determine the result
of the comparison. — end note ]
20.4.2.8 Tuple traits [tuple.traits]
template <class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc> : true_type { };
Requires: Alloc shall be an Allocator (17.6.3.5).
1 [ Note: Specialization of this trait informs other library components that tuple can be constructed
with an allocator, even though it does not have a nested allocator_type. — end note ]
20.4.2.9 Tuple specialized algorithms [tuple.special]
template <class... Types>
void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept;
1 Remark: The expression inside noexcept is equivalent to:
noexcept(x.swap(y))
2 Effects: x.swap(y)
20.5 Class template bitset [template.bitset]
Header <bitset> synopsis
#include <string>
#include <iosfwd> // for istream, ostream
namespace std {
template <size_t N> class bitset;
// 20.5.4 bitset operators:
template <size_t N>
bitset<N> operator&(const bitset<N>&, const bitset<N>&) noexcept;
template <size_t N>
bitset<N> operator|(const bitset<N>&, const bitset<N>&) noexcept;
template <size_t N>
bitset<N> operator^(const bitset<N>&, const bitset<N>&) noexcept;
template <class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
template <class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
}
1 The header <bitset> defines a class template and several related functions for representing and manipulating
fixed-size sequences of bits.
namespace std {
template<size_t N> class bitset {
§ 20.5 513

 c ISO/IEC N3242=11-0012
public:
// bit reference:
class reference {
friend class bitset;
reference() noexcept;
public:
~reference() noexcept;
reference& operator=(bool x) noexcept; // for b[i] = x;
reference& operator=(const reference&) noexcept; // for b[i] = b[j];
bool operator~() const noexcept; // flips the bit
operator bool() const noexcept; // for x = b[i];
reference& flip() noexcept; // for b[i].flip();
};
// 20.5.1 constructors:
constexpr bitset() noexcept;
constexpr bitset(unsigned long long val) noexcept;
template<class charT, class traits, class Allocator>
explicit bitset(
const basic_string<charT,traits,Allocator>& str,
typename basic_string<charT,traits,Allocator>::size_type pos = 0,
typename basic_string<charT,traits,Allocator>::size_type n =
basic_string<charT,traits,Allocator>::npos,
charT zero = charT(’0’), charT one = charT(’1’));
template <class charT>
explicit bitset(
const charT* str,
typename basic_string<charT>::size_type n = basic_string<charT>::npos,
charT zero = charT(’0’), charT one = charT(’1’));
// 20.5.2 bitset operations:
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
bitset<N>& operator<<=(size_t pos) noexcept;
bitset<N>& operator>>=(size_t pos) noexcept;
bitset<N>& set() noexcept;
bitset<N>& set(size_t pos, bool val = true);
bitset<N>& reset() noexcept;
bitset<N>& reset(size_t pos);
bitset<N> operator~() const noexcept;
bitset<N>& flip() noexcept;
bitset<N>& flip(size_t pos);
// element access:
constexpr bool operator[](size_t pos) const noexcept; // for b[i];
reference operator[](size_t pos) noexcept; // for b[i];
unsigned long to_ulong() const;
unsigned long long to_ullong() const;
template <class charT = char,
class traits = char_traits<charT>,
class Allocator = allocator<charT> >
basic_string<charT, traits, Allocator>
to_string(charT zero = charT(’0’), charT one = charT(’1’)) const;
§ 20.5 514

 c ISO/IEC N3242=11-0012
size_t count() const noexcept;
constexpr size_t size() noexcept;
bool operator==(const bitset<N>& rhs) const noexcept;
bool operator!=(const bitset<N>& rhs) const noexcept;
bool test(size_t pos) const;
bool all() const noexcept;
bool any() const noexcept;
bool none() const noexcept;
bitset<N> operator<<(size_t pos) const noexcept;
bitset<N> operator>>(size_t pos) const noexcept;
};
// 20.5.3 hash support
template <class T> struct hash;
template <size_t N> struct hash<bitset<N> >;
}
2 The class template bitset<N>describes an object that can store a sequence consisting of a fixed number of
bits, N.
3 Each bit represents either the value zero (reset) or one (set). To toggle a bit is to change the value zero to
one, or the value one to zero. Each bit has a non-negative position pos. When converting between an object
of class bitset<N> and a value of some integral type, bit position pos corresponds to the bit value 1 <<pos.
The integral value corresponding to two or more bits is the sum of their bit values.
4 The functions described in this subclause can report three kinds of errors, each associated with a distinct
exception:
— an invalid-argument error is associated with exceptions of type invalid_argument (19.2.3);
— an out-of-range error is associated with exceptions of type out_of_range (19.2.5);
— an overflow error is associated with exceptions of type overflow_error (19.2.8).
20.5.1 bitset constructors [bitset.cons]
constexpr bitset() noexcept;
1 Effects: Constructs an object of class bitset<N>, initializing all bits to zero.
constexpr bitset(unsigned long long val) noexcept;
2 Effects: Constructs an object of class bitset<N>, initializing the first M bit positions to the corresponding bit values in val. M is the smaller of N and the number of bits in the value representation (3.9) of
unsigned long long. If M < N, the remaining bit positions are initialized to zero.
template <class charT, class traits, class Allocator>
explicit
bitset(const basic_string<charT, traits, Allocator>& str,
typename basic_string<charT, traits, Allocator>::size_type pos = 0,
typename basic_string<charT, traits, Allocator>::size_type n =
basic_string<charT, traits, Allocator>::npos,
charT zero = charT(’0’), charT one = charT(’1’));
3 Requires: pos <= str.size().
4 Throws: out_of_range if pos > str.size().
§ 20.5.1 515

 c ISO/IEC N3242=11-0012
5 Effects: Determines the effective length rlen of the initializing string as the smaller of n and str.size()
- pos.
The function then throws invalid_argument if any of the rlen characters in str beginning at position
pos is other than zero or one. The function uses traits::eq() to compare the character values.
Otherwise, the function constructs an object of class bitset<N>, initializing the first M bit positions to
values determined from the corresponding characters in the string str. M is the smaller of N and rlen.
6 An element of the constructed string has value zero if the corresponding character in str, beginning
at position pos, is 0 zero. Otherwise, the element has the value 1. Character position pos + M - 1
corresponds to bit position zero. Subsequent decreasing character positions correspond to increasing
bit positions.
7 If M < N, remaining bit positions are initialized to zero.
template <class charT>
explicit bitset(
const charT* str,
typename basic_string<charT>::size_type n = basic_string<charT>::npos,
charT zero = charT(’0’), charT one = charT(’1’));
8 Effects: Constructs an object of class bitset<N> as if by
bitset(
n == basic_string<charT>::npos
? basic_string<charT>(str)
: basic_string<charT>(str, n),
0, n, zero, one)
20.5.2 bitset members [bitset.members]
bitset<N>& operator&=(const bitset<N>& rhs) noexcept;
1 Effects: Clears each bit in *this for which the corresponding bit in rhs is clear, and leaves all other
bits unchanged.
2 Returns: *this.
bitset<N>& operator|=(const bitset<N>& rhs) noexcept;
3 Effects: Sets each bit in *this for which the corresponding bit in rhs is set, and leaves all other bits
unchanged.
4 Returns: *this.
bitset<N>& operator^=(const bitset<N>& rhs) noexcept;
5 Effects: Toggles each bit in *this for which the corresponding bit in rhs is set, and leaves all other
bits unchanged.
6 Returns: *this.
bitset<N>& operator<<=(size_t pos) noexcept;
7 Effects: Replaces each bit at position I in *this with a value determined as follows:
— If I < pos, the new value is zero;
— If I >= pos, the new value is the previous value of the bit at position I - pos.
§ 20.5.2 516

 c ISO/IEC N3242=11-0012
8 Returns: *this.
bitset<N>& operator>>=(size_t pos) noexcept;
9 Effects: Replaces each bit at position I in *this with a value determined as follows:
— If pos >= N - I, the new value is zero;
— If pos < N - I, the new value is the previous value of the bit at position I + pos.
10 Returns: *this.
bitset<N>& set() noexcept;
11 Effects: Sets all bits in *this.
12 Returns: *this.
bitset<N>& set(size_t pos, bool val = true);
13 Requires: pos is valid
14 Throws: out_of_range if pos does not correspond to a valid bit position.
15 Effects: Stores a new value in the bit at position pos in *this. If val is nonzero, the stored value is
one, otherwise it is zero.
16 Returns: *this.
bitset<N>& reset() noexcept;
17 Effects: Resets all bits in *this.
18 Returns: *this.
bitset<N>& reset(size_t pos);
19 Requires: pos is valid
20 Throws: out_of_range if pos does not correspond to a valid bit position.
21 Effects: Resets the bit at position pos in *this.
22 Returns: *this.
bitset<N> operator~() const noexcept;
23 Effects: Constructs an object x of class bitset<N> and initializes it with *this.
24 Returns: x.flip().
bitset<N>& flip() noexcept;
25 Effects: Toggles all bits in *this.
26 Returns: *this.
bitset<N>& flip(size_t pos) noexcept;
27 Requires: pos is valid
28 Throws: out_of_range if pos does not correspond to a valid bit position.
29 Effects: Toggles the bit at position pos in *this.
§ 20.5.2 517

 c ISO/IEC N3242=11-0012
30 Returns: *this.
unsigned long to_ulong() const;
31 Throws: overflow_error if the integral value x corresponding to the bits in *this cannot be represented as type unsigned long.
32 Returns: x.
unsigned long long to_ullong() const;
33 Throws: overflow_error if the integral value x corresponding to the bits in *this cannot be represented as type unsigned long long.
34 Returns: x.
template <class charT = char,
class traits = char_traits<charT>,
class Allocator = allocator<charT> >
basic_string<charT, traits, Allocator>
to_string(charT zero = charT(’0’), charT one = charT(’1’)) const;
35 Effects: Constructs a string object of the appropriate type and initializes it to a string of length N
characters. Each character is determined by the value of its corresponding bit position in *this.
Character position N - 1 corresponds to bit position zero. Subsequent decreasing character positions
correspond to increasing bit positions. Bit value zero becomes the character zero, bit value one
becomes the character one.
36 Returns: The created object.
size_t count() const noexcept;
37 Returns: A count of the number of bits set in *this.
constexpr size_t size() noexcept;
38 Returns: N.
bool operator==(const bitset<N>& rhs) const noexcept;
39 Returns: A nonzero value true if the value of each bit in *this equals the value of the corresponding
bit in rhs.
bool operator!=(const bitset<N>& rhs) const noexcept;
40 Returns: A nonzero value true if !(*this == rhs).
bool test(size_t pos) const;
41 Requires: pos is valid
42 Throws: out_of_range if pos does not correspond to a valid bit position.
43 Returns: true if the bit at position pos in *this has the value one.
bool all() const noexcept;
44 Returns: count() == size()
bool any() const noexcept;
45 Returns: count() != 0
§ 20.5.2 518

 c ISO/IEC N3242=11-0012
bool none() const noexcept;
46 Returns: count() == 0
bitset<N> operator<<(size_t pos) const noexcept;
47 Returns: bitset<N>(*this) <<= pos.
bitset<N> operator>>(size_t pos) const noexcept;
48 Returns: bitset<N>(*this) >>= pos.
constexpr bool operator[](size_t pos) noexcept;
49 Requires: pos shall be valid.
50 Returns: true if the bit at position pos in *this has the value one, otherwise false.
bitset<N>::reference operator[](size_t pos) noexcept;
51 Requires: pos shall be valid.
52 Returns: An object of type bitset<N>::reference such that (*this)[pos] == this->test(pos),
and such that (*this)[pos] = val is equivalent to this->set(pos, val).
53 Remark: For the purpose of determining the presence of a data race (1.10), any access or update
through the resulting reference potentially accesses or modifies, respectively, the entire underlying
bitset.
20.5.3 bitset hash support [bitset.hash]
template <size_t N> struct hash<bitset<N> >;
1 Requires: the template specialization shall meet the requirements of class template hash (20.8.12).
20.5.4 bitset operators [bitset.operators]
bitset<N> operator&(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
1 Returns: bitset<N>(lhs) &= rhs.
bitset<N> operator|(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
2 Returns: bitset<N>(lhs) |= rhs.
bitset<N> operator^(const bitset<N>& lhs, const bitset<N>& rhs) noexcept;
3 Returns: bitset<N>(lhs) ˆ= rhs.
template <class charT, class traits, size_t N>
basic_istream<charT, traits>&
operator>>(basic_istream<charT, traits>& is, bitset<N>& x);
4 A formatted input function (27.7.2.2).
5 Effects: Extracts up to N characters from is. Stores these characters in a temporary object str of type
basic_string<charT, traits>, then evaluates the expression x = bitset<N>(str). Characters are
extracted and stored until any of the following occurs:
— N characters have been extracted and stored;
§ 20.5.4 519

 c ISO/IEC N3242=11-0012
— end-of-file occurs on the input sequence;
— the next input character is neither is.widen(’0’) nor is.widen(’1’) (in which case the input
character is not extracted).
6 If no characters are stored in str, calls is.setstate(ios_base::failbit) (which may throw ios_-
base::failure (27.5.5.4)).
7 Returns: is.
template <class charT, class traits, size_t N>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os, const bitset<N>& x);
8 Returns:
os << x.template to_string<charT,traits,allocator<charT> >(
use_facet<ctype<charT> >(os.getloc()).widen(’0’),
use_facet<ctype<charT> >(os.getloc()).widen(’1’))
(see 27.7.3.6).
20.6 Memory [memory]
20.6.1 In general [memory.general]
1 This subclause describes the contents of the header <memory> (20.6.2) and some of the contents of the C
headers <cstdlib> and cstring> (20.6.13).
20.6.2 Header <memory> synopsis [memory.syn]
1 The header <memory> defines several types and template functions that describe properties of pointers and
pointer-like types, manage memory for containers and other template types, and construct multiple objects
in unitialized memory buffers (20.6.3–20.6.12). The header also defines the templates unique_ptr, shared_-
ptr, weak_ptr, and various template functions that operate on objects of these types (20.7).
namespace std {
// 20.6.3, pointer traits
template <class Ptr> struct pointer_traits;
template <class T> struct pointer_traits<T*>;
// 20.6.4, pointer safety
enum class pointer_safety { relaxed, preferred, strict };
void declare_reachable(void *p);
template <class T> T *undeclare_reachable(T *p) noexcept;
void declare_no_pointers(char *p, size_t n) noexcept;
void undeclare_no_pointers(char *p, size_t n) noexcept;
pointer_safety get_pointer_safety() noexcept;
// 20.6.5, pointer alignment function
void *align(std::size_t alignment, std::size_t size,
void *&ptr, std::size_t& space) noexcept;
// 20.6.6, allocator argument tag
struct allocator_arg_t { };
constexpr allocator_arg_t allocator_arg = allocator_arg_t();
§ 20.6.2 520

 c ISO/IEC N3242=11-0012
// 20.6.7, uses_allocator
template <class T, class Alloc> struct uses_allocator;
// 20.6.8, allocator traits
template <class Alloc> struct allocator_traits;
// 20.6.9, the default allocator:
template <class T> class allocator;
template <> class allocator<void>;
template <class T, class U>
bool operator==(const allocator<T>&, const allocator<U>&) noexcept;
template <class T, class U>
bool operator!=(const allocator<T>&, const allocator<U>&) noexcept;
// 20.6.10, raw storage iterator:
template <class OutputIterator, class T> class raw_storage_iterator;
// 20.6.11, temporary buffers:
template <class T>
pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
template <class T>
void return_temporary_buffer(T* p) noexcept;
// 20.6.12, specialized algorithms:
template <class T> T* addressof(T& r) noexcept;
template <class InputIterator, class ForwardIterator>
ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
ForwardIterator result);
template <class InputIterator, class Size, class ForwardIterator>
ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
ForwardIterator result);
template <class ForwardIterator, class T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last,
const T& x);
template <class ForwardIterator, class Size, class T>
ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
// 20.7.1 class template unique_ptr:
template <class T> class default_delete;
template <class T> class default_delete<T[]>;
template <class T, class D = default_delete<T>> class unique_ptr;
template <class T, class D> class unique_ptr<T[], D>;
template <class T1, class D1, class T2, class D2>
bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template <class T1, class D1, class T2, class D2>
bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
§ 20.6.2 521

 c ISO/IEC N3242=11-0012
// 20.7.2.1, class bad_weak_ptr:
class bad_weak_ptr;
// 20.7.2.2, class template shared_ptr:
template<class T> class shared_ptr;
// 20.7.2.2.7, shared_ptr comparisons:
template<class T, class U>
bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b);
template<class T, class U>
bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b);
template<class T, class U>
bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b);
template<class T, class U>
bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b);
template<class T, class U>
bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b);
template<class T, class U>
bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b);
// 20.7.2.2.8, shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b);
// 20.7.2.2.9, shared_ptr casts:
template<class T, class U>
shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;
template<class T, class U>
shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;
// 20.7.2.2.10, shared_ptr get_deleter:
template<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;
// 20.7.2.2.11, shared_ptr I/O:
template<class E, class T, class Y>
basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);
// 20.7.2.3, class template weak_ptr:
template<class T> class weak_ptr;
// 20.7.2.3.6, weak_ptr specialized algorithms:
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
// 20.7.2.3.7, class template owner_less:
template<class T> class owner_less;
// 20.7.2.4, class template enable_shared_from_this:
template<class T> class enable_shared_from_this;
// 20.7.2.5, shared_ptr atomic access:
template<class T>
bool atomic_is_lock_free(const shared_ptr<T>* p) noexcept;
§ 20.6.2 522

 c ISO/IEC N3242=11-0012
template<class T>
shared_ptr<T> atomic_load(const shared_ptr<T>* p) noexcept;
template<class T>
shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo) noexcept;
template<class T>
void atomic_store(shared_ptr<T>* p, shared_ptr<T> r) noexcept;
template<class T>
void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo) noexcept;
template<class T>
shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r) noexcept;
template<class T>
shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,
memory_order mo) noexcept;
template<class T>
bool atomic_compare_exchange_weak(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w) noexcept;
template<class T>
bool atomic_compare_exchange_strong(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w) noexcept;
template<class T>
bool atomic_compare_exchange_weak_explicit(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure) noexcept;
template<class T>
bool atomic_compare_exchange_strong_explicit(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure) noexcept;
// 20.7.2.6 hash support
template <class T> struct hash;
template <class T, class D> struct hash<unique_ptr<T, D> >;
template <class T> struct hash<shared_ptr<T> >;
// D.10, auto_ptr (deprecated)
template <class X> class auto_ptr;
}
20.6.3 Pointer traits [pointer.traits]
1 The class template pointer_traits supplies a uniform interface to certain attributes of pointer-like types.
namespace std {
template <class Ptr> struct pointer_traits {
typedef Ptr pointer;
typedef see below element_type;
typedef see below difference_type;
template <class U> using rebind = see below;
static pointer pointer_to(see below r);
};
template <class T> struct pointer_traits<T*> {
§ 20.6.3 523

 c ISO/IEC N3242=11-0012
typedef T* pointer;
typedef T element_type;
typedef ptrdiff_t difference_type;
template <class U> using rebind = U*;
static pointer pointer_to(see below r);
};
}
20.6.3.1 Pointer traits member types [pointer.traits.types]
typedef see below element_type;
1 Type: Ptr::element_type if such a type exists; otherwise, T if Ptr is a class template instantiation of the form SomePointer<T, Args>, where Args is zero or more type arguments; otherwise, the
specialization is ill-formed.
typedef see below difference_type;
2 Type: Ptr::difference_type if such a type exists; otherwise, std::ptrdiff_t.
template <class U> using rebind = see below;
3 Alias template: Ptr::rebind<U> if such a type exists; otherwise, SomePointer<U, Args> if Ptr is
a class template instantiation of the form SomePointer<T, Args>, where Args is zero or more type
arguments; otherwise, the instantiation of rebind is ill-formed.
20.6.3.2 Pointer traits member functions [pointer.traits.functions]
static pointer pointer_traits::pointer_to(see below r);
static pointer pointer_traits<T*>::pointer_to(see below r);
Remark: if element_type is (possibly cv-qualified) void, the type of r is unspecified; otherwise, it is
T&.
Returns: The first template function returns a dereferenceable pointer to r obtained by calling
Ptr::pointer_to(r); an instantiation of this function is ill-formed if Ptr does not have a matching pointer_to static member function. The second template function returns std::addressof(r).
20.6.4 Pointer safety [util.dynamic.safety]
1 A complete object is declared reachable while the number of calls to declare_reachable with an argument
referencing the object exceeds the number of calls to undeclare_reachable with an argument referencing
the object.
void declare_reachable(void *p);
2 Requires: p shall be a safely-derived pointer (3.7.4.3) or a null pointer value.
3 Effects: If p is not null, the complete object referenced by p is subsequently declared reachable (3.7.4.3).
4 Throws: May throw std::bad_alloc if the system cannot allocate additional memory that may be
required to track objects declared reachable.
template <class T> T *undeclare_reachable(T *p) noexcept;
§ 20.6.4 524

 c ISO/IEC N3242=11-0012
5 Requires: If p is not null, the complete object referenced by p shall have been previously declared
reachable, and shall be live (3.8) from the time of the call until the last undeclare_reachable(p) call
on the object.
6 Returns: A safely derived copy of p which shall compare equal to p.
7 [ Note: It is expected that calls to declare_reachable(p) will consume a small amount of memory in
addition to that occupied by the referenced object until the matching call to undeclare_reachable(p)
is encountered. Long running programs should arrange that calls are matched. — end note ]
void declare_no_pointers(char *p, size_t n) noexcept;
8 Requires: No bytes in the specified range have been previously registered with declare_no_pointers().
If the specified range is in an allocated object, then it must be entirely within a single allocated object. The object must be live until the corresponding undeclare_no_pointers() call. [ Note: In a
garbage-collecting implementation, the fact that a region in an object is registered with declare_no_-
pointers() should not prevent the object from being collected. — end note ]
9 Effects: The n bytes starting at p no longer contain traceable pointer locations, independent of their
type. Hence pointers located there may not be dereferenced if the object they point to was created
by global operator new and not previously declared reachable. [ Note: This may be used to inform a
garbage collector or leak detector that this region of memory need not be traced. — end note ]
10 [ Note: Under some conditions implementations may need to allocate memory. However, the request
can be ignored if memory allocation fails. — end note ]
void undeclare_no_pointers(char *p, size_t n) noexcept;
11 Requires: The same range must previously have been passed to declare_no_pointers().
12 Effects: Unregisters a range registered with declare_no_pointers() for destruction. It must be called
before the lifetime of the object ends.
pointer_safety get_pointer_safety() noexcept;
13 Returns: pointer_safety::strict if the implementation has strict pointer safety (3.7.4.3). It is implementation defined whether get_pointer_safety returns pointer_safety::relaxed or pointer_-
safety::preferred if the implementation has relaxed pointer safety.227
20.6.5 Align [ptr.align]
void *align(std::size_t alignment, std::size_t size,
void *&ptr, std::size_t& space) noexcept;
1 Effects: If it is possible to fit size bytes of storage aligned by alignment into the buffer pointed to by
ptr with length space, the function updates ptr to point to the first possible address of such storage
and decreases space by the number of bytes used for alignment. Otherwise, the function does nothing.
2 Requires:
— alignment shall be a fundamental alignment value or an extended alignment value supported by
the implementation in this context
— ptr shall point to contiguous storage of at least space bytes
227) pointer_safety::preferred might be returned to indicate that a leak detector is running so that the program can avoid
spurious leak reports.
§ 20.6.5 525

 c ISO/IEC N3242=11-0012
3 Returns: A null pointer if the requested aligned buffer would not fit into the available space, otherwise
the adjusted value of ptr.
4 [ Note: The function updates its ptr and space arguments so that it can be called repeatedly with
possibly different alignment and size arguments for the same buffer.
20.6.6 Allocator argument tag [allocator.tag]
namespace std {
struct allocator_arg_t { };
constexpr allocator_arg_t allocator_arg = allocator_arg_t();
}
1 The allocator_arg_t struct is an empty structure type used as a unique type to disambiguate constructor
and function overloading. Specifically, several types (see tuple 20.4) have constructors with allocator_-
arg_t as the first argument, immediately followed by an argument of a type that satisfies the Allocator
requirements (17.6.3.5).
20.6.7 uses_allocator [allocator.uses]
20.6.7.1 uses_allocator trait [allocator.uses.trait]
template <class T, class Alloc> struct uses_allocator;
1 Remark: automatically detects whether T has a nested allocator_type that is convertible from Alloc.
Meets the BinaryTypeTrait requirements (20.9.1). The implementation shall provide a definition
that is derived from true_type if a type T::allocator_type exists and is_convertible<Alloc,
T::allocator_type>::value != false, otherwise it shall be derived from false_type. A program
may specialize this template to derive from true_type for a user-defined type T that does not have a
nested allocator_type but nonetheless can be constructed with an allocator where either:
— the first argument of a constructor has type allocator_arg_t and the second argument has type
Alloc or
— the last argument of a constructor has type Alloc.
20.6.7.2 uses-allocator construction [allocator.uses.construction]
1 Uses-allocator construction with allocator Alloc refers to the construction of an object obj of type T, using
constructor arguments v1, v2, ..., vN of types V1, V2, ..., VN, respectively, and an allocator alloc
of type Alloc, according to the following rules:
— if uses_allocator<T, Alloc>::value is false and is_constructible<T, V1, V2, ..., VN>::value
is true, then obj is initialized as obj(v1, v2, ..., vN);
— otherwise, if uses_allocator<T, Alloc>::value is true and is_constructible<T, allocator_-
arg_t, Alloc, V1, V2, ..., VN>::value is true, then obj is initialized as obj(allocator_arg,
alloc, v1, v2, ..., vN);
— otherwise, if uses_allocator<T, Alloc>::value is true and is_constructible<T, V1, V2, ...,
VN, Alloc>::value is true, then obj is initialized as obj(v1, v2, ..., vN, alloc);
— otherwise, the request for uses-allocator construction is ill-formed. [ Note: An error will result if
uses_allocator<T, Alloc>::value is true but the specific constructor does not take an allocator.
This definition prevents a silent failure to pass the allocator to an element. — end note ]
§ 20.6.7.2 526

 c ISO/IEC N3242=11-0012
20.6.8 Allocator traits [allocator.traits]
1 The class template allocator_traits supplies a uniform interface to all allocator types. An allocator cannot
be a non-class type, however, even if allocator_traits supplies the entire required interface. [ Note: Thus,
it is always possible to create a derived class from an allocator. — end note ]
namespace std {
template <class Alloc> struct allocator_traits {
typedef Alloc allocator_type;
typedef typename Alloc::value_type value_type;
typedef see below pointer;
typedef see below const_pointer;
typedef see below void_pointer;
typedef see below const_void_pointer;
typedef see below difference_type;
typedef see below size_type;
typedef see below propagate_on_container_copy_assignment;
typedef see below propagate_on_container_move_assignment;
typedef see below propagate_on_container_swap;
template <class T> using rebind_alloc = see below;
template <class T> using rebind_traits = allocator_traits<rebind_alloc<T> >;
static pointer allocate(Alloc& a, size_type n);
static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
static void deallocate(Alloc& a, pointer p, size_type n) noexcept;
template <class T, class... Args>
static void construct(Alloc& a, T* p, Args&&... args);
template <class T>
static void destroy(Alloc& a, T* p);
static size_type max_size(const Alloc& a);
static Alloc select_on_container_copy_construction(const Alloc& rhs);
};
}
20.6.8.1 Allocator traits member types [allocator.traits.types]
typedef see below pointer;
1 Type: Alloc::pointer if such a type exists; otherwise, value_type*.
typedef see below const_pointer;
2 Type: Alloc::const_pointer if such a type exists; otherwise, pointer_traits<pointer>::rebind<const
value_type>.
typedef see below void_pointer;
§ 20.6.8.1 527

 c ISO/IEC N3242=11-0012
3 Type: Alloc::void_pointer if such a type exists; otherwise, pointer_traits<pointer>::rebind<void>.
typedef see below const_void_pointer;
4 Type: Alloc::const_void_pointer if such a type exists; otherwise, pointer_traits<pointer>::rebind<const
void>.
typedef see below difference_type;
5 Type: Alloc::difference_type if such a type exists; otherwise, pointer_traits<pointer>::difference_-
type.
typedef see below size_type;
6 Type: Alloc::size_type if such a type exists; otherwise, make_unsigned<difference_type>::type.
typedef see below propagate_on_container_copy_assignment;
7 Type: Alloc::propagate_on_container_copy_assignment if such a type exits, otherwise false_-
type.
typedef see below propagate_on_container_move_assignment;
8 Type: Alloc::propagate_on_container_move_assignment if such a type exits, otherwise false_-
type.
typedef see below propagate_on_container_swap;
9 Type: Alloc::propagate_on_container_swap if such a type exits, otherwise false_type.
template <class T> using rebind_alloc = see below;
10 Alias template: Alloc::rebind<T>::other if such a type exists; otherwise, Alloc<T, Args> if Alloc
is a class template instantiation of the form Alloc<U, Args>, where Args is zero or more type arguments; otherwise, the instantiation of rebind_alloc is ill-formed.
20.6.8.2 Allocator traits static member functions [allocator.traits.members]
static pointer allocate(Alloc& a, size_type n);
1 Returns: a.allocate(n).
static pointer allocate(Alloc& a, size_type n, const_void_pointer hint);
2 Returns: a.allocate(n, hint) if that expression is well-formed; otherwise, a.allocate(n).
static void deallocate(Alloc& a, pointer p, size_type n) noexcept;
3 Effects: calls a.deallocate(p, n).
template <class T, class... Args>
static void construct(Alloc& a, T* p, Args&&... args);
4 Effects: calls a.construct(p, std::forward<Args>(args)...) if that call is well-formed; otherwise,
invokes ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...).
template <class T>
static void destroy(Alloc& a, T* p);
5 Effects: calls a.destroy(p) if that call is well-formed; otherwise, invokes p->~T().
§ 20.6.8.2 528

 c ISO/IEC N3242=11-0012
static size_type max_size(Alloc& a);
6 Returns: a.max_size() if that expression is well-formed; otherwise, numeric_limits<size_type>::max().
static Alloc select_on_container_copy_construction(const Alloc& rhs);
7 Returns: rhs.select_on_container_copy_construction() if that expression is well-formed; otherwise, rhs.
20.6.9 The default allocator [default.allocator]
namespace std {
template <class T> class allocator;
// specialize for void:
template <> class allocator<void> {
public:
typedef void* pointer;
typedef const void* const_pointer;
// reference-to-void members are impossible.
typedef void value_type;
template <class U> struct rebind { typedef allocator<U> other; };
};
template <class T> class allocator {
public:
typedef size_t size_type;
typedef ptrdiff_t difference_type;
typedef T* pointer;
typedef const T* const_pointer;
typedef T& reference;
typedef const T& const_reference;
typedef T value_type;
template <class U> struct rebind { typedef allocator<U> other; };
allocator() noexcept;
allocator(const allocator&) noexcept;
template <class U> allocator(const allocator<U>&) noexcept;
~allocator();
pointer address(reference x) const noexcept;
const_pointer address(const_reference x) const noexcept;
pointer allocate(
size_type, allocator<void>::const_pointer hint = 0);
void deallocate(pointer p, size_type n) noexcept;
size_type max_size() const noexcept;
template<class U, class... Args>
void construct(U* p, Args&&... args);
template <class U>
void destroy(U* p);
};
}
§ 20.6.9 529

 c ISO/IEC N3242=11-0012
20.6.9.1 allocator members [allocator.members]
1 Except for the destructor, member functions of the default allocator shall not introduce data races (1.10)
as a result of concurrent calls to those member functions from different threads. Calls to these functions
that allocate or deallocate a particular unit of storage shall occur in a single total order, and each such
deallocation call shall happen before the next allocation (if any) in this order.
pointer address(reference x) const noexcept;
2 Returns: The actual address of the object referenced by x, even in the presence of an overloaded
operator&.
const_pointer address(const_reference x) const noexcept;
3 Returns: The actual address of the object referenced by x, even in the presence of an overloaded
operator&.
pointer allocate(size_type n, allocator<void>::const_pointer hint = 0) noexcept;
4 [ Note: In a container member function, the address of an adjacent element is often a good choice to
pass for the hint argument. — end note ]
5 Returns: A pointer to the initial element of an array of storage of size n * sizeof(T), aligned appropriately for objects of type T. It is implementation-defined whether over-aligned types are supported (3.11).
6 Remark: the storage is obtained by calling ::operator new(std::size_t) (18.6.1), but it is unspecified when or how often this function is called. The use of hint is unspecified, but intended as an aid
to locality if an implementation so desires.
7 Throws: bad_alloc if the storage cannot be obtained.
void deallocate(pointer p, size_type n) noexcept;
8 Requires: p shall be a pointer value obtained from allocate(). n shall equal the value passed as the
first argument to the invocation of allocate which returned p.
9 Effects: Deallocates the storage referenced by p .
10 Remarks: Uses ::operator delete(void*) (18.6.1), but it is unspecified when this function is called.
size_type max_size() const noexcept;
11 Returns: The largest value N for which the call allocate(N,0) might succeed.
template <class U, class... Args>
void construct(U* p, Args&&... args);
12 Effects: ::new((void *)p) U(std::forward<Args>(args)...)
template <class U>
void destroy(U* p);
13 Effects: p->~U()
20.6.9.2 allocator globals [allocator.globals]
template <class T1, class T2>
bool operator==(const allocator<T1>&, const allocator<T2>&) noexcept;
1 Returns: true.
§ 20.6.9.2 530

 c ISO/IEC N3242=11-0012
template <class T1, class T2>
bool operator!=(const allocator<T1>&, const allocator<T2>&) noexcept;
2 Returns: false.
20.6.10 Raw storage iterator [storage.iterator]
1 raw_storage_iterator is provided to enable algorithms to store their results into uninitialized memory.
The formal template parameter OutputIterator is required to have its operator* return an object for
which operator& is defined and returns a pointer to T, and is also required to satisfy the requirements of an
output iterator (24.2.4).
namespace std {
template <class OutputIterator, class T>
class raw_storage_iterator
: public iterator<output_iterator_tag,void,void,void,void> {
public:
explicit raw_storage_iterator(OutputIterator x) noexcept;
raw_storage_iterator<OutputIterator,T>& operator*() noexcept;
raw_storage_iterator<OutputIterator,T>& operator=(const T& element);
raw_storage_iterator<OutputIterator,T>& operator++() noexcept;
raw_storage_iterator<OutputIterator,T> operator++(int) noexcept;
};
}
explicit raw_storage_iterator(OutputIterator x) noexcept;
2 Effects: Initializes the iterator to point to the same value to which x points.
raw_storage_iterator<OutputIterator,T>& operator*() noexcept;
3 Returns: *this
raw_storage_iterator<OutputIterator,T>& operator=(const T& element);
4 Effects: Constructs a value from element at the location to which the iterator points.
5 Returns: A reference to the iterator.
raw_storage_iterator<OutputIterator,T>& operator++() noexcept;
6 Effects: Pre-increment: advances the iterator and returns a reference to the updated iterator.
raw_storage_iterator<OutputIterator,T> operator++(int) noexcept;
7 Effects: Post-increment: advances the iterator and returns the old value of the iterator.
20.6.11 Temporary buffers [temporary.buffer]
template <class T>
pair<T*, ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;
1 Effects: Obtains a pointer to storage sufficient to store up to n adjacent T objects. It is implementationdefined whether over-aligned types are supported (3.11).
2 Returns: A pair containing the buffer’s address and capacity (in the units of sizeof(T)), or a pair
of 0 values if no storage can be obtained or if n <= 0.
§ 20.6.11 531

 c ISO/IEC N3242=11-0012
template <class T> void return_temporary_buffer(T* p) noexcept;
3 Effects: Deallocates the buffer to which p points.
4 Requires: The buffer shall have been previously allocated by get_temporary_buffer.
20.6.12 Specialized algorithms [specialized.algorithms]
1 All the iterators that are used as formal template parameters in the following algorithms are required to
have their operator* return an object for which operator& is defined and returns a pointer to T. In the
algorithm uninitialized_copy, the formal template parameter InputIterator is required to satisfy the
requirements of an input iterator (24.2.3). In all of the following algorithms, the formal template parameter
ForwardIterator is required to satisfy the requirements of a forward iterator (24.2.5), and is required to
have the property that no exceptions are thrown from increment, assignment, comparison, or dereference of
valid iterators. In the following algorithms, if an exception is thrown there are no effects.
20.6.12.1 addressof [specialized.addressof]
template <class T> T* addressof(T& r) noexcept;
1 Returns: The actual address of the object or function referenced by r, even in the presence of an
overloaded operator&.
20.6.12.2 uninitialized_copy [uninitialized.copy]
template <class InputIterator, class ForwardIterator>
ForwardIterator uninitialized_copy(InputIterator first, InputIterator last,
ForwardIterator result);
1 Effects:
for (; first != last; ++result, ++first)
::new (static_cast<void*>(&*result))
typename iterator_traits<ForwardIterator>::value_type(*first);
2 Returns: result
template <class InputIterator, class Size, class ForwardIterator>
ForwardIterator uninitialized_copy_n(InputIterator first, Size n,
ForwardIterator result);
3 Effects:
for ( ; n > 0; ++result, ++first, --n) {
::new (static_cast<void*>(&*result))
typename iterator_traits<ForwardIterator>::value_type(*first);
}
4 Returns: result
20.6.12.3 uninitialized_fill [uninitialized.fill]
template <class ForwardIterator, class T>
void uninitialized_fill(ForwardIterator first, ForwardIterator last,
const T& x);
§ 20.6.12.3 532

 c ISO/IEC N3242=11-0012
1 Effects:
for (; first != last; ++first)
::new (static_cast<void*>(&*first))
typename iterator_traits<ForwardIterator>::value_type(x);
20.6.12.4 uninitialized_fill_n [uninitialized.fill.n]
template <class ForwardIterator, class Size, class T>
ForwardIterator uninitialized_fill_n(ForwardIterator first, Size n, const T& x);
1 Effects:
for (; n--; ++first)
::new (static_cast<void*>(&*first))
typename iterator_traits<ForwardIterator>::value_type(x);
return first;
20.6.13 C library [c.malloc]
1 Table 45 describes the header <cstdlib>.
Table 45 — Header <cstdlib> synopsis
Type Name(s)
Functions: calloc malloc
free realloc
2 The contents are the same as the Standard C library header <stdlib.h>, with the following changes:
3 The functions calloc(), malloc(), and realloc() do not attempt to allocate storage by calling ::operator
new() (18.6).
4 The function free() does not attempt to deallocate storage by calling ::operator delete().
See also: ISO C Clause 7.11.2.
5 Storage allocated directly with malloc(), calloc(), or realloc() is implicitly declared reachable (see 3.7.4.3)
on allocation, ceases to be declared reachable on deallocation, and need not cease to be declared reachable as
the result of an undeclare_reachable() call. [ Note: This allows existing C libraries to remain unaffected
by restrictions on pointers that are not safely derived, at the expense of providing far fewer garbage collection and leak detection options for malloc()-allocated objects. It also allows malloc() to be implemented
with a separate allocation arena, bypassing the normal declare_reachable() implementation. The above
functions should never intentionally be used as a replacement for declare_reachable(), and newly written
code is strongly encouraged to treat memory allocated with these functions as though it were allocated with
operator new. — end note ]
6 Table 46 describes the header <cstring>.
7 The contents are the same as the Standard C library header <string.h>, with the change to memchr()
specified in 21.7.
See also: ISO C Clause 7.11.2.
§ 20.6.13 533

 c ISO/IEC N3242=11-0012
Table 46 — Header <cstring> synopsis
Type Name(s)
Macro: NULL
Type: size_t
Functions: memchr memcmp
memcpy memmove memset
20.7 Smart pointers [smartptr]
20.7.1 Class template unique_ptr [unique.ptr]
1 A unique pointer is an object that owns another object and manages that other object through a pointer.
More precisely, a unique pointer is an object u that stores a pointer to a second object p and will dispose of
p when u is itself destroyed (e.g., when leaving block scope (6.7)). In this context, u is said to own p.
2 The mechanism by which u disposes of p is known as p’s associated deleter, a function object whose correct
invocation results in p’s appropriate disposition (typically its deletion).
3 Let the notation u.p denote the pointer stored by u, and let u.d denote the associated deleter. Upon request,
u can reset (replace) u.p and u.d with another pointer and deleter, but must properly dispose of its owned
object via the associated deleter before such replacement is considered completed.
4 Additionally, u can, upon request, transfer ownership to another unique pointer u2. Upon completion of
such a transfer, the following postconditions hold:
— u2.p is equal to the pre-transfer u.p,
— u.p is equal to nullptr, and
— if the pre-transfer u.d maintained state, such state has been transferred to u2.d.
As in the case of a reset, u2 must properly dispose of its pre-transfer owned object via the pre-transfer
associated deleter before the ownership transfer is considered complete. [ Note: A deleter’s state need never
be copied, only moved or swapped as ownership is transferred. — end note ]
5 Each object of a type U instantiated from the unique_ptr template specified in this subclause has the strict
ownership semantics, specified above, of a unique pointer. In partial satisfaction of these semantics, each
such U is MoveConstructible and MoveAssignable, but is not CopyConstructible nor CopyAssignable.
The template parameter T of unique_ptr may be an incomplete type.
6 [ Note: The uses of unique_ptr include providing exception safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and returning dynamically allocated memory from
a function. — end note ]
namespace std {
template<class T> struct default_delete;
template<class T> struct default_delete<T[]>;
template<class T, class D = default_delete<T>> class unique_ptr;
template<class T, class D> class unique_ptr<T[], D>;
template<class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
template<class T1, class D1, class T2, class D2>
bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
§ 20.7.1 534

 c ISO/IEC N3242=11-0012
template<class T1, class D1, class T2, class D2>
bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
template<class T1, class D1, class T2, class D2>
bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
}
20.7.1.1 Default deleters [unique.ptr.dltr]
20.7.1.1.1 In general [unique.ptr.dltr.general]
1 The class template default_delete serves as the default deleter (destruction policy) for the class template
unique_ptr.
2 The template parameter T of default_delete may be an incomplete type.
20.7.1.1.2 default_delete [unique.ptr.dltr.dflt]
namespace std {
template <class T> struct default_delete {
constexpr default_delete() noexcept = default;
template <class U> default_delete(const default_delete<U>&) noexcept;
void operator()(T*) const;
};
}
template <class U> default_delete(const default_delete<U>& other) noexcept;
1 Effects: Constructs a default_delete object from another default_delete<U> object.
2 Remarks: This constructor shall not participate in overload resolution unless U* is implicitly convertible
to T*.
void operator()(T *ptr) const;
3 Effects: calls delete on ptr.
4 Remarks: If T is an incomplete type, the program is ill-formed.
20.7.1.1.3 default_delete<T[]> [unique.ptr.dltr.dflt1]
namespace std {
template <class T> struct default_delete<T[]> {
constexpr default_delete() noexcept = default;
void operator()(T*) const;
template <class U> void operator()(U*) const = delete;
};
}
void operator()(T* ptr) const;
§ 20.7.1.1.3 535

 c ISO/IEC N3242=11-0012
1 Effects: calls delete[] on ptr.
2 Remarks: If T is an incomplete type, the program is ill-formed.
20.7.1.2 unique_ptr for single objects [unique.ptr.single]
namespace std {
template <class T, class D = default_delete<T>> class unique_ptr {
public:
typedef see below pointer;
typedef T element_type;
typedef D deleter_type;
// 20.7.1.2.1, constructors
constexpr unique_ptr() noexcept;
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, see below d1) noexcept;
unique_ptr(pointer p, see below d2) noexcept;
unique_ptr(unique_ptr&& u) noexcept;
constexpr unique_ptr(nullptr_t) : unique_ptr() { }
template <class U, class E>
unique_ptr(unique_ptr<U, E>&& u) noexcept;
template <class U>
unique_ptr(auto_ptr<U>&& u) noexcept;
// 20.7.1.2.2, destructor
~unique_ptr();
// 20.7.1.2.3, assignment
unique_ptr& operator=(unique_ptr&& u) noexcept;
template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
unique_ptr& operator=(nullptr_t) noexcept;
// 20.7.1.2.4, observers
typename add_lvalue_reference<T>::type operator*() const;
pointer operator->() const noexcept;
pointer get() const noexcept;
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
explicit operator bool() const noexcept;
// 20.7.1.2.5 modifiers
pointer release() noexcept;
void reset(pointer p = pointer()) noexcept;
void swap(unique_ptr& u) noexcept;
// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;
};
}
1 The default type for the template parameter D is default_delete. A client-supplied template argument D
shall be a function object type (20.8), lvalue-reference to function, or lvalue-reference to function object type
§ 20.7.1.2 536

 c ISO/IEC N3242=11-0012
for which, given a value d of type D and a value ptr of type unique_ptr<T, D>::pointer, the expression
d(ptr) is valid and has the effect of disposing of the pointer as appropriate for that deleter.
2 If the deleter’s type D is not a reference type, D shall satisfy the requirements of Destructible (Table 24).
3 If the type remove_reference<D>::type::pointer exists, then unique_ptr<T, D>::pointer shall be a
synonym for remove_reference<D>::type::pointer. Otherwise unique_ptr<T, D>::pointer shall be a
synonym for T*. The type unique_ptr<T, D>::pointer shall satisfy the requirements of NullablePointer (17.6.3.3).
4 [ Example: Given an allocator type X (17.6.3.5) and letting A be a synonym for allocator_traits<X>, the
types A::pointer, A::const_pointer, A::void_pointer, and A::const_void_pointer may be used as
unique_ptr<T, D>::pointer. — end example ]
20.7.1.2.1 unique_ptr constructors [unique.ptr.single.ctor]
constexpr unique_ptr() noexcept;
1 Requires: D shall satisfy the requirements of DefaultConstructible (Table 19), and that construction
shall not throw an exception.
2 Effects: Constructs a unique_ptr object that owns nothing, value-initializing the stored pointer and
the stored deleter.
3 Postconditions: get() == nullptr. get_deleter() returns a reference to the stored deleter.
4 Remarks: If this constructor is instantiated with a pointer type or reference type for the template
argument D, the program is ill-formed.
explicit unique_ptr(pointer p) noexcept;
5 Requires: D shall satisfy the requirements of DefaultConstructible (Table 19), and that construction
shall not throw an exception.
6 Effects: Constructs a unique_ptr which owns p, initializing the stored pointer with p and valueinitializing the stored deleter.
7 Postconditions: get() == p. get_deleter() returns a reference to the stored deleter.
8 Remarks: If this constructor is instantiated with a pointer type or reference type for the template
argument D, the program is ill-formed.
unique_ptr(pointer p, see below d1) noexcept;
unique_ptr(pointer p, see below d2) noexcept;
9 The signature of these constructors depends upon whether D is a reference type. If D is non-reference
type A, then the signatures are:
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, A&& d);
10 If D is an lvalue-reference type A&, then the signatures are:
unique_ptr(pointer p, A& d);
unique_ptr(pointer p, A&& d);
11 If D is an lvalue-reference type const A&, then the signatures are:
unique_ptr(pointer p, const A& d);
unique_ptr(pointer p, const A&& d);
§ 20.7.1.2.1 537

 c ISO/IEC N3242=11-0012
12 Requires:
— If D is not an lvalue-reference type then
— If d is an lvalue or const rvalue then the first constructor of this pair will be selected. D shall
satisfy the requirements of CopyConstructible (Table 21), and the copy constructor of D
shall not throw an exception. This unique_ptr will hold a copy of d.
— Otherwise, d is a non-const rvalue and the second constructor of this pair will be selected. D
shall satisfy the requirements of MoveConstructible (Table 20), and the move constructor
of D shall not throw an exception. This unique_ptr will hold a value move constructed from
d.
— Otherwise D is an lvalue-reference type. d shall be reference-compatible with one of the constructors. If d is an rvalue, it will bind to the second constructor of this pair and the program
is ill-formed. [ Note: The diagnostic could be implemented using a static_assert which assures that D is not a reference type. — end note ] Else d is an lvalue and will bind to the
first constructor of this pair. The type which D references need not be CopyConstructible nor
MoveConstructible. This unique_ptr will hold a D which refers to the lvalue d. [ Note: D may
not be an rvalue-reference type. — end note ]
13 Effects: Constructs a unique_ptr object which owns p, initializing the stored pointer with p and
initializing the deleter as described above.
14 Postconditions: get() == p. get_deleter() returns a reference to the stored deleter. If D is a
reference type then get_deleter() returns a reference to the lvalue d.
[ Example:
D d;
unique_ptr<int, D> p1(new int, D()); // D must be MoveConstructible
unique_ptr<int, D> p2(new int, d); // D must be Copyconstructible
unique_ptr<int, D&> p3(new int, d); // p3 holds a reference to d
unique_ptr<int, const D&> p4(new int, D()); // error: rvalue deleter object combined
// with reference deleter type
— end example ]
unique_ptr(unique_ptr&& u) noexcept;
15 Requires: If D is not a reference type, D shall satisfy the requirements of MoveConstructible (Table 20).
Construction of the deleter from an rvalue of type D shall not throw an exception.
16 Effects: Constructs a unique_ptr by transferring ownership from u to *this. If D is a reference type,
this deleter is copy constructed from u’s deleter; otherwise, this deleter is move constructed from u’s
deleter. [ Note: The deleter constructor can be implemented with std::forward<D>. — end note ]
17 Postconditions: get() yields the value u.get() yielded before the construction. get_deleter()
returns a reference to the stored deleter that was constructed from u.get_deleter(). If D is a
reference type then get_deleter() and u.get_deleter() both reference the same lvalue deleter.
template <class U, class E> unique_ptr(unique_ptr<U, E>&& u) noexcept;
18 Requires: If E is not a reference type, construction of the deleter from an rvalue of type E shall be
well formed and shall not throw an exception. Otherwise, E is a reference type and construction of the
deleter from an lvalue of type E shall be well formed and shall not throw an exception.
19 Remarks: This constructor shall not participate in overload resolution unless:
§ 20.7.1.2.1 538

 c ISO/IEC N3242=11-0012
— unique_ptr<U, E>::pointer is implicitly convertible to pointer,
— U is not an array type, and
— either D is a reference type and E is the same type as D, or D is not a reference type and E is
implicitly convertible to D.
20 Effects: Constructs a unique_ptr by transferring ownership from u to *this. If E is a reference type,
this deleter is copy constructed from u’s deleter; otherwise, this deleter is move constructed from u’s
deleter. [ Note: The deleter constructor can be implemented with std::forward<E>. — end note ]
21 Postconditions: get() yields the value u.get() yielded before the construction. get_deleter()
returns a reference to the stored deleter that was constructed from u.get_deleter().
template <class U>
unique_ptr(auto_ptr<U>&& u) noexcept;
22 Effects: Constructs a unique_ptr object, initializing the stored pointer with u.release() and valueinitializing the stored deleter.
23 Postconditions: get() yields the value u.get() yielded before the construction. u.get() == nullptr.
get_deleter() returns a reference to the stored deleter.
24 Remarks: This constructor shall not participate in overload resolution unless U* is implictly convertible
to T* and D is the same type as default_delete<T>.
20.7.1.2.2 unique_ptr destructor [unique.ptr.single.dtor]
~unique_ptr();
1 Requires: The expression get_deleter()(get()) shall be well formed, shall have well-defined behavior, and shall not throw exceptions. [ Note: The use of default_delete requires T to be a complete
type. — end note ]
2 Effects: If get() == nullptr there are no effects. Otherwise get_deleter()(get()).
20.7.1.2.3 unique_ptr assignment [unique.ptr.single.asgn]
unique_ptr& operator=(unique_ptr&& u) noexcept;
1 Requires: If D is not a reference type, D shall satisfy the requirements of MoveAssignable (Table 22)
and assignment of the deleter from an rvalue of type D shall not throw an execption. Otherwise, D
is a reference type; remove_reference<D>::type shall satisfy the CopyAssignable requirements and
assignment of the deleter from an lvalue of type D shall not throw an exception.
2 Effects: Transfers ownership from u to *this as if by calling reset(u.release()) followed by an
assignment from std::forward<D>(u.get_deleter()).
3 Returns: *this.
template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;
4 Requires: If E is not a reference type, assignment of the deleter from an rvalue of type E shall be
well-formed and shall not throw an exception. Otherwise, E is a reference type and assignment of the
deleter from an lvalue of type E shall be well-formed and shall not throw an exception.
5 Remarks: This operator shall not participate in overload resolution unless:
— unique_ptr<U, E>::pointer is implicitly convertible to pointer and
§ 20.7.1.2.3 539

 c ISO/IEC N3242=11-0012
— U is not an array type.
6 Effects: Transfers ownership from u to *this as if by calling reset(u.release()) followed by an
assignment from std::forward<D>(u.get_deleter()).
7 Returns: *this.
unique_ptr& operator=(nullptr_t) noexcept;
8 Effects: reset().
9 Postcondition: get() == nullptr
10 Returns: *this.
20.7.1.2.4 unique_ptr observers [unique.ptr.single.observers]
typename add_lvalue_reference<T>::type operator*() const;
1 Requires: get() != nullptr.
2 Returns: *get().
pointer operator->() const noexcept;
3 Requires: get() != nullptr.
4 Returns: get().
5 Note: use typically requires that T be a complete type.
pointer get() const noexcept;
6 Returns: The stored pointer.
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
7 Returns: A reference to the stored deleter.
explicit operator bool() const noexcept;
8 Returns: get() != nullptr.
20.7.1.2.5 unique_ptr modifiers [unique.ptr.single.modifiers]
pointer release() noexcept;
1 Postcondition: get() == nullptr.
2 Returns: The value get() had at the start of the call to release.
void reset(pointer p = pointer()) noexcept;
3 Requires: The expression get_deleter()(get()) shall be well formed, shall have well-defined behavior, and shall not throw exceptions.
4 Effects: assigns p to the stored pointer, and then if the old value of the stored pointer, old_p, was not
equal to nullptr, calls get_deleter()(old_p). [ Note: The order of these operations is significant
because the call to get_deleter() may destroy *this. — end note ]
§ 20.7.1.2.5 540

 c ISO/IEC N3242=11-0012
5 Postconditions: get() == p. [ Note: The postcondition does not hold if the call to get_deleter()
destroys *this since this->get() is no longer a valid expression. — end note ]
void swap(unique_ptr& u) noexcept;
6 Requires: get_deleter() shall be swappable (17.6.3.2) and shall not throw an exception under swap.
7 Effects: Invokes swap on the stored pointers and on the stored deleters of *this and u.
20.7.1.3 unique_ptr for array objects with a runtime length [unique.ptr.runtime]
namespace std {
template <class T, class D> class unique_ptr<T[], D> {
public:
typedef see below pointer;
typedef T element_type;
typedef D deleter_type;
// 20.7.1.3.1, constructors
constexpr unique_ptr() noexcept;
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, see below d) noexcept;
unique_ptr(pointer p, see below d) noexcept;
unique_ptr(unique_ptr&& u) noexcept;
constexpr unique_ptr(nullptr_t) : unique_ptr() { }
// destructor
~unique_ptr();
// assignment
unique_ptr& operator=(unique_ptr&& u) noexcept;
unique_ptr& operator=(nullptr_t) noexcept;
// 20.7.1.3.2, observers
T& operator[](size_t i) const;
pointer get() const noexcept;
deleter_type& get_deleter() noexcept;
const deleter_type& get_deleter() const noexcept;
explicit operator bool() const noexcept;
// 20.7.1.3.3 modifiers
pointer release() noexcept;
void reset(pointer p = pointer()) noexcept;
void reset(nullptr_t) noexcept;
template <class U> void reset(U) = delete;
void swap(unique_ptr& u) noexcept;
// disable copy from lvalue
unique_ptr(const unique_ptr&) = delete;
unique_ptr& operator=(const unique_ptr&) = delete;
};
}
1 A specialization for array types is provided with a slightly altered interface.
§ 20.7.1.3 541

 c ISO/IEC N3242=11-0012
— Conversions between different types of unique_ptr<T[], D> or to or from the non-array forms of
unique_ptr produce an ill-formed program.
— Pointers to types derived from T are rejected by the constructors, and by reset.
— The observers operator* and operator-> are not provided.
— The indexing observer operator[] is provided.
— The default deleter will call delete[].
2 Descriptions are provided below only for member functions that have behavior different from the primary
template.
3 The template argument T shall be a complete type.
20.7.1.3.1 unique_ptr constructors [unique.ptr.runtime.ctor]
explicit unique_ptr(pointer p) noexcept;
unique_ptr(pointer p, see below d) noexcept;
unique_ptr(pointer p, see below d) noexcept;
These constructors behave the same as in the primary template except that they do not accept pointer
types which are convertible to pointer. [ Note: One implementation technique is to create private
templated overloads of these members. — end note ]
20.7.1.3.2 unique_ptr observers [unique.ptr.runtime.observers]
T& operator[](size_t i) const;
1 Requires: i < the size of the array number of elements in the array to which the stored pointer points.
2 Returns: get()[i].
20.7.1.3.3 unique_ptr modifiers [unique.ptr.runtime.modifiers]
void reset(pointer p = pointer()) noexcept;
void reset(nullptr_t p) noexcept;
1 Effects: If get() == nullptr there are no effects. Otherwise get_deleter()(get()).
2 Postcondition: get() == p.
20.7.1.4 unique_ptr specialized algorithms [unique.ptr.special]
template <class T, class D> void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;
1 Effects: Calls x.swap(y).
template <class T1, class D1, class T2, class D2>
bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
2 Returns: x.get() == y.get().
template <class T1, class D1, class T2, class D2>
bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
3 Returns: x.get() != y.get().
§ 20.7.1.4 542

 c ISO/IEC N3242=11-0012
template <class T1, class D1, class T2, class D2>
bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
4 Returns: x.get() < y.get().
template <class T1, class D1, class T2, class D2>
bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
5 Returns: x.get() <= y.get().
template <class T1, class D1, class T2, class D2>
bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
6 Returns: x.get() > y.get().
template <class T1, class D1, class T2, class D2>
bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);
7 Returns: x.get() >= y.get().
20.7.2 Shared-ownership pointers [util.smartptr]
20.7.2.1 Class bad_weak_ptr [util.smartptr.weakptr]
namespace std {
class bad_weak_ptr: public std::exception {
public:
bad_weak_ptr() noexcept;
};
} // namespace std
1 An exception of type bad_weak_ptr is thrown by the shared_ptr constructor taking a weak_ptr.
bad_weak_ptr() noexcept;
2 Postconditions: what() returns "bad_weak_ptr".
20.7.2.2 Class template shared_ptr [util.smartptr.shared]
1 The shared_ptr class template stores a pointer, usually obtained via new. shared_ptr implements semantics
of shared ownership; the last remaining owner of the pointer is responsible for destroying the object, or
otherwise releasing the resources associated with the stored pointer. A shared_ptr object is empty if it does
not own a pointer.
namespace std {
template<class T> class shared_ptr {
public:
typedef T element_type;
// 20.7.2.2.1, constructors:
constexpr shared_ptr() noexcept;
template<class Y> explicit shared_ptr(Y* p);
template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template <class D> shared_ptr(nullptr_t p, D d)
template <class D, class A> shared_ptr(nullptr_t p, D d, A a)
template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
§ 20.7.2.2 543

 c ISO/IEC N3242=11-0012
shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
template<class Y> shared_ptr(auto_ptr<Y>&& r);
template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);
constexpr shared_ptr(nullptr_t) : shared_ptr() { }
// 20.7.2.2.2, destructor:
~shared_ptr();
// 20.7.2.2.3, assignment:
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);
template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
// 20.7.2.2.4, modifiers:
void swap(shared_ptr& r) noexcept;
void reset() noexcept;
template<class Y> void reset(Y* p);
template<class Y, class D> void reset(Y* p, D d);
template<class Y, class D, class A> void reset(Y* p, D d, A a);
// 20.7.2.2.5, observers:
T* get() const noexcept;
T& operator*() const noexcept;
T* operator->() const noexcept;
long use_count() const noexcept;
bool unique() const noexcept;
explicit operator bool() const noexcept;
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;
};
// 20.7.2.2.6, shared_ptr creation
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>
shared_ptr<T> allocate_shared(const A& a, Args&&... args);
// 20.7.2.2.7, shared_ptr comparisons:
template<class T, class U>
bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
template<class T, class U>
bool operator!=(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
template<class T, class U>
bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
// 20.7.2.2.8, shared_ptr specialized algorithms:
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
// 20.7.2.2.9, shared_ptr casts:
§ 20.7.2.2 544

 c ISO/IEC N3242=11-0012
template<class T, class U>
shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
template<class T, class U>
shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
// 20.7.2.2.10, shared_ptr get_deleter:
template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;
// 20.7.2.2.11, shared_ptr I/O:
template<class E, class T, class Y>
basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, const shared_ptr<Y>& p);
} // namespace std
2 Specializations of shared_ptr shall be CopyConstructible, CopyAssignable, and LessThanComparable,
allowing their use in standard containers. Specializations of shared_ptr shall be convertible to bool,
allowing their use in boolean expressions and declarations in conditions. The template parameter T of
shared_ptr may be an incomplete type.
3 [ Example:
if(shared_ptr<X> px = dynamic_pointer_cast<X>(py)) {
// do something with px
} —
end example ]
4 For purposes of determining the presence of a data race, member functions shall access and modify only the
shared_ptr and weak_ptr objects themselves and not objects they refer to. Changes in use_count() do
not reflect modifications that can introduce data races.
20.7.2.2.1 shared_ptr constructors [util.smartptr.shared.const]
constexpr shared_ptr() noexcept;
1 Effects: Constructs an empty shared_ptr object.
2 Postconditions: use_count() == 0 && get() == 0.
template<class Y> explicit shared_ptr(Y* p);
3 Requires: p shall be convertible to T*. Y shall be a complete type. The expression delete p shall be
well formed, shall have well defined behavior, and shall not throw exceptions.
4 Effects: Constructs a shared_ptr object that owns the pointer p.
5 Postconditions: use_count() == 1 && get() == p.
6 Throws: bad_alloc, or an implementation-defined exception when a resource other than memory
could not be obtained.
7 Exception safety: If an exception is thrown, delete p is called.
template<class Y, class D> shared_ptr(Y* p, D d);
template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);
template <class D> shared_ptr(nullptr_t p, D d);
template <class D, class A> shared_ptr(nullptr_t p, D d, A a);
§ 20.7.2.2.1 545

 c ISO/IEC N3242=11-0012
8 Requires: p shall be convertible to T*. D shall be CopyConstructible. The copy constructor and
destructor of D shall not throw exceptions. The expression d(p) shall be well formed, shall have
well defined behavior, and shall not throw exceptions. A shall be an allocator (17.6.3.5). The copy
constructor and destructor of A shall not throw exceptions.
9 Effects: Constructs a shared_ptr object that owns the object p and the deleter d. The second and
fourth constructors shall use a copy of a to allocate memory for internal use.
10 Postconditions: use_count() == 1 && get() == p.
11 Throws: bad_alloc, or an implementation-defined exception when a resource other than memory
could not be obtained.
12 Exception safety: If an exception is thrown, d(p) is called.
template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;
13 Effects: Constructs a shared_ptr instance that stores p and shares ownership with r.
14 Postconditions: get() == p && use_count() == r.use_count()
15 [ Note: To avoid the possibility of a dangling pointer, the user of this constructor must ensure that p
remains valid at least until the ownership group of r is destroyed. — end note ]
16 [ Note: This constructor allows creation of an empty shared_ptr instance with a non-NULL stored
pointer. — end note ]
shared_ptr(const shared_ptr& r) noexcept;
template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;
17 Requires: The second constructor shall not participate in the overload resolution unless Y* is implicitly
convertible to T*.
18 Effects: If r is empty, constructs an empty shared_ptr object; otherwise, constructs a shared_ptr
object that shares ownership with r.
19 Postconditions: get() == r.get() && use_count() == r.use_count().
shared_ptr(shared_ptr&& r) noexcept;
template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;
20 Remark: The second constructor shall not participate in overload resolution unless Y* is convertible
to T*.
21 Effects: Move-constructs a shared_ptr instance from r.
22 Postconditions: *this shall contain the old value of r. r shall be empty. r.get() == 0.
template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);
23 Requires: Y* shall be convertible to T*.
24 Effects: Constructs a shared_ptr object that shares ownership with r and stores a copy of the pointer
stored in r.
25 Postconditions: use_count() == r.use_count().
26 Throws: bad_weak_ptr when r.expired().
27 Exception safety: If an exception is thrown, the constructor has no effect.
template<class Y> shared_ptr(auto_ptr<Y>&& r);
§ 20.7.2.2.1 546

 c ISO/IEC N3242=11-0012
28 Requires: r.release() shall be convertible to T*. Y shall be a complete type. The expression delete
r.release() shall be well formed, shall have well defined behavior, and shall not throw exceptions.
29 Effects: Constructs a shared_ptr object that stores and owns r.release().
30 Postconditions: use_count() == 1 && r.get() == 0.
31 Throws: bad_alloc, or an implementation-defined exception when a resource other than memory
could not be obtained.
32 Exception safety: If an exception is thrown, the constructor has no effect.
template <class Y, class D> shared_ptr(unique_ptr<Y, D>&&r);
33 Effects: Equivalent to shared_ptr(r.release(), r.get_deleter()) when D is not a reference type,
otherwise shared_ptr(r.release(), ref(r.get_deleter())).
34 Exception safety: If an exception is thrown, the constructor has no effect.
20.7.2.2.2 shared_ptr destructor [util.smartptr.shared.dest]
~shared_ptr();
1 Effects:
— If *this is empty or shares ownership with another shared_ptr instance (use_count() > 1),
there are no side effects.
— Otherwise, if *this owns an object p and a deleter d, d(p) is called.
— Otherwise, *this owns a pointer p, and delete p is called.
2 [ Note: Since the destruction of *this decreases the number of instances that share ownership with *this
by one, after *this has been destroyed all shared_ptr instances that shared ownership with *this will
report a use_count() that is one less than its previous value. — end note ]
20.7.2.2.3 shared_ptr assignment [util.smartptr.shared.assign]
shared_ptr& operator=(const shared_ptr& r) noexcept;
template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;
template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);
1 Effects: Equivalent to shared_ptr(r).swap(*this).
2 Returns: *this.
3 [ Note: The use count updates caused by the temporary object construction and destruction are not
observable side effects, so the implementation may meet the effects (and the implied guarantees) via
different means, without creating a temporary. In particular, in the example:
shared_ptr<int> p(new int);
shared_ptr<void> q(p);
p = p;
q = p;
both assignments may be no-ops. — end note ]
shared_ptr& operator=(shared_ptr&& r) noexcept;
template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r) noexcept;
§ 20.7.2.2.3 547

 c ISO/IEC N3242=11-0012
4 Effects: Equivalent to shared_ptr(std::move(r)).swap(*this).
5 Returns: *this.
template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);
6 Effects: Equivalent to shared_ptr(std::move(r)).swap(*this).
7 Returns: *this
20.7.2.2.4 shared_ptr modifiers [util.smartptr.shared.mod]
void swap(shared_ptr& r) noexcept;
1 Effects: Exchanges the contents of *this and r.
void reset() noexcept;
2 Effects: Equivalent to shared_ptr().swap(*this).
template<class Y> void reset(Y* p);
3 Effects: Equivalent to shared_ptr(p).swap(*this).
template<class Y, class D> void reset(Y* p, D d);
4 Effects: Equivalent to shared_ptr(p, d).swap(*this).
template<class Y, class D, class A> void reset(Y* p, D d, A a);
5 Effects: Equivalent to shared_ptr(p, d, a).swap(*this).
20.7.2.2.5 shared_ptr observers [util.smartptr.shared.obs]
T* get() const noexcept;
1 Returns: the stored pointer.
T& operator*() const noexcept;
2 Requires: get() != 0.
3 Returns: *get().
4 Remarks: When T is void, it is unspecified whether this member function is declared. If it is declared,
it is unspecified what its return type is, except that the declaration (although not necessarily the
definition) of the function shall be well formed.
T* operator->() const noexcept;
5 Requires: get() != 0.
6 Returns: get().
long use_count() const noexcept;
7 Returns: the number of shared_ptr objects, *this included, that share ownership with *this, or 0
when *this is empty.
8 [ Note: use_count() is not necessarily efficient. — end note ]
bool unique() const noexcept;
§ 20.7.2.2.5 548

 c ISO/IEC N3242=11-0012
9 Returns: use_count() == 1.
10 [ Note: unique() may be faster than use_count(). If you are using unique() to implement copy on
write, do not rely on a specific value when get() == 0. — end note ]
explicit operator bool() const noexcept;
11 Returns: get() != 0.
template<class U> bool owner_before(shared_ptr<U> const& b) const;
template<class U> bool owner_before(weak_ptr<U> const& b) const;
12 Returns: An unspecified value such that
— x.owner_before(y) defines a strict weak ordering as defined in 25.4;
— under the equivalence relation defined by owner_before, !a.owner_before(b) && !b.owner_-
before(a), two shared_ptr or weak_ptr instances are equivalent if and only if they share ownership or are both empty.
20.7.2.2.6 shared_ptr creation [util.smartptr.shared.create]
template<class T, class... Args> shared_ptr<T> make_shared(Args&&... args);
template<class T, class A, class... Args>
shared_ptr<T> allocate_shared(const A& a, Args&&... args);
1 Requires: The expression ::new (pv) T(std::forward<Args>(args)...), where pv has type void*
and points to storage suitable to hold an object of type T, shall be well formed. A shall be an allocator (17.6.3.5). The copy constructor and destructor of A shall not throw exceptions.
2 Effects: Allocates memory suitable for an object of type T and constructs an object in that memory
via the placement new expression ::new (pv) T(std::forward<Args>(args)...). The template
allocate_shared uses a copy of a to allocate memory. If an exception is thrown, the functions have
no effect.
3 Returns: A shared_ptr instance that stores and owns the address of the newly constructed object of
type T.
4 Postconditions: get() != 0 && use_count() == 1
5 Throws: bad_alloc, or an exception thrown from A::allocate or from the constructor of T.
6 Remarks: Implementations are encouraged, but not required, to perform no more than one memory
allocation. [ Note: This provides efficiency equivalent to an intrusive smart pointer. — end note ]
7 [ Note: These functions will typically allocate more memory than sizeof(T) to allow for internal
bookkeeping structures such as the reference counts. — end note ]
20.7.2.2.7 shared_ptr comparison [util.smartptr.shared.cmp]
template<class T, class U> bool operator==(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
1 Returns: a.get() == b.get().
template<class T, class U> bool operator<(const shared_ptr<T>& a, const shared_ptr<U>& b) noexcept;
2 Returns: less<V>()(a.get(), b.get()), where V is the composite pointer type (5.9) of T* and U*.
§ 20.7.2.2.7 549

 c ISO/IEC N3242=11-0012
3 [ Note: Defining a comparison operator allows shared_ptr objects to be used as keys in associative
containers. — end note ]
20.7.2.2.8 shared_ptr specialized algorithms [util.smartptr.shared.spec]
template<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;
1 Effects: Equivalent to a.swap(b).
20.7.2.2.9 shared_ptr casts [util.smartptr.shared.cast]
template<class T, class U> shared_ptr<T> static_pointer_cast(const shared_ptr<U>& r) noexcept;
1 Requires: The expression static_cast<T*>(r.get()) shall be well formed.
2 Returns: If r is empty, an empty shared_ptr<T>; otherwise, a shared_ptr<T> object that stores
static_cast<T*>(r.get()) and shares ownership with r.
3 Postconditions: w.get() == static_cast<T*>(r.get()) and w.use_count() == r.use_count(),
where w is the return value.
4 [ Note: The seemingly equivalent expression shared_ptr<T>(static_cast<T*>(r.get())) will eventually result in undefined behavior, attempting to delete the same object twice. — end note ]
template<class T, class U> shared_ptr<T> dynamic_pointer_cast(const shared_ptr<U>& r) noexcept;
5 Requires: The expression dynamic_cast<T*>(r.get()) shall be well formed and shall have well defined
behavior.
6 Returns:
— When dynamic_cast<T*>(r.get()) returns a nonzero value, a shared_ptr<T> object that stores
a copy of it and shares ownership with r;
— Otherwise, an empty shared_ptr<T> object.
7 Postcondition: w.get() == dynamic_cast<T*>(r.get()), where w is the return value.
8 [ Note: The seemingly equivalent expression shared_ptr<T>(dynamic_cast<T*>(r.get())) will eventually result in undefined behavior, attempting to delete the same object twice. — end note ]
template<class T, class U> shared_ptr<T> const_pointer_cast(const shared_ptr<U>& r) noexcept;
9 Requires: The expression const_cast<T*>(r.get()) shall be well formed.
10 Returns: If r is empty, an empty shared_ptr<T>; otherwise, a shared_ptr<T> object that stores
const_cast<T*>(r.get()) and shares ownership with r.
11 Postconditions: w.get() == const_cast<T*>(r.get()) and w.use_count() == r.use_count(), where
w is the return value.
12 [ Note: The seemingly equivalent expression shared_ptr<T>(const_cast<T*>(r.get())) will eventually result in undefined behavior, attempting to delete the same object twice. — end note ]
20.7.2.2.10 get_deleter [util.smartptr.getdeleter]
template<class D, class T> D* get_deleter(const shared_ptr<T>& p) noexcept;
§ 20.7.2.2.10 550

 c ISO/IEC N3242=11-0012
1 Returns: If p owns a deleter d of type cv-unqualified D, returns &d; otherwise returns 0. The returned
pointer remains valid as long as there exists a shared_ptr instance that owns d. [ Note: It is unspecified
whether the pointer remains valid longer than that. This can happen if the implementation doesn’t
destroy the deleter until all weak_ptr instances that share ownership with p have been destroyed.
— end note ]
20.7.2.2.11 shared_ptr I/O [util.smartptr.shared.io]
template<class E, class T, class Y>
basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);
1 Effects: os << p.get();.
2 Returns: os.
20.7.2.3 Class template weak_ptr [util.smartptr.weak]
1 The weak_ptr class template stores a weak reference to an object that is already managed by a shared_ptr.
To access the object, a weak_ptr can be converted to a shared_ptr using the member function lock.
namespace std {
template<class T> class weak_ptr {
public:
typedef T element_type;
// 20.7.2.3.1, constructors
constexpr weak_ptr() noexcept;
template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;
weak_ptr(weak_ptr const& r) noexcept;
template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;
// 20.7.2.3.2, destructor
~weak_ptr();
// 20.7.2.3.3, assignment
weak_ptr& operator=(weak_ptr const& r) noexcept;
template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;
template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;
// 20.7.2.3.4, modifiers
void swap(weak_ptr& r) noexcept;
void reset() noexcept;
// 20.7.2.3.5, observers
long use_count() const noexcept;
bool expired() const noexcept;
shared_ptr<T> lock() const noexcept;
template<class U> bool owner_before(shared_ptr<U> const& b);
template<class U> bool owner_before(weak_ptr<U> const& b);
};
// 20.7.2.3.6, specialized algorithms
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
} // namespace std
§ 20.7.2.3 551

 c ISO/IEC N3242=11-0012
2 Specializations of weak_ptr shall be CopyConstructible and CopyAssignable, allowing their use in standard containers. The template parameter T of weak_ptr may be an incomplete type.
20.7.2.3.1 weak_ptr constructors [util.smartptr.weak.const]
constexpr weak_ptr() noexcept;
1 Effects: Constructs an empty weak_ptr object.
2 Postconditions: use_count() == 0.
weak_ptr(const weak_ptr& r) noexcept;
template<class Y> weak_ptr(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr(const shared_ptr<Y>& r) noexcept;
3 Requires: The second and third constructors shall not participate in the overload resolution unless Y*
is implicitly convertible to T*.
4 Effects: If r is empty, constructs an empty weak_ptr object; otherwise, constructs a weak_ptr object
that shares ownership with r and stores a copy of the pointer stored in r.
5 Postconditions: use_count() == r.use_count().
20.7.2.3.2 weak_ptr destructor [util.smartptr.weak.dest]
~weak_ptr();
1 Effects: Destroys this weak_ptr object but has no effect on the object its stored pointer points to.
20.7.2.3.3 weak_ptr assignment [util.smartptr.weak.assign]
weak_ptr& operator=(const weak_ptr& r) noexcept;
template<class Y> weak_ptr& operator=(const weak_ptr<Y>& r) noexcept;
template<class Y> weak_ptr& operator=(const shared_ptr<Y>& r) noexcept;
1 Effects: Equivalent to weak_ptr(r).swap(*this).
2 Remarks: The implementation may meet the effects (and the implied guarantees) via different means,
without creating a temporary.
20.7.2.3.4 weak_ptr modifiers [util.smartptr.weak.mod]
void swap(weak_ptr& r) noexcept;
1 Effects: Exchanges the contents of *this and r.
void reset() noexcept;
2 Effects: Equivalent to weak_ptr().swap(*this).
20.7.2.3.5 weak_ptr observers [util.smartptr.weak.obs]
long use_count() const noexcept;
1 Returns: 0 if *this is empty; otherwise, the number of shared_ptr instances that share ownership
with *this.
2 [ Note: use_count() is not necessarily efficient. — end note ]
§ 20.7.2.3.5 552

 c ISO/IEC N3242=11-0012
bool expired() const noexcept;
3 Returns: use_count() == 0.
4 [ Note: expired() may be faster than use_count(). — end note ]
shared_ptr<T> lock() const noexcept;
5 Returns: expired() ? shared_ptr<T>() : shared_ptr<T>(*this).
template<class U> bool owner_before(shared_ptr<U> const& b);
template<class U> bool owner_before(weak_ptr<U> const& b);
6 Returns: An unspecified value such that
— x.owner_before(y) defines a strict weak ordering as defined in 25.4;
— under the equivalence relation defined by owner_before, !a.owner_before(b) && !b.owner_-
before(a), two shared_ptr or weak_ptr instances are equivalent if and only if they share ownership or are both empty.
20.7.2.3.6 weak_ptr specialized algorithms [util.smartptr.weak.spec]
template<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;
1 Effects: Equivalent to a.swap(b).
20.7.2.3.7 Class template owner_less [util.smartptr.ownerless]
1 The class template owner_less allows ownership-based mixed comparisons of shared and weak pointers.
namespace std {
template<class T> struct owner_less;
template<class T> struct owner_less<shared_ptr<T> > {
typedef bool result_type;
typedef shared_ptr<T> first_argument_type;
typedef shared_ptr<T> second_argument_type;
bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;
bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
};
template<class T> struct owner_less<weak_ptr<T> > {
typedef bool result_type;
typedef weak_ptr<T> first_argument_type;
typedef weak_ptr<T> second_argument_type;
bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;
bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;
};
}
2 operator()(x,y) shall return x.owner_before(y). [ Note: Note that
— operator() defines a strict weak ordering as defined in 25.4;
§ 20.7.2.3.7 553

 c ISO/IEC N3242=11-0012
— under the equivalence relation defined by operator(), !operator()(a, b) && !operator()(b, a),
two shared_ptr or weak_ptr instances are equivalent if and only if they share ownership or are both
empty.
20.7.2.4 Class template enable_shared_from_this [util.smartptr.enab]
1 A class T can inherit from enable_shared_from_this<T> to inherit the shared_from_this member functions that obtain a shared_ptr instance pointing to *this.
2 [ Example:
struct X: public enable_shared_from_this<X> {
};
int main() {
shared_ptr<X> p(new X);
shared_ptr<X> q = p->shared_from_this();
assert(p == q);
assert(!(p < q ) && !(q < p)); // p and q share ownership
} —
end example ]
namespace std {
template<class T> class enable_shared_from_this {
protected:
constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(enable_shared_from_this const&) noexcept;
enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;
~enable_shared_from_this();
public:
shared_ptr<T> shared_from_this();
shared_ptr<T const> shared_from_this() const;
};
} // namespace std
3 The template parameter T of enable_shared_from_this may be an incomplete type.
constexpr enable_shared_from_this() noexcept;
enable_shared_from_this(const enable_shared_from_this<T>&) noexcept;
4 Effects: Constructs an enable_shared_from_this<T> object.
enable_shared_from_this<T>& operator=(const enable_shared_from_this<T>&) noexcept;
5 Returns: *this.
~enable_shared_from_this();
6 Effects: Destroys *this.
shared_ptr<T> shared_from_this();
shared_ptr<T const> shared_from_this() const;
7 Requires: enable_shared_from_this<T> shall be an accessible base class of T. *this shall be a
subobject of an object t of type T. There shall be at least one shared_ptr instance p that owns &t.
8 Returns: A shared_ptr<T> object r that shares ownership with p.
§ 20.7.2.4 554

 c ISO/IEC N3242=11-0012
9 Postconditions: r.get() == this.
10 [ Note: A possible implementation is shown below:
template<class T> class enable_shared_from_this {
private:
weak_ptr<T> __weak_this;
protected:
constexpr enable_shared_from_this() : __weak_this() { }
enable_shared_from_this(enable_shared_from_this const &) { }
enable_shared_from_this& operator=(enable_shared_from_this const &) { return *this; }
~enable_shared_from_this() { }
public:
shared_ptr<T> shared_from_this() { return shared_ptr<T>(__weak_this); }
shared_ptr<T const> shared_from_this() const { return shared_ptr<T const>(__weak_this); }
};
11 The shared_ptr constructors that create unique pointers can detect the presence of an enable_shared_-
from_this base and assign the newly created shared_ptr to its __weak_this member. — end note ]
20.7.2.5 shared_ptr atomic access [util.smartptr.shared.atomic]
1 Concurrent access to a shared_ptr object from multiple threads does not introduce a data race if the access
is done exclusively via the functions in this section and the instance is passed as their first argument.
2 The meaning of the arguments of type memory_order is explained in 29.3.
template<class T>
bool atomic_is_lock_free(const shared_ptr<T>* p) noexcept;
3 Requires: p shall not be null.
4 Returns: true if atomic access to *p is lock-free, false otherwise.
template<class T>
shared_ptr<T> atomic_load(const shared_ptr<T>* p) noexcept;
5 Requires: p shall not be null.
6 Returns: atomic_load_explicit(p, memory_order_seq_cst).
template<class T>
shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo) noexcept;
7 Requires: p shall not be null.
8 Requires: mo shall not be memory_order_release or memory_order_acq_rel.
9 Returns: *p.
template<class T>
void atomic_store(shared_ptr<T>* p, shared_ptr<T> r) noexcept;
10 Requires: p shall not be null.
11 Effects: atomic_store_explicit(p, r, memory_order_seq_cst).
template<class T>
void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo) noexcept;
§ 20.7.2.5 555

 c ISO/IEC N3242=11-0012
12 Requires: p shall not be null.
13 Requires: mo shall not be memory_order_acquire or memory_order_acq_rel.
14 Effects: p->swap(r).
template<class T>
shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r) noexcept;
15 Requires: p shall not be null.
16 Returns: atomic_exchange_explicit(p, r, memory_order_seq_cst).
template<class T>
shared_ptr<T> atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r,
memory_order mo) noexcept;
17 Requires: p shall not be null.
18 Effects: p->swap(r).
19 Returns: The previous value of *p.
template<class T>
bool atomic_compare_exchange_weak(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w) noexcept;
20 Requires: p shall not be null.
21 Returns: atomic_compare_exchange_weak_explicit(p, v, w, memory_order_seq_cst, memory_-
order_seq_cst).
template<class T>
bool atomic_compare_exchange_strong(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w) noexcept;
22 Returns: atomic_compare_exchange_strong_explicit(p, v, w, memory_order_seq_cst, memory_-
order_seq_cst).
template<class T>
bool atomic_compare_exchange_weak_explicit(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure) noexcept;
template<class T>
bool atomic_compare_exchange_strong_explicit(
shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w,
memory_order success, memory_order failure) noexcept;
23 Requires: p shall not be null.
24 Requires: failure shall not be memory_order_release, memory_order_acq_rel, or stronger than
success.
25 Effects: If *p is equivalent to *v, assigns w to *p and has synchronization semantics corresponding to
the value of success, otherwise assigns *p to *v and has synchronization semantics corresponding to
the value of failure.
26 Returns: true if *p was equivalent to *v, false otherwise.
Throws: nothing.
§ 20.7.2.5 556

 c ISO/IEC N3242=11-0012
27 Remarks: two shared_ptr objects are equivalent if they store the same pointer value and share
ownership.
28 Remarks: the weak forms may fail spuriously. See 29.6.
20.7.2.6 Smart pointer hash support [util.smartptr.hash]
template <class T, class D> struct hash<unique_ptr<T, D> >;
1 Requires: The template specialization shall meet the requirements of class template hash (20.8.12). For
an object p of type UP, where UP is unique_ptr<T, D>, hash<UP>()(p) shall evaluate to the same value
as hash<typename UP::pointer>()(p.get()). The specialization hash<typename UP::pointer>
shall be well-formed.
template <class T> struct hash<shared_ptr<T> >;
2 Requires: The template specialization shall meet the requirements of class template hash (20.8.12).
For an object p of type shared_ptr<T>, hash<shared_ptr<T> >()(p) shall evaluate to the same value
as hash<T*>()(p.get()).
20.8 Function objects [function.objects]
1 A function object type is an object type (3.9) that can be the type of the postfix-expression in a function call
(5.2.2, 13.3.1.1).228 A function object is an object of a function object type. In the places where one would
expect to pass a pointer to a function to an algorithmic template (Clause 25), the interface is specified to
accept a function object. This not only makes algorithmic templates work with pointers to functions, but
also enables them to work with arbitrary function objects.
2 Header <functional> synopsis
namespace std {
// D.8.1, base (deprecated):
template <class Arg, class Result> struct unary_function;
template <class Arg1, class Arg2, class Result> struct binary_function;
// 20.8.3, reference_wrapper:
template <class T> class reference_wrapper;
template <class T> reference_wrapper<T> ref(T&) noexcept;
template <class T> reference_wrapper<const T> cref(const T&) noexcept;
template <class T> void ref(const T&&) = delete;
template <class T> void cref(const T&&) = delete;
template <class T> reference_wrapper<T> ref(reference_wrapper<T>) noexcept;
template <class T> reference_wrapper<const T> cref(reference_wrapper<T>) noexcept;
// 20.8.4, arithmetic operations:
template <class T> struct plus;
template <class T> struct minus;
template <class T> struct multiplies;
template <class T> struct divides;
template <class T> struct modulus;
template <class T> struct negate;
228) Such a type is a function pointer or a class type which has a member operator() or a class type which has a conversion
to a pointer to function.
§ 20.8 557

 c ISO/IEC N3242=11-0012
// 20.8.5, comparisons:
template <class T> struct equal_to;
template <class T> struct not_equal_to;
template <class T> struct greater;
template <class T> struct less;
template <class T> struct greater_equal;
template <class T> struct less_equal;
// 20.8.6, logical operations:
template <class T> struct logical_and;
template <class T> struct logical_or;
template <class T> struct logical_not;
// 20.8.7, bitwise operations:
template <class T> struct bit_and;
template <class T> struct bit_or;
template <class T> struct bit_xor;
// 20.8.8, negators:
template <class Predicate> class unary_negate;
template <class Predicate>
unary_negate<Predicate> not1(const Predicate&);
template <class Predicate> class binary_negate;
template <class Predicate>
binary_negate<Predicate> not2(const Predicate&);
// 20.8.9, bind:
template<class T> struct is_bind_expression;
template<class T> struct is_placeholder;
template<class F, class... BoundArgs>
unspecified bind(F&&, BoundArgs&&...);
template<class R, class F, class... BoundArgs>
unspecified bind(F&&, BoundArgs&&...);
namespace placeholders {
// M is the implementation-defined number of placeholders
extern unspecified _1;
extern unspecified _2;
...
extern unspecified _M;
}
// D.9, binders (deprecated):
template <class Fn> class binder1st;
template <class Fn, class T>
binder1st<Fn> bind1st(const Fn&, const T&);
template <class Fn> class binder2nd;
template <class Fn, class T>
binder2nd<Fn> bind2nd(const Fn&, const T&);
// D.8.2.1, adaptors (deprecated):
§ 20.8 558

 c ISO/IEC N3242=11-0012
template <class Arg, class Result> class pointer_to_unary_function;
template <class Arg, class Result>
pointer_to_unary_function<Arg,Result> ptr_fun(Result (*)(Arg));
template <class Arg1, class Arg2, class Result>
class pointer_to_binary_function;
template <class Arg1, class Arg2, class Result>
pointer_to_binary_function<Arg1,Arg2,Result>
ptr_fun(Result (*)(Arg1,Arg2));
// D.8.2.2, adaptors (deprecated):
template<class S, class T> class mem_fun_t;
template<class S, class T, class A> class mem_fun1_t;
template<class S, class T>
mem_fun_t<S,T> mem_fun(S (T::*f)());
template<class S, class T, class A>
mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));
template<class S, class T> class mem_fun_ref_t;
template<class S, class T, class A> class mem_fun1_ref_t;
template<class S, class T>
mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)());
template<class S, class T, class A>
mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));
template <class S, class T> class const_mem_fun_t;
template <class S, class T, class A> class const_mem_fun1_t;
template <class S, class T>
const_mem_fun_t<S,T> mem_fun(S (T::*f)() const);
template <class S, class T, class A>
const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);
template <class S, class T> class const_mem_fun_ref_t;
template <class S, class T, class A> class const_mem_fun1_ref_t;
template <class S, class T>
const_mem_fun_ref_t<S,T> mem_fun_ref(S (T::*f)() const);
template <class S, class T, class A>
const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);
// 20.8.10, member function adaptors:
template<class R, class T> unspecified mem_fn(R T::*) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...)) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) volatile) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const volatile) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) volatile &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const volatile &) noexcept;
template<class R, class T, class... Args>
§ 20.8 559

 c ISO/IEC N3242=11-0012
unspecified mem_fn(R (T::*)(Args...) &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) volatile &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::*)(Args...) const volatile &&) noexcept;
// 20.8.11 polymorphic function wrappers:
class bad_function_call;
template<class> class function; // undefined
template<class R, class... ArgTypes> class function<R(ArgTypes...)>;
template<class R, class... ArgTypes>
void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);
template<class R, class... ArgTypes>
bool operator==(const function<R(ArgTypes...)>&, nullptr_t);
template<class R, class... ArgTypes>
bool operator==(nullptr_t, const function<R(ArgTypes...)>&);
template<class R, class... ArgTypes>
bool operator!=(const function<R(ArgTypes...)>&, nullptr_t);
template<class R, class... ArgTypes>
bool operator!=(nullptr_t, const function<R(ArgTypes...)>&);
// 20.8.12, hash function base template:
template <class T> struct hash;
// Hash function specializations
template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long>;
template <> struct hash<unsigned long long>;
template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;
template<class T> struct hash<T*>;
}
3 [ Example: If a C++ program wants to have a by-element addition of two vectors a and b containing double
and put the result into a, it can do:
§ 20.8 560

 c ISO/IEC N3242=11-0012
transform(a.begin(), a.end(), b.begin(), a.begin(), plus<double>());
— end example ]
4 [ Example: To negate every element of a:
transform(a.begin(), a.end(), a.begin(), negate<double>());
— end example ]
5 To enable adaptors and other components to manipulate function objects that take one or two arguments
it is required that the function objects correspondingly provide typedefs argument_type and result_-
type for function objects that take one argument and first_argument_type, second_argument_type, and
result_type for function objects that take two arguments.
20.8.1 Definitions [func.def]
1 The following definitions apply to this Clause:
2 A call signature is the name of a return type followed by a parenthesized comma-separated list of zero or
more argument types.
3 A callable type is a function object type (20.8) or a pointer to member.
4 A callable object is an object of a callable type.
5 A call wrapper type is a type that holds a callable object and supports a call operation that forwards to that
object.
6 A call wrapper is an object of a call wrapper type.
7 A target object is the callable object held by a call wrapper.
20.8.2 Requirements [func.require]
1 Define INVOKE(f, t1, t2, ..., tN) as follows:
— (t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is an object of
type T or a reference to an object of type T or a reference to an object of a type derived from T;
— ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is not one of
the types described in the previous item;
— t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is an object of type T or a
reference to an object of type T or a reference to an object of a type derived from T;
— (*t1).*f when N == 1 and f is a pointer to member data of a class T and t1 is not one of the types
described in the previous item;
— f(t1, t2, ..., tN) in all other cases.
2 Define INVOKE(f, t1, t2, ..., tN, R) as INVOKE(f, t1, t2, ..., tN) implicitly converted to R.
3 If a call wrapper (20.8.1) has a weak result type the type of its member type result_type is based on the
type T of the wrapper’s target object (20.8.1):
— if T is a pointer to function type, result_type shall be a synonym for the return type of T;
— if T is a pointer to member function, result_type shall be a synonym for the return type of T;
— if T is a class type with a member type result_type, then result_type shall be a synonym for
T::result_type;
§ 20.8.2 561

 c ISO/IEC N3242=11-0012
— otherwise result_type shall not be defined.
4 Every call wrapper (20.8.1) shall be MoveConstructible. A simple call wrapper is a call wrapper that is
CopyConstructible and CopyAssignable and whose copy constructor, move constructor, and assignment
operator do not throw exceptions. A forwarding call wrapper is a call wrapper that can be called with
an arbitrary argument list and delivers the arguments to the wrapped callable object as references. This
forwarding step shall ensure that rvalue arguments are delivered as rvalue-references and lvalue arguments
are delivered as lvalue-references. [ Note: In a typical implementation forwarding call wrappers have an
overloaded function call operator of the form
template<class... UnBoundArgs>
R operator()(UnBoundArgs&&... unbound_args) cv-qual;
— end note ]
20.8.3 Class template reference_wrapper [refwrap]
namespace std {
template <class T> class reference_wrapper {
public :
// types
typedef T type;
typedef see below result_type; // not always defined
typedef see below argument_type; // not always defined
typedef see below first_argument_type; // not always defined
typedef see below second_argument_type; // not always defined
// construct/copy/destroy
reference_wrapper(T&) noexcept;
reference_wrapper(T&&) = delete; // do not bind to temporary objects
reference_wrapper(const reference_wrapper<T>& x) noexcept;
// assignment
reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;
// access
operator T& () const noexcept;
T& get() const noexcept;
// invocation
template <class... ArgTypes>
typename result_of<T(ArgTypes...)>::type
operator() (ArgTypes&&...) const;
};
}
1 reference_wrapper<T> is a CopyConstructible and CopyAssignable wrapper around a reference to an object
or function of type T.
2 reference_wrapper has a weak result type (20.8.2).
3 The template instantiation reference_wrapper<T> shall define a nested type named argument_type as a
synonym for T1 only if the type T is any of the following:
— a function type or a pointer to function type taking one argument of type T1
§ 20.8.3 562

 c ISO/IEC N3242=11-0012
— a pointer to member function R T0::f cv (where cv represents the member function’s cv-qualifiers);
the type T1 is cv T0*
— a class type with a member type argument_type; the type T1 is T::argument_type.
4 The template instantiation reference_wrapper<T> shall define two nested types named first_argument_-
type and second_argument_type as synonyms for T1 and T2, respectively, only if the type T is any of the
following:
— a function type or a pointer to function type taking two arguments of types T1 and T2
— a pointer to member function R T0::f(T2) cv (where cv represents the member function’s cv-qualifiers);
the type T1 is cv T0*
— a class type with member types first_argument_type and second_argument_type; the type T1 is
T::first_argument_type. and the type T2 is T::second_argument_type.
20.8.3.1 reference_wrapper construct/copy/destroy [refwrap.const]
reference_wrapper(T& t) noexcept;
1 Effects: Constructs a reference_wrapper object that stores a reference to t.
reference_wrapper(const reference_wrapper<T>& x) noexcept;
2 Effects: Constructs a reference_wrapper object that stores a reference to x.get().
20.8.3.2 reference_wrapper assignment [refwrap.assign]
reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;
1 Postconditions: *this stores a reference to x.get().
20.8.3.3 reference_wrapper access [refwrap.access]
operator T& () const noexcept;
1 Returns: The stored reference.
T& get() const noexcept;
2 Returns: The stored reference.
20.8.3.4 reference_wrapper invocation [refwrap.invoke]
template <class... ArgTypes>
typename result_of<T(ArgTypes... )>::type
operator()(ArgTypes&&... args) const;
1 Returns: INVOKE(get(), std::forward<ArgTypes>(args)...). (20.8.2)
2 Remark: operator() is described for exposition only. Implementations are not required to provide an
actual reference_wrapper::operator(). Implementations are permitted to support reference_-
wrapper function invocation through multiple overloaded operators or through other means.
§ 20.8.3.4 563

 c ISO/IEC N3242=11-0012
20.8.3.5 reference_wrapper helper functions [refwrap.helpers]
template <class T> reference_wrapper<T> ref(T& t) noexcept;
1 Returns: reference_wrapper<T>(t)
template <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;
2 Returns: ref(t.get())
template <class T> reference_wrapper<const T> cref(const T& t) noexcept;
3 Returns: reference_wrapper <const T>(t)
template <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;
4 Returns: cref(t.get());
20.8.4 Arithmetic operations [arithmetic.operations]
1 The library provides basic function object classes for all of the arithmetic operators in the language (5.6,
5.7).
template <class T> struct plus {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
2 operator() returns x + y.
template <class T> struct minus {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
3 operator() returns x - y.
template <class T> struct multiplies {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
4 operator() returns x * y.
template <class T> struct divides {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
5 operator() returns x / y.
§ 20.8.4 564

 c ISO/IEC N3242=11-0012
template <class T> struct modulus {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
6 operator() returns x % y.
template <class T> struct negate {
T operator()(const T& x) const;
typedef T argument_type;
typedef T result_type;
};
7 operator() returns -x.
20.8.5 Comparisons [comparisons]
1 The library provides basic function object classes for all of the comparison operators in the language (5.9,
5.10).
template <class T> struct equal_to {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
2 operator() returns x == y.
template <class T> struct not_equal_to {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
3 operator() returns x != y.
template <class T> struct greater {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
4 operator() returns x > y.
template <class T> struct less {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
5 operator() returns x < y.
§ 20.8.5 565

 c ISO/IEC N3242=11-0012
template <class T> struct greater_equal {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
6 operator() returns x >= y.
template <class T> struct less_equal {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
7 operator() returns x <= y.
8 For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type
yield a total order, even if the built-in operators <, >, <=, >= do not.
20.8.6 Logical operations [logical.operations]
1 The library provides basic function object classes for all of the logical operators in the language (5.14, 5.15,
5.3.1).
template <class T> struct logical_and {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
2 operator() returns x && y.
template <class T> struct logical_or {
bool operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef bool result_type;
};
3 operator() returns x || y.
template <class T> struct logical_not {
bool operator()(const T& x) const;
typedef T argument_type;
typedef bool result_type;
};
4 operator() returns !x.
20.8.7 Bitwise operations [bitwise.operations]
1 The library provides basic function object classes for all of the bitwise operators in the language (5.11, 5.13,
5.12).
§ 20.8.7 566

 c ISO/IEC N3242=11-0012
template <class T> struct bit_and {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
2 operator() returns x & y.
template <class T> struct bit_or {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
3 operator() returns x | y.
template <class T> struct bit_xor {
T operator()(const T& x, const T& y) const;
typedef T first_argument_type;
typedef T second_argument_type;
typedef T result_type;
};
4 operator() returns x ˆ y.
20.8.8 Negators [negators]
1 Negators not1 and not2 take a unary and a binary predicate, respectively, and return their complements (5.3.1).
template <class Predicate>
class unary_negate {
public:
explicit unary_negate(const Predicate& pred);
bool operator()(const typename Predicate::argument_type& x) const;
typedef typename Predicate::argument_type argument_type;
typedef bool result_type;
};
2 operator() returns !pred(x).
template <class Predicate>
unary_negate<Predicate> not1(const Predicate& pred);
3 Returns: unary_negate<Predicate>(pred).
template <class Predicate>
class binary_negate {
public:
explicit binary_negate(const Predicate& pred);
bool operator()(const typename Predicate::first_argument_type& x,
const typename Predicate::second_argument_type& y) const;
typedef typename Predicate::first_argument_type first_argument_type;
typedef typename Predicate::second_argument_type second_argument_type;
typedef bool result_type;
§ 20.8.8 567

 c ISO/IEC N3242=11-0012
};
4 operator() returns !pred(x,y).
template <class Predicate>
binary_negate<Predicate> not2(const Predicate& pred);
5 Returns: binary_negate<Predicate>(pred).
20.8.9 Function template bind [bind]
1 The function template bind returns an object that binds a callable object passed as an argument to additional
arguments.
20.8.9.1 Function object binders [func.bind]
1 This subclause describes a uniform mechanism for binding arguments of callable objects.
20.8.9.1.1 Class template is_bind_expression [func.bind.isbind]
namespace std {
template<class T> struct is_bind_expression
: integral_constant<bool, see below> { };
}
1 is_bind_expression can be used to detect function objects generated by bind. bind uses is_bind_-
expression to detect subexpressions. Users may specialize this template to indicate that a type should be
treated as a subexpression in a bind call.
2 If T is a type returned from bind, is_bind_expression<T> shall be publicly derived from integral_-
constant<bool, true>, otherwise from integral_constant<bool, false>.
3 is_placeholder can be used to detect the standard placeholders _1, _2, and so on. bind uses is_-
placeholder to detect placeholders. Users may specialize this template to indicate a placeholder type.
4 If T is the type of std::placeholders::_J, is_placeholder<T> shall be publicly derived from integral_-
constant<int, J>, otherwise from integral_constant<int, 0>.
20.8.9.1.2 Function template bind [func.bind.bind]
1 In the text that follows, the following names have the following meanings:
— FD is the type decay<F>::type,
— fd is an lvalue of type FD constructed from std::forward<F>(f),
— Ti is the ith type in the template parameter back BoundArgs,
— TiD is the type decay<Ti>::type,
— ti is the ith argument in the function paramater pack bound_args,
— tid is an lvalue of type TiD constructed from std::forward<Ti>(ti),
— Uj is the jth deduced type of the UnBoundArgs&&... parameter of the forwarding call wrapper, and
— uj is the jth argument associated with Uj.
template<class F, class... BoundArgs>
unspecified bind(F&& f, BoundArgs&&... bound_args);
§ 20.8.9.1.2 568

 c ISO/IEC N3242=11-0012
2 Requires: is_constructible<FD, F>::value shall be true. For each Ti in BoundArgs, is_constructible<TiD,
Ti>::value shall be true. INVOKE (fd, w1, w2, ..., wN) (20.8.2) shall be a valid expression for
some values w1, w2, ..., wN, where N == sizeof...(bound_args).
3 Returns: A forwarding call wrapper g with a weak result type (20.8.2). The effect of g(u1, u2, ...,
uM) shall be INVOKE(fd, v1, v2, ..., vN, result_of<FD cv (V1, V2, ..., VN)>::type), where
cv represents the cv-qualifiers of g and the values and types of the bound arguments v1, v2, ...,
vN are determined as specified below. The copy constructor and move constructor of the forwarding
call wrapper shall throw an exception if and only if the corresponding constructor of FD or of any of
the types TiD throws an exception.
4 Throws: Nothing unless the construction of fd or of one of the values tid throws an exception.
5 Remarks: The return type shall satisfy the requirements of MoveConstructible. If all of FD and TiD
satisfy the requirements of CopyConstructible, then the return type shall satisfy the requirements
of CopyConstructible. [ Note: This implies that all of FD and TiD are MoveConstructible. — end
note ]
template<class R, class F, class... BoundArgs>
unspecified bind(F&& f, BoundArgs&&... bound_args);
6 Requires: is_constructible<FD, F>::value shall be true. For each Ti in BoundArgs, is_constructible<TiD,
Ti>::value shall be true. INVOKE(fd, w1, w2, ..., wN) shall be a valid expression for some values
w1, w2, ..., wN, where N == sizeof...(bound_args).
7 Returns: A forwarding call wrapper g with a nested type result_type defined as a synonym for
R. The effect of g(u1, u2, ..., uM) shall be INVOKE(fd, v1, v2, ..., vN, R), where the values
and types of the bound arguments v1, v2, ..., vN are determined as specified below. The copy
constructor and move constructor of the forwarding call wrapper shall throw an exception if and only
if the corresponding constructor of FD or of any of the types TiD throws an exception.
8 Throws: Nothing unless the construction of fd or of one of the values tid throws an exception.
9 Remarks: The return type shall satisfy the requirements of MoveConstructible. If all of FD and TiD
satisfy the requirements of CopyConstructible, then the return type shall satisfy the requirements
of CopyConstructible. [ Note: This implies that all of FD and TiD are MoveConstructible. — end
note ]
10 The values of the bound arguments v1, v2, ..., vN and their corresponding types V1, V2, ..., VN
depend on the types TiD derived from the call to bind and the cv-qualifiers cv of the call wrapper g as
follows:
— if TiD is reference_wrapper<T>, the argument is tid.get() and its type Vi is T&;
— if the value of is_bind_expression<TiD>::value is true, the argument is tid(std::forward<Uj>(uj)...)
and its type Vi is result_of<TiD cv (Uj...)>::type;
— if the value j of is_placeholder<TiD>::value is not zero, the argument is std::forward<Uj>(uj)
and its type Vi is Uj&&;
— otherwise, the value is tid and its type Vi is TiD cv &.
20.8.9.1.3 Placeholders [func.bind.place]
namespace std {
namespace placeholders {
// M is the implementation-defined number of placeholders
§ 20.8.9.1.3 569

 c ISO/IEC N3242=11-0012
extern unspecified _1;
extern unspecified _2;
...
extern unspecified _M;
}
}
1 All placeholder types shall be DefaultConstructible and CopyConstructible, and their default constructors and copy/move constructors shall not throw exceptions. It is implementation-defined whether
placeholder types are CopyAssignable. CopyAssignable placeholders’ copy assignment operators shall not
throw exceptions.
20.8.10 Function template mem_fn [func.memfn]
template<class R, class T>
unspecified mem_fn(R T::* pm) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...)) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) volatile) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const volatile) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) volatile &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const volatile &) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) volatile &&) noexcept;
template<class R, class T, class... Args>
unspecified mem_fn(R (T::* pm)(Args...) const volatile &&) noexcept;
1 Returns: A simple call wrapper (20.8.1) fn such that the expression fn(t, a2, ..., aN) is equivalent
to INVOKE(pm, t, a2, ..., aN) (20.8.2). fn shall have a nested type result_type that is a synonym
for the return type of pm when pm is a pointer to member function.
2 The simple call wrapper shall define two nested types named argument_type and result_type as
synonyms for cv T* and Ret, respectively, when pm is a pointer to member function with cv-qualifier
cv and taking no arguments, where Ret is pm’s return type.
The simple call wrapper shall define three nested types named first_argument_type, second_-
argument_type, and result_type as synonyms for cv T*, T1, and Ret, respectively, when pm is a
pointer to member function with cv-qualifier cv and taking one argument of type T1, where Ret is pm’s
return type.
§ 20.8.10 570

 c ISO/IEC N3242=11-0012
20.8.11 Polymorphic function wrappers [func.wrap]
1 This subclause describes a polymorphic wrapper class that encapsulates arbitrary callable objects.
20.8.11.1 Class bad_function_call [func.wrap.badcall]
1 An exception of type bad_function_call is thrown by function::operator() (20.8.11.2.4) when the
function wrapper object has no target.
namespace std {
class bad_function_call : public std::exception {
public:
// 20.8.11.1.1, constructor:
bad_function_call() noexcept;
};
} // namespace std
20.8.11.1.1 bad_function_call constructor [func.wrap.badcall.const]
bad_function_call() noexcept;
1 Effects: constructs a bad_function_call object.
20.8.11.2 Class template function [func.wrap.func]
namespace std {
template<class> class function; // undefined
template<class R, class... ArgTypes>
class function<R(ArgTypes...)> {
public:
typedef R result_type;
typedef T1 argument_type; // iff sizeof...(ArgTypes) == 1 and
// the type in ArgTypes is T1
typedef T1 first_argument_type; // iff sizeof...(ArgTypes) == 2 and
// ArgTypes contains T1 and T2
typedef T2 second_argument_type; // iff sizeof...(ArgTypes) == 2 and
// ArgTypes contains T1 and T2
// 20.8.11.2.1, construct/copy/destroy:
function() noexcept;
function(nullptr_t) noexcept;
function(const function&);
function(function&&);
template<class F> function(F);
template<class A> function(allocator_arg_t, const A&) noexcept;
template<class A> function(allocator_arg_t, const A&,
nullptr_t) noexcept;
template<class A> function(allocator_arg_t, const A&,
const function&);
template<class A> function(allocator_arg_t, const A&,
function&&);
template<class F, class A> function(allocator_arg_t, const A&, F);
function& operator=(const function&);
function& operator=(function&&);
§ 20.8.11.2 571

 c ISO/IEC N3242=11-0012
function& operator=(nullptr_t);
template<class F> function& operator=(F&&);
template<class F> function& operator=(reference_wrapper<F>) noexcept;
~function();
// 20.8.11.2.2, function modifiers:
void swap(function&) noexcept;
template<class F, class A> void assign(F&&, const A&);
// 20.8.11.2.3, function capacity:
explicit operator bool() const noexcept;
// 20.8.11.2.4, function invocation:
R operator()(ArgTypes...) const;
// 20.8.11.2.5, function target access:
const std::type_info& target_type() const noexcept;
template <typename T> T* target() noexcept;
template <typename T> const T* target() const noexcept;
};
// 20.8.11.2.6, Null pointer comparisons:
template <class R, class... ArgTypes>
bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
template <class R, class... ArgTypes>
bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
template <class R, class... ArgTypes>
bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;
template <class R, class... ArgTypes>
bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;
// 20.8.11.2.7, specialized algorithms:
template <class R, class... ArgTypes>
void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&);
template<class R, class... ArgTypes, class Alloc>
struct uses_allocator<function<R(ArgTypes...)>, Alloc>
: true_type { };
}
1 The function class template provides polymorphic wrappers that generalize the notion of a function pointer.
Wrappers can store, copy, and call arbitrary callable objects (20.8.1), given a call signature (20.8.1), allowing
functions to be first-class objects.
2 A callable object f of type F is Callable for argument types ArgTypes and return type R if the expression INVOKE(f, declval<ArgTypes>()..., R), considered as an unevaluated operand (Clause 5), is well
formed (20.8.2).
§ 20.8.11.2 572

 c ISO/IEC N3242=11-0012
3 The function class template is a call wrapper (20.8.1) whose call signature (20.8.1) is R(ArgTypes...).
20.8.11.2.1 function construct/copy/destroy [func.wrap.func.con]
1 When any function constructor that takes a first argument of type allocator_arg_t is invoked, the second
argument shall have a type that conforms to the requirements for Allocator (Table 17.6.3.5). A copy of the
allocator argument is used to allocate memory, if necessary, for the internal data structures of the constructed
function object.
function() noexcept;
template <class A> function(allocator_arg_t, const A& a) noexcept;
2 Postconditions: !*this.
function(nullptr_t) noexcept;
template <class A> function(allocator_arg_t, const A& a, nullptr_t) noexcept;
3 Postconditions: !*this.
function(const function& f);
template <class A> function(allocator_arg_t, const A& a, const function& f);
4 Postconditions: !*this if !f; otherwise, *this targets a copy of f.target().
5 Throws: shall not throw exceptions if f’s target is a callable object passed via reference_wrapper or
a function pointer. Otherwise, may throw bad_alloc or any exception thrown by the copy constructor
of the stored callable object. [ Note: Implementations are encouraged to avoid the use of dynamically
allocated memory for small callable objects, for example, where f’s target is an object holding only a
pointer or reference to an object and a member function pointer. — end note ]
function(function&& f);
template <class A> function(allocator_arg_t, const A& a, function&& f);
6 Effects: If !f, *this has no target; otherwise, move-constructs the target of f into the target of *this,
leaving f in a valid state with an unspecified value.
template<class F> function(F f);
template <class F, class A> function(allocator_arg_t, const A& a, F f);
7 Requires: F shall be CopyConstructible. f shall be Callable (20.8.11.2) for argument types ArgTypes
and return type R. The copy constructor and destructor of A shall not throw exceptions.
8 Postconditions: !*this if any of the following hold:
— f is a NULL function pointer.
— f is a NULL pointer to member.
— F is an instance of the function class template, and !f
9 Otherwise, *this targets a copy of f initialized with std::move(f). [ Note: Implementations are
encouraged to avoid the use of dynamically allocated memory for small callable objects, for example,
where f’s target is an object holding only a pointer or reference to an object and a member function
pointer. — end note ]
10 Throws: shall not throw exceptions when f is a function pointer or a reference_wrapper<T> for some
T. Otherwise, may throw bad_alloc or any exception thrown by F’s copy or move constructor.
function& operator=(const function& f);
§ 20.8.11.2.1 573

 c ISO/IEC N3242=11-0012
11 Effects: function(f).swap(*this);
12 Returns: *this
function& operator=(function&& f);
13 Effects: Replaces the target of *this with the target of f, leaving f in a valid but unspecified state.
14 Returns: *this
function& operator=(nullptr_t);
15 Effects: If *this != NULL, destroys the target of this.
16 Postconditions: !(*this).
17 Returns: *this
template<class F> function& operator=(F&& f);
18 Effects: function(std::forward<F>(f)).swap(*this);
19 Returns: *this
template<class F> function& operator=(reference_wrapper<F> f) noexcept;
20 Effects: function(f).swap(*this);
Throws: nothing.
21 Returns: *this
~function();
22 Effects: If *this != NULL, destroys the target of this.
20.8.11.2.2 function modifiers [func.wrap.func.mod]
void swap(function& other) noexcept;
1 Effects: interchanges the targets of *this and other.
template<class F, class A>
void assign(F&& f, const A& a);
2 Effects: function(allocator_arg, a, std::forward<F>(f)).swap(*this)
20.8.11.2.3 function capacity [func.wrap.func.cap]
explicit operator bool() const noexcept;
1 Returns: true if *this has a target, otherwise false.
20.8.11.2.4 function invocation [func.wrap.func.inv]
R operator()(ArgTypes... args) const
1 Effects: INVOKE(f, std::forward<ArgTypes>(args)..., R) (20.8.2), where f is the target object (20.8.1) of *this.
§ 20.8.11.2.4 574

 c ISO/IEC N3242=11-0012
2 Returns: Nothing if R is void, otherwise the return value of INVOKE(f, std::forward<ArgTypes>(args)...,
R).
3 Throws: bad_function_call if !*this; otherwise, any exception thrown by the wrapped callable
object.
20.8.11.2.5 function target access [func.wrap.func.targ]
const std::type_info& target_type() const noexcept;
1 Returns: If *this has a target of type T, typeid(T); otherwise, typeid(void).
template<typename T> T* target() noexcept;
template<typename T> const T* target() const noexcept;
2 Requires: T shall be a type that is Callable (20.8.11.2) for parameter types ArgTypes and return type
R.
3 Returns: If target_type() == typeid(T) a pointer to the stored function target; otherwise a null
pointer.
20.8.11.2.6 null pointer comparison operators [func.wrap.func.nullptr]
template <class R, class... ArgTypes>
bool operator==(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template <class R, class... ArgTypes>
bool operator==(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
1 Returns: !f.
template <class R, class... ArgTypes>
bool operator!=(const function<R(ArgTypes...)>& f, nullptr_t) noexcept;
template <class R, class... ArgTypes>
bool operator!=(nullptr_t, const function<R(ArgTypes...)>& f) noexcept;
2 Returns: (bool) f.
20.8.11.2.7 specialized algorithms [func.wrap.func.alg]
template<class R, class... ArgTypes>
void swap(function<R(ArgTypes...)>& f1, function<R(ArgTypes...)>& f2);
1 Effects: f1.swap(f2);
20.8.12 Class template hash [unord.hash]
1 The unordered associative containers defined in 23.5 use specializations of the class template hash as the
default hash function. For all object types Key for which there exists a specialization hash<Key>, the
instantiation hash<Key> shall:
— satisfy the Hash requirements (17.6.3.4), with Key as the function call argument type, the DefaultConstructible
requirements (Table 19), the CopyAssignable requirements (Table 23),
— be swappable (17.6.3.2) for lvalues,
— provide two nested types result_type and argument_type which shall be synonyms for size_t and
Key, respectively,
§ 20.8.12 575

 c ISO/IEC N3242=11-0012
— satisfy the requirement that if k1 == k2 is true, h(k1) == h(k2) is also true, where h is an object of
type hash<Key> and k1 and k2 are objects of type Key.
template <> struct hash<bool>;
template <> struct hash<char>;
template <> struct hash<signed char>;
template <> struct hash<unsigned char>;
template <> struct hash<char16_t>;
template <> struct hash<char32_t>;
template <> struct hash<wchar_t>;
template <> struct hash<short>;
template <> struct hash<unsigned short>;
template <> struct hash<int>;
template <> struct hash<unsigned int>;
template <> struct hash<long>;
template <> struct hash<unsigned long>;
template <> struct hash<long long>;
template <> struct hash<unsigned long long>;
template <> struct hash<float>;
template <> struct hash<double>;
template <> struct hash<long double>;
template <class T> struct hash<T*>;
2 Requires: the template specializations shall meet the requirements of class template hash (20.8.12).
20.9 Metaprogramming and type traits [meta]
1 This subclause describes components used by C++ programs, particularly in templates, to support the
widest possible range of types, optimise template code usage, detect type related user errors, and perform
type inference and transformation at compile time. It includes type classification traits, type property
inspection traits, and type transformations. The type classification traits describe a complete taxonomy
of all possible C++ types, and state where in that taxonomy a given type belongs. The type property
inspection traits allow important characteristics of types or of combinations of types to be inspected. The
type transformations allow certain properties of types to be manipulated.
20.9.1 Requirements [meta.rqmts]
1 A UnaryTypeTrait describes a property of a type. It shall be a class template that takes one template
type argument and, optionally, additional arguments that help define the property being described. It
shall be DefaultConstructible, CopyConstructible, and publicly and unambiguously derived, directly or
indirectly, from its BaseCharacteristic, which is a specialization of the template integral_constant (20.9.3),
with the arguments to the template integral_constant determined by the requirements for the particular
property being described. The member names of the BaseCharacteristic shall not be hidden and shall be
unambiguously available in the UnaryTypeTrait.
2 A BinaryTypeTrait describes a relationship between two types. It shall be a class template that takes two
template type arguments and, optionally, additional arguments that help define the relationship being described. It shall be DefaultConstructible, CopyConstructible, and publicly and unambiguously derived,
directly or indirectly, from its BaseCharacteristic, which is a specialization of the template integral_-
constant (20.9.3), with the arguments to the template integral_constant determined by the requirements
for the particular relationship being described. The member names of the BaseCharacteristic shall not be
hidden and shall be unambiguously available in the BinaryTypeTrait.
§ 20.9.1 576

 c ISO/IEC N3242=11-0012
3 A TransformationTrait modifies a property of a type. It shall be a class template that takes one template
type argument and, optionally, additional arguments that help define the modification. It shall define a
nested type named type, which shall be a synonym for the modified type.
20.9.2 Header <type_traits> synopsis [meta.type.synop]
namespace std {
// 20.9.3, helper class:
template <class T, T v> struct integral_constant;
typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
// 20.9.4.1, primary type categories:
template <class T> struct is_void;
template <class T> struct is_integral;
template <class T> struct is_floating_point;
template <class T> struct is_array;
template <class T> struct is_pointer;
template <class T> struct is_lvalue_reference;
template <class T> struct is_rvalue_reference;
template <class T> struct is_member_object_pointer;
template <class T> struct is_member_function_pointer;
template <class T> struct is_enum;
template <class T> struct is_union;
template <class T> struct is_class;
template <class T> struct is_function;
// 20.9.4.2, composite type categories:
template <class T> struct is_reference;
template <class T> struct is_arithmetic;
template <class T> struct is_fundamental;
template <class T> struct is_object;
template <class T> struct is_scalar;
template <class T> struct is_compound;
template <class T> struct is_member_pointer;
// 20.9.4.3, type properties:
template <class T> struct is_const;
template <class T> struct is_volatile;
template <class T> struct is_trivial;
template <class T> struct is_trivially_copyable;
template <class T> struct is_standard_layout;
template <class T> struct is_pod;
template <class T> struct is_literal_type;
template <class T> struct is_empty;
template <class T> struct is_polymorphic;
template <class T> struct is_abstract;
template <class T> struct is_signed;
template <class T> struct is_unsigned;
template <class T, class... Args> struct is_constructible;
template <class T> struct is_default_constructible;
template <class T> struct is_copy_constructible;
template <class T> struct is_move_constructible;
§ 20.9.2 577

 c ISO/IEC N3242=11-0012
template <class T, class U> struct is_assignable;
template <class T> struct is_copy_assignable;
template <class T> struct is_move_assignable;
template <class T> struct is_destructible;
template <class T, class... Args> struct is_trivially_constructible;
template <class T> struct is_trivially_default_constructible;
template <class T> struct is_trivially_copy_constructible;
template <class T> struct is_trivially_move_constructible;
template <class T, class U> struct is_trivially_assignable;
template <class T> struct is_trivially_copy_assignable;
template <class T> struct is_trivially_move_assignable;
template <class T> struct is_trivially_destructible;
template <class T, class... Args> struct is_nothrow_constructible;
template <class T> struct is_nothrow_default_constructible;
template <class T> struct is_nothrow_copy_constructible;
template <class T> struct is_nothrow_move_constructible;
template <class T, class U> struct is_nothrow_assignable;
template <class T> struct is_nothrow_copy_assignable;
template <class T> struct is_nothrow_move_assignable;
template <class T> struct is_nothrow_destructible;
template <class T> struct has_virtual_destructor;
// 20.9.5, type property queries:
template <class T> struct alignment_of;
template <class T> struct rank;
template <class T, unsigned I = 0> struct extent;
// 20.9.6, type relations:
template <class T, class U> struct is_same;
template <class Base, class Derived> struct is_base_of;
template <class From, class To> struct is_convertible;
// 20.9.7.1, const-volatile modifications:
template <class T> struct remove_const;
template <class T> struct remove_volatile;
template <class T> struct remove_cv;
template <class T> struct add_const;
template <class T> struct add_volatile;
template <class T> struct add_cv;
// 20.9.7.2, reference modifications:
template <class T> struct remove_reference;
template <class T> struct add_lvalue_reference;
template <class T> struct add_rvalue_reference;
// 20.9.7.3, sign modifications:
template <class T> struct make_signed;
template <class T> struct make_unsigned;
§ 20.9.2 578

 c ISO/IEC N3242=11-0012
// 20.9.7.4, array modifications:
template <class T> struct remove_extent;
template <class T> struct remove_all_extents;
// 20.9.7.5, pointer modifications:
template <class T> struct remove_pointer;
template <class T> struct add_pointer;
// 20.9.7.6, other transformations:
template <std::size_t Len, std::size_t Align> struct aligned_storage;
template <std::size_t Len, class... Types> struct aligned_union;
template <class T> struct decay;
template <bool, class T = void> struct enable_if;
template <bool, class T, class F> struct conditional;
template <class... T> struct common_type;
template <class T> struct underlying_type;
template <class> class result_of; // undefined
template <class F, class... ArgTypes> class result_of<F(ArgTypes...)>;
} // namespace std
1 The behavior of a program that adds specializations for any of the class templates defined in this subclause
is undefined unless otherwise specified.
20.9.3 Helper classes [meta.help]
namespace std {
template <class T, T v>
struct integral_constant {
static constexpr T value = v;
typedef T value_type;
typedef integral_constant<T,v> type;
constexpr operator value_type() { return value; }
};
typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
}
1 The class template integral_constant and its associated typedefs true_type and false_type are used as
base classes to define the interface for various type traits.
20.9.4 Unary type traits [meta.unary]
1 This sub-clause contains templates that may be used to query the properties of a type at compile time.
2 Each of these templates shall be a UnaryTypeTrait (20.9.1) with a BaseCharacteristic of true_type if the
corresponding condition is true, otherwise false_type.
20.9.4.1 Primary type categories [meta.unary.cat]
1 The primary type categories correspond to the descriptions given in section 3.9 of the C++ standard.
2 For any given type T, the result of applying one of these templates to T and to cv-qualified T shall yield the
same result.
3 [ Note: For any given type T, exactly one of the primary type categories has a value member that evaluates
to true. — end note ]
§ 20.9.4.1 579

 c ISO/IEC N3242=11-0012
Table 47 — Primary type category predicates
Template Condition Comments
template <class T>
struct is_void;
T is void
template <class T>
struct is_integral;
T is an integral type (3.9.1)
template <class T>
struct is_floating_point;
T is a floating point
type (3.9.1)
template <class T>
struct is_array;
T is an array type (3.9.2) of
known or unknown extent
Class template
array (23.3.2) is not an
array type.
template <class T>
struct is_pointer;
T is a pointer type (3.9.2) Includes pointers to
functions but not pointers
to non-static members.
template <class T>
struct is_lvalue_reference;
T is an lvalue reference
type (8.3.2)
template <class T>
struct is_rvalue_reference;
T is an rvalue reference
type (8.3.2)
template <class T>
struct is_member_object_pointer;
T is a pointer to non-static
data member
template <class T>
struct
is_member_function_pointer;
T is a pointer to non-static
member function
template <class T>
struct is_enum;
T is an enumeration
type (3.9.2)
template <class T>
struct is_union;
T is a union type (3.9.2)
template <class T>
struct is_class;
T is a class type but not a
union type (3.9.2)
template <class T>
struct is_function;
T is a function type (3.9.2)
20.9.4.2 Composite type traits [meta.unary.comp]
1 These templates provide convenient compositions of the primary type categories, corresponding to the descriptions given in section 3.9.
2 For any given type T, the result of applying one of these templates to T, and to cv-qualified T shall yield the
same result.
Table 48 — Composite type category predicates
Template Condition Comments
template <class T>
struct is_reference;
T is an lvalue reference or
an rvalue reference
template <class T>
struct is_arithmetic;
T is an arithmetic
type (3.9.1)
template <class T>
struct is_fundamental;
T is a fundamental
type (3.9.1)
§ 20.9.4.2 580

 c ISO/IEC N3242=11-0012
Table 48 — Composite type category predicates (continued)
Template Condition Comments
template <class T>
struct is_object;
T is an object type (3.9)
template <class T>
struct is_scalar;
T is a scalar type (3.9)
template <class T>
struct is_compound;
T is a compound
type (3.9.2)
template <class T>
struct is_member_pointer;
T is a pointer to non-static
data member or non-static
member function
20.9.4.3 Type properties [meta.unary.prop]
1 These templates provide access to some of the more important properties of types.
2 It is unspecified whether the library defines any full or partial specialisations of any of these templates.
3 For all of the class templates X declared in this Clause, instantiating that template with a template-argument
that is a class template specialization may result in the implicit instantiation of the template argument if
and only if the semantics of X require that the argument must be a complete type.
Table 49 — Type property predicates
Template Condition Preconditions
template <class T>
struct is_const;
T is const-qualified (3.9.3)
template <class T>
struct is_volatile;
T is
volatile-qualified (3.9.3)
template <class T>
struct is_trivial;
T is a trivial type (3.9) T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_trivially_copyable;
T is a trivially copyable
type (3.9)
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_standard_layout;
T is a standard-layout
type (3.9)
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_pod;
T is a POD type (3.9) T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_literal_type;
T is a literal type (3.9) T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
§ 20.9.4.3 581

 c ISO/IEC N3242=11-0012
Table 49 — Type property predicates (continued)
Template Condition Preconditions
template <class T>
struct is_empty;
T is a class type, but not a
union type, with no
non-static data members
other than bit-fields of
length 0, no virtual
member functions, no
virtual base classes, and
no base class B for which
is_empty<B>::value is
false.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_polymorphic;
T is a polymorphic
class (10.3)
T shall be a complete type,
type, (possibly
cv-qualified) void, or an
array of unknown bound.
template <class T>
struct is_abstract;
T is an abstract
class (10.4)
T shall be a complete type,
type, (possibly
cv-qualified) void, or an
array of unknown bound.
template <class T>
struct is_signed;
is_-
arithmetic<T>::value
&& T(-1) < T(0)
template <class T>
struct is_unsigned;
is_-
arithmetic<T>::value
&& T(0) < T(-1)
template <class T, class... Args>
struct is_constructible;
see below T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualified)
void, or arrays of
unknown bound.
template <class T>
struct is_default_constructible;
is_-
constructible<T>::value
is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_copy_constructible;
is_constructible<T,
const T&>::value is
true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_move_constructible;
is_constructible<T,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
§ 20.9.4.3 582

 c ISO/IEC N3242=11-0012
Table 49 — Type property predicates (continued)
Template Condition Preconditions
template <class T, class U>
struct is_assignable;
The expression
declval<T>() =
declval<U>() is
well-formed when treated
as an unevaluated operand
(Clause 5). Access
checking is performed as if
in a context unrelated to T
and U. Only the validity of
the immediate context of
the assignment expression
is considered. [ Note: The
compilation of the
expression can result in
side effects such as the
instantiation of class
template specializations
and function template
specializations, the
generation of
implicitly-defined
functions, and so on. Such
side effects are not in the
“immediate context” and
can result in the program
being ill-formed. — end
note ]
T and U shall be complete
types, (possibly
cv-qualified) void, or
arrays of unknown bound.
template <class T>
struct is_copy_assignable;
is_assignable<T&,
const T&>::value is
true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_move_assignable;
is_assignable<T&,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_destructible;
For a complete type T and
given
template <class U>
struct test { U u; };,
test<T>::~test() is not
deleted.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
§ 20.9.4.3 583

 c ISO/IEC N3242=11-0012
Table 49 — Type property predicates (continued)
Template Condition Preconditions
template <class T, class... Args>
struct
is_trivially_constructible;
is_constructible<T,
Args...>::value is true
and the variable definition
for is_constructible, as
defined below, is known to
call no operation that is
not trivial ( 3.9, 12).
T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualified)
void, or arrays of
unknown bound.
template <class T>
struct
is_trivially_default_constructible;
is_trivially_-
constructible<T>::value
is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct
is_trivially_copy_constructible;
is_trivially_-
constructible<T, const
T&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct
is_trivially_move_constructible;
is_trivially_-
constructible<T,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T, class U>
struct is_trivially_assignable;
is_assignable<T,
U>::value is true and the
assignment, as defined by
is_assignable, is known
to call no operation that is
not trivial (3.9, 12).
T and U shall be complete
types, (possibly
cv-qualified) void, or
arrays of unknown bound.
template <class T>
struct
is_trivially_copy_assignable;
is_trivially_-
assignable<T&, const
T&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct
is_trivially_move_assignable;
is_trivially_-
assignable<T&,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_trivially_destructible;
is_-
destructible<T>::value
is true and the indicated
destructor is known to be
trivial.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T, class... Args>
struct is_nothrow_constructible;
is_constructible<T,
Args...>::value is true
and the variable definition
for is_constructible, as
defined below, is known
not to throw any
exceptions (5.3.7).
T and all types in the
parameter pack Args shall
be complete types,
(possibly cv-qualified)
void, or arrays of
unknown bound.
§ 20.9.4.3 584

 c ISO/IEC N3242=11-0012
Table 49 — Type property predicates (continued)
Template Condition Preconditions
template <class T>
struct
is_nothrow_default_constructible;
is_nothrow_-
constructible<T>::value
is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct
is_nothrow_copy_constructible;
is_nothrow_-
constructible<T, const
T&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct
is_nothrow_move_constructible;
is_nothrow_-
constructible<T,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T, class U>
struct is_nothrow_assignable;
is_assignable<T,
U>::value is true and
the assignment is known
not to throw any
exceptions (5.3.7).
T and U shall be complete
types, (possibly
cv-qualified) void, or
arrays of unknown bound.
template <class T>
struct is_nothrow_copy_assignable;
is_nothrow_-
assignable<T&, const
T&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_nothrow_move_assignable;
is_nothrow_-
assignable<T&,
T&&>::value is true.
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct is_nothrow_destructible;
is_-
destructible<T>::value
is true and the indicated
destructor is known not to
throw any
exceptions (5.3.7).
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
template <class T>
struct has_virtual_destructor;
T has a virtual
destructor (12.4)
T shall be a complete type,
(possibly cv-qualified)
void, or an array of
unknown bound.
4 [ Example:
is_const<const volatile int>::value // true
is_const<const int*>::value // false
is_const<const int&>::value // false
is_const<int[3]>::value // false
is_const<const int[3]>::value // true
— end example ]
5 [ Example:
remove_const<const volatile int>::type // volatile int
§ 20.9.4.3 585

 c ISO/IEC N3242=11-0012
remove_const<const int* const>::type // const int*
remove_const<const int&>::type // const int&
remove_const<const int[3]>::type // int[3]
— end example ]
6 Given the following function prototype:
template <class T>
typename add_rvalue_reference<T>::type create();
the predicate condition for a template specialization is_constructible<T, Args...> shall be satisfied if
and only if the following variable definition would be well-formed for some invented variable t:
T t(create<Args>()...);
[ Note: These tokens are never interpreted as a function declaration. — end note ] Access checking is
performed as if in a context unrelated to T and any of the Args. Only the validity of the immediate context
of the variable initialization is considered. [ Note: The evaluation of the initialization can result in side
effects such as the instantiation of class template specializations and function template specializations, the
generation of implicitly-defined functions, and so on. Such side effects are not in the “immediate context”
and can result in the program being ill-formed. — end note ]
20.9.5 Type property queries [meta.unary.prop.query]
1 This sub-clause contains templates that may be used to query properties of types at compile time.
Table 50 — Type property queries
Template Value
template <class T>
struct alignment_of;
alignof(T).
Requires:alignof(T) shall be a valid expression (5.3.6)
template <class T>
struct rank;
If T names an array type, an integer value representing the number of
dimensions of T; otherwise, 0.
template <class T,
unsigned I = 0>
struct extent;
If T is not an array type, or if it has rank less than or equal to I, or if I
is 0 and T has type “array of unknown bound of U”, then 0; otherwise,
the bound (8.3.4) of the I’th dimension of T, where indexing of I is
zero-based
2 [ Example:
// the following assertions hold:
assert(rank<int>::value == 0);
assert(rank<int[2]>::value == 1);
assert(rank<int[][4]>::value == 2);
— end example ]
3 [ Example:
// the following assertions hold:
assert(extent<int>::value == 0);
assert(extent<int[2]>::value == 2);
assert(extent<int[2][4]>::value == 2);
assert(extent<int[][4]>::value == 0);
§ 20.9.5 586

 c ISO/IEC N3242=11-0012
assert((extent<int, 1>::value) == 0);
assert((extent<int[2], 1>::value) == 0);
assert((extent<int[2][4], 1>::value) == 4);
assert((extent<int[][4], 1>::value) == 4);
— end example ]
20.9.6 Relationships between types [meta.rel]
1 This sub-clause contains templates that may be used to query relationships between types at compile time.
2 Each of these templates shall be a BinaryTypeTrait (20.9.1) with a BaseCharacteristic of true_type if the
corresponding condition is true, otherwise false_type.
Table 51 — Type relationship predicates
Template Condition Comments
template <class T, class U>
struct is_same;
T and U name the same
type with the same
cv-qualifications
template <class Base, class
Derived>
struct is_base_of;
Base is a base class of
Derived (10) without
regard to cv-qualifiers
or Base and Derived
are not unions and
name the same class
type without regard to
cv-qualifiers
If Base and Derived are class
types and are different types
(ignoring possible cv-qualifiers)
then Derived shall be a complete
type. [ Note: Base classes that
are private, protected, or
ambiguous are, nonetheless, base
classes. — end note ]
template <class From, class To>
struct is_convertible;
see below From and To shall be complete
types, arrays of unknown bound,
or (possibly cv-qualified) void
types.
template <class From, class To>
struct is_explicitly_convertible;
is_constructible<
To, From>::value
is_explicitly_convertible is
a synonym for a two-argument
version of is_constructible.
An implementation may define it
as [FI 11] a template aliasan
alias template.
3 [ Example:
struct B {};
struct B1 : B {};
struct B2 : B {};
struct D : private B1, private B2 {};
is_base_of<B, D>::value // true
is_base_of<const B, D>::value // true
is_base_of<B, const D>::value // true
is_base_of<B, const B>::value // true
is_base_of<D, B>::value // false
is_base_of<B&, D&>::value // false
is_base_of<B[3], D[3]>::value // false
§ 20.9.6 587

 c ISO/IEC N3242=11-0012
is_base_of<int, int>::value // false
— end example ]
4 Given the following function prototype:
template <class T>
typename add_rvalue_reference<T>::type create();
the predicate condition for a template specialization is_convertible<From, To> shall be satisfied if and
only if the return expression in the following code would be well-formed, including any implicit conversions
to the return type of the function:
To test() {
return create<From>();
}
[ Note: This requirement gives well defined results for reference types, void types, array types, and function
types. — end note ] Access checking is performed as if in a context unrelated to To and From. Only the validity
of the immediate context of the expression of the return-statement (including conversions to the return type)
is considered. [ Note: The evaluation of the conversion can result in side effects such as the instantiation
of class template specializations and function template specializations, the generation of implicitly-defined
functions, and so on. Such side effects are not in the “immediate context” and can result in the program
being ill-formed. — end note ]
20.9.7 Transformations between types [meta.trans]
1 This sub-clause contains templates that may be used to transform one type to another following some
predefined rule.
2 Each of the templates in this subclause shall be a TransformationTrait (20.9.1).
20.9.7.1 Const-volatile modifications [meta.trans.cv]
Table 52 — Const-volatile modifications
Template Comments
template <class T>
struct remove_const;
The member typedef type shall name the same type as T except that
any top-level const-qualifier has been removed.
[ Example:remove_const<const volatile int>::type evaluates to
volatile int, whereas remove_const<const int*>::type evaluates
to const int*. — end example ]
template <class T>
struct remove_volatile;
The member typedef type shall name the same type as T except that
any top-level volatile-qualifier has been removed.
[ Example:remove_volatile<const volatile int>::type evaluates to
const int, whereas remove_volatile<volatile int*>::type
evaluates to volatile int*. — end example ]
template <class T>
struct remove_cv;
The member typedef type shall be the same as T except that any
top-level cv-qualifier has been removed. [ Example:remove_cv<const
volatile int>::type evaluates to int, whereas remove_cv<const
volatile int*>::type evaluates to const volatile int*. — end
example ]
template <class T>
struct add_const;
If T is a reference, function, or top-level const-qualified type, then type
shall name the same type as T, otherwise T const.
§ 20.9.7.1 588

 c ISO/IEC N3242=11-0012
Table 52 — Const-volatile modifications (continued)
Template Comments
template <class T>
struct add_volatile;
If T is a reference, function, or top-level volatile-qualified type, then
type shall name the same type as T, otherwise T volatile.
template <class T>
struct add_cv;
The member typedef type shall name the same type as
add_const<typename add_volatile<T>::type>::type.
20.9.7.2 Reference modifications [meta.trans.ref]
Table 53 — Reference modifications
Template Comments
template <class T>
struct remove_reference;
If T has type “reference to T1” then the member typedef type shall
name T1; otherwise, type shall name T.
template <class T>
struct
add_lvalue_reference;
If T names an object or function type then the member typedef type
shall name T&; otherwise, if T names a type “rvalue reference to T1” then
the member typedef type shall name T1&; otherwise, type shall name T.
template <class T>
struct
add_rvalue_reference;
If T names an object or function type then the member typedef type
shall name T&&; otherwise, type shall name T. [ Note: This rule reflects
the semantics of reference collapsing (8.3.2). For example, when a type T
names a type T1&, the type add_rvalue_reference<T>::type is not an
rvalue reference. — end note ]
20.9.7.3 Sign modifications [meta.trans.sign]
Table 54 — Sign modifications
Template Comments
template <class T>
struct make_signed;
If T names a (possibly cv-qualified) signed integral integer type (3.9.1)
then the member typedef type shall name the type T; otherwise, if T
names a (possibly cv-qualified) unsigned integral integer type then type
shall name the corresponding signed integral integer type, with the same
cv-qualifiers as T; otherwise, type shall name the signed integral integer
type with smallest rank (4.13) for which sizeof(T) == sizeof(type),
with the same cv-qualifiers as T.
Requires:T shall be a (possibly cv-qualified) integral type or enumeration
but not a bool type.
template <class T>
struct make_unsigned;
If T names a (possibly cv-qualified) unsigned integral integer type (3.9.1)
then the member typedef type shall name the type T; otherwise, if T
names a (possibly cv-qualified) signed integral integer type then type
shall name the corresponding unsigned integral integer type, with the
same cv-qualifiers as T; otherwise, type shall name the unsigned integral
integer type with smallest rank (4.13) for which sizeof(T) ==
sizeof(type), with the same cv-qualifiers as T.
Requires:T shall be a (possibly cv-qualified) integral type or enumeration
but not a bool type.
§ 20.9.7.3 589

 c ISO/IEC N3242=11-0012
20.9.7.4 Array modifications [meta.trans.arr]
Table 55 — Array modifications
Template Comments
template <class T>
struct remove_extent;
If T names a type “array of U”, the member typedef type shall be U,
otherwise T. [ Note: For multidimensional arrays, only the first array
dimension is removed. For a type “array of const U”, the resulting type
is const U. — end note ]
template <class T>
struct remove_all_extents;
If T is “multi-dimensional array of U”, the resulting member typedef
type is U, otherwise T.
1 [Example
// the following assertions hold:
assert((is_same<remove_extent<int>::type, int>::value));
assert((is_same<remove_extent<int[2]>::type, int>::value));
assert((is_same<remove_extent<int[2][3]>::type, int[3]>::value));
assert((is_same<remove_extent<int[][3]>::type, int[3]>::value));
— end example ]
2 [Example
// the following assertions hold:
assert((is_same<remove_all_extents<int>::type, int>::value));
assert((is_same<remove_all_extents<int[2]>::type, int>::value));
assert((is_same<remove_all_extents<int[2][3]>::type, int>::value));
assert((is_same<remove_all_extents<int[][3]>::type, int>::value));
— end example ]
20.9.7.5 Pointer modifications [meta.trans.ptr]
Table 56 — Pointer modifications
Template Comments
template <class T>
struct remove_pointer;
If T has type “(possibly cv-qualified) pointer to T1” then the member
typedef type shall name T1; otherwise, it shall name T.
template <class T>
struct add_pointer;
The member typedef type shall name the same type as
remove_reference<T>::type*.
20.9.7.6 Other transformations [meta.trans.other]
§ 20.9.7.6 590

 c ISO/IEC N3242=11-0012
Table 57 — Other transformations
Template Condition Comments
template <std::size_t Len,
std::size_t Align
= default-alignment>
struct aligned_storage;
Len shall not be zero. Align
shall be equal to
alignof(T) for some type T
or to default-alignment.
The value of default-alignment shall
be the most stringent alignment
requirement for any C++ object type
whose size is no greater than
Len (3.9). The member typedef type
shall be a POD type suitable for use
as uninitialized storage for any object
whose size is at most Len and whose
alignment is a divisor of Align.
template <std:size_t Len,class... Types>struct aligned_union; At least one type is
provided.
The member typedef type shall be a
POD type suitable for use as
uninitialized storage for any object
whose type is listed in Types; its size
shall be at least Len. The static
member alignment_value shall be an
integral constant of type std::size_t
whose value is the strictest alignment
of all types listed in Types.
template <class T> struct
decay;
Let U be
remove_reference<T>::type. If
is_array<U>::value is true, the
member typedef type shall equal
remove_extent<U>::type*. If
is_function<U>::value is true, the
member typedef type shall equal
add_pointer<U>::type. Otherwise
the member typedef type equals
remove_cv<U>::type. [ Note: This
behavior is similar to the
lvalue-to-rvalue (4.1),
array-to-pointer (4.2), and
function-to-pointer (4.3) conversions
applied when an lvalue expression is
used as an rvalue, but also strips
cv-qualifiers from class types in order
to more closely model by-value
argument passing. — end note ]
template <bool B, class T =
void> struct enable_if;
If B is true, the member typedef type
shall equal T; otherwise, there shall be
no member typedef type.
template <bool B, class T,
class F> struct conditional;
If B is true, the member typedef type
shall equal T. If B is false, the
member typedef type shall equal F.
§ 20.9.7.6 591

 c ISO/IEC N3242=11-0012
Table 57 — Other transformations (continued)
Template Condition Comments
template <class... T>
struct common_type;
The member typedef type shall be
defined as set out below. All types in
the parameter pack T shall be
complete or (possibly cv) void. A
program may specialize this trait if at
least one template parameter in the
specialization is a user-defined type.
[ Note: Such specializations are needed
when only explicit conversions are
desired among the template
arguments. — end note ]
template <class T>
struct underlying_type;
T shall be an enumeration
type (7.2)
The member typedef type shall name
the underlying type of T.
template <class Fn,
class... ArgTypes> struct
result_of<Fn(ArgTypes...)>;
Fn shall be a callable
type (20.8.1), reference to
function, or reference to
callable type. The
expression
decltype(INVOKE(declval<Fn>(),
declval<ArgTypes>()...))
shall be well formed.
The member typedef type shall name
the type
decltype(INVOKE(declval<Fn>(),
declval<ArgTypes>()...))
1 [ Note: A typical implementation would define aligned_storage as:
template <std::size_t Len, std::size_t Alignment>
struct aligned_storage {
typedef struct {
alignas(Alignment) unsigned char __data[Len];
} type;
};
— end note ]
2 It is implementation-defined whether any extended alignment is supported (3.11).
3 The nested typedef common_type::type shall be defined as follows:
template <class ...T> struct common_type;
template <class T>
struct common_type<T> {
typedef T type;
};
template <class T, class U>
struct common_type<T, U> {
typedef decltype(true ? declval<T>() : declval<U>()) type;
};
template <class T, class U, class... V>
struct common_type<T, U, V...> {
§ 20.9.7.6 592

 c ISO/IEC N3242=11-0012
typedef typename common_type<typename common_type<T, U>::type, V...>::type type;
};
4 [ Example: Given these definitions:
typedef bool (&PF1)();
typedef short (*PF2)(long);
struct S {
operator PF2() const;
double operator()(char, int&);
void fn(long) const;
char data;
};
typedef void (S::*PMF)(long) const;
typedef char S::*PMD;
the following assertions will hold:
static_assert(is_same<result_of<S(int)>::type, short>::value, "Error!");
static_assert(is_same<result_of<S&(unsigned char, int&)>::type, double>::value, "Error!");
static_assert(is_same<result_of<PF1()>::type, bool>::value, "Error!");
static_assert(is_same<result_of<PMF(unique_ptr<S>, int)>::type, void>::value, "Error!");
static_assert(is_same<result_of<PMD(S)>::type, char&&>::value, "Error!");
static_assert(is_same<result_of<PMD(const S*)>::type, const char&>::value, "Error!");
— end example ]
20.10 Compile-time rational arithmetic [ratio]
20.10.1 In general [ratio.general]
1 This subclause describes the ratio library. It provides a class template ratio which exactly represents any
finite rational number with a numerator and denominator representable by compile-time constants of type
intmax_t.
2 Throughout this subclause, if the template argument types R1 and R2 are not specializations of the ratio
template, the program is ill-formed.
20.10.2 Header <ratio> synopsis [ratio.syn]
namespace std {
// 20.10.3, class template ratio
template <intmax_t N, intmax_t D = 1> class ratio;
// 20.10.4, ratio arithmetic
template <class R1, class R2> using ratio_add = see below;
template <class R1, class R2> using ratio_subtract = see below;
template <class R1, class R2> using ratio_multiply = see below;
template <class R1, class R2> using ratio_divide = see below;
// 20.10.5, ratio comparison
template <class R1, class R2> struct ratio_equal;
template <class R1, class R2> struct ratio_not_equal;
template <class R1, class R2> struct ratio_less;
§ 20.10.2 593

 c ISO/IEC N3242=11-0012
template <class R1, class R2> struct ratio_less_equal;
template <class R1, class R2> struct ratio_greater;
template <class R1, class R2> struct ratio_greater_equal;
// 20.10.6, convenience SI typedefs
typedef ratio<1, 1000000000000000000000000> yocto; // see below
typedef ratio<1, 1000000000000000000000> zepto; // see below
typedef ratio<1, 1000000000000000000> atto;
typedef ratio<1, 1000000000000000> femto;
typedef ratio<1, 1000000000000> pico;
typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio< 10, 1> deca;
typedef ratio< 100, 1> hecto;
typedef ratio< 1000, 1> kilo;
typedef ratio< 1000000, 1> mega;
typedef ratio< 1000000000, 1> giga;
typedef ratio< 1000000000000, 1> tera;
typedef ratio< 1000000000000000, 1> peta;
typedef ratio< 1000000000000000000, 1> exa;
typedef ratio< 1000000000000000000000, 1> zetta; // see below
typedef ratio<1000000000000000000000000, 1> yotta; // see below
}
20.10.3 Class template ratio [ratio.ratio]
namespace std {
template <intmax_t N, intmax_t D = 1>
class ratio {
public:
typedef ratio<num, den> type;
static constexpr intmax_t num;
static constexpr intmax_t den;
};
}
1 If the template argument D is zero or the absolute values of either of the template arguments N and D is not
representable by type intmax_t, the program is ill-formed. [ Note: These rules ensure that infinite ratios
are avoided and that for any negative input, there exists a representable value of its absolute value which is
positive. In a two’s complement representation, this excludes the most negative value. — end note ]
2 The static data members num and den shall have the following values, where gcd represents the greatest
common divisor of the absolute values of N and D:
— num shall have the value sign(N) * sign(D) * abs(N) / gcd.
— den shall have the value abs(D) / gcd.
20.10.4 Arithmetic on ratios [ratio.arithmetic]
1 Each of the [FI 11] template aliasesalias templates ratio_add, ratio_subtract, ratio_multiply, and
ratio_divide denotes the result of an arithmetic computation on two ratios R1 and R2. With X and Y
§ 20.10.4 594

 c ISO/IEC N3242=11-0012
computed (in the absence of arithmetic overflow) as specified by Table 58, each alias denotes a ratio<U,
V> such that U is the same as ratio<X, Y>::num and V is the same as ratio<X, Y>::den.
2 If it is not possible to represent U or V with intmax_t, the program is ill-formed. Otherwise, an implementation should yield correct values of U and V. If it is not possible to represent X or Y with intmax_t, the
program is ill-formed unless the implementation yields correct values of U and V.
Table 58 — Expressions used to perform ratio arithmetic
Type Value of X Value of Y
ratio_add<R1, R2> R1::num * R2::den + R1::den * R2::den
R2::num * R1::den
ratio_subtract<R1, R2> R1::num * R2::den - R1::den * R2::den
R2::num * R1::den
ratio_multiply<R1, R2> R1::num * R2::num R1::den * R2::den
ratio_divide<R1, R2> R1::num * R2::den R1::den * R2::num
3 [ Example:
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::num == 1, "1/3+1/6 == 1/2");
static_assert(ratio_add<ratio<1,3>, ratio<1,6>>::den == 2, "1/3+1/6 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::num == 1, "1/3*3/2 == 1/2");
static_assert(ratio_multiply<ratio<1,3>, ratio<3,2>>::den == 2, "1/3*3/2 == 1/2");
// The following cases may cause the program to be ill-formed under some implementations
static_assert(ratio_add<ratio<1,INTMAX_MAX>, ratio<1,INTMAX_MAX>>::num == 2,
"1/MAX+1/MAX == 2/MAX");
static_assert(ratio_add<ratio<1,INTMAX_MAX>, ratio<1,INTMAX_MAX>>::den == INTMAX_MAX,
"1/MAX+1/MAX == 2/MAX");
static_assert(ratio_multiply<ratio<1,INTMAX_MAX>, ratio<INTMAX_MAX,2>>::num == 1,
"1/MAX * MAX/2 == 1/2");
static_assert(ratio_multiply<ratio<1,INTMAX_MAX>, ratio<INTMAX_MAX,2>>::den == 2,
"1/MAX * MAX/2 == 1/2");
— end example ]
20.10.5 Comparison of ratios [ratio.comparison]
template <class R1, class R2> struct ratio_equal
: integral_constant<bool, see below> { };
1 If R1::num == R2::num and R1::den == R2::den, ratio_equal<R1, R2> shall be derived from
integral_constant<bool, true>; otherwise it shall be derived from integral_constant<bool,
false>.
template <class R1, class R2> struct ratio_not_equal
: integral_constant<bool, !ratio_equal<R1, R2>::value> { };
template <class R1, class R2> struct ratio_less
: integral_constant<bool, see below> { };
2 If R1::num * R2::den < R2::num * R1::den, ratio_less<R1, R2> shall be derived from integral_-
constant<bool, true>; otherwise it shall be derived from integral_constant<bool, false>. Implementations may use other algorithms to compute this relationship to avoid overflow. If overflow
occurs, the program is ill-formed.
§ 20.10.5 595

 c ISO/IEC N3242=11-0012
template <class R1, class R2> struct ratio_less_equal
: integral_constant<bool, !ratio_less<R2, R1>::value> { };
template <class R1, class R2> struct ratio_greater
: integral_constant<bool, ratio_less<R2, R1>::value> { };
template <class R1, class R2> struct ratio_greater_equal
: integral_constant<bool, !ratio_less<R1, R2>::value> { };
20.10.6 SI types for ratio [ratio.si]
1 For each of the typedefs yocto, zepto, zetta, and yotta, if both of the constants used in its specification
are representable by intmax_t, the typedef shall be defined; if either of the constants is not representable
by intmax_t, the typedef shall not be defined.
20.11 Time utilities [time]
20.11.1 In general [time.general]
1 This subclause describes the chrono library (20.11.2) and various C functions (20.11.8) that provide generally
useful time utilities.
20.11.2 Header <chrono> synopsis [time.syn]
namespace std {
namespace chrono {
// 20.11.5, class template duration
template <class Rep, class Period = ratio<1> > class duration;
// 20.11.6, class template time_point
template <class Clock, class Duration = typename Clock::duration> class time_point;
} // namespace chrono
// 20.11.4.3 common_type specializations
template <class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>>;
template <class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>>;
namespace chrono {
// 20.11.4, customization traits
template <class Rep> struct treat_as_floating_point;
template <class Rep> struct duration_values;
// 20.11.5.5, duration arithmetic
template <class Rep1, class Period1, class Rep2, class Period2>
typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
constexpr operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
constexpr operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
§ 20.11.2 596

 c ISO/IEC N3242=11-0012
template <class Rep1, class Period, class Rep2>
duration<typename common_type<Rep1, Rep2>::type, Period>
constexpr operator*(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period, class Rep2>
duration<typename common_type<Rep1, Rep2>::type, Period>
constexpr operator*(const Rep1& s, const duration<Rep2, Period>& d);
template <class Rep1, class Period, class Rep2>
duration<typename common_type<Rep1, Rep2>::type, Period>
constexpr operator/(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
typename common_type<Rep1, Rep2>::type
constexpr operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period, class Rep2>
duration<typename common_type<Rep1, Rep2>::type, Period>
constexpr operator%(const duration<Rep1, Period>& d, const Rep2& s);
template <class Rep1, class Period1, class Rep2, class Period2>
typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
constexpr operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
// 20.11.5.6, duration comparisons
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator< (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator> (const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
// 20.11.5.7, duration_cast
template <class ToDuration, class Rep, class Period>
constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
// convenience typedefs
typedef duration<signed integral integer type of at least 64 bits , nano> nanoseconds;
typedef duration<signed integral integer type of at least 55 bits , micro> microseconds;
typedef duration<signed integral integer type of at least 45 bits , milli> milliseconds;
typedef duration<signed integral integer type of at least 35 bits > seconds;
typedef duration<signed integral integer type of at least 29 bits , ratio< 60>> minutes;
typedef duration<signed integral integer type of at least 23 bits , ratio<3600>> hours;
// 20.11.6.5, time_point arithmetic
template <class Clock, class Duration1, class Rep2, class Period2>
time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
template <class Rep1, class Period1, class Clock, class Duration2>
time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Rep2, class Period2>
time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
§ 20.11.2 597

 c ISO/IEC N3242=11-0012
template <class Clock, class Duration1, class Duration2>
typename common_type<Duration1, Duration2>::type
operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
// 20.11.6.6 time_point comparisons
template <class Clock, class Duration1, class Duration2>
bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
bool operator< (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
bool operator> (const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
template <class Clock, class Duration1, class Duration2>
bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
// 20.11.6.7, time_point_cast
template <class ToDuration, class Clock, class Duration>
time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);
// 20.11.7, clocks
class system_clock;
class steady_clock;
class high_resolution_clock;
} // namespace chrono
} // namespace std
20.11.3 Clock requirements [time.clock.req]
1 A clock is a bundle consisting of a duration, a time_point, and a function now() to get the current time_-
point. The origin of the clock’s time_point is referred to as the clock’s epoch. A clock shall meet the
requirements in Table 59.
2 In Table 59 C1 and C2 denote clock types. t1 and t2 are values returned by C1::now() where the call
returning t1 happens before (1.10) the call returning t2 and both of these calls happen before C1::time_-
point::max().
Table 59 — Clock requirements
Expression Return type Operational semantics
C1::rep An arithmetic type or a class
emulating an arithmetic type
The representation type of
C1::duration.
C1::period a specialization of ratio The tick period of the clock in
seconds.
C1::duration chrono::duration<C1::rep,
C1::period>
The duration type of the
clock.
C1::time_point chrono::time_point<C1> or
chrono::time_point<C2,
C1::duration>
The time_point type of the
clock. C1 and C2 shall refer to
the same epoch.
§ 20.11.3 598

 c ISO/IEC N3242=11-0012
Table 59 — Clock requirements (continued)
Expression Return type Operational semantics
C1::is_steady const bool true if t1 <= t2 is always
true and the time between
clock ticks is constant,
otherwise false.
C1::now() C1::time_point Returns a time_point object
representing the current point
in time.
3 [ Note: The relative difference in durations between those reported by a given clock and the SI definition is
a measure of the quality of implementation. — end note ]
20.11.4 Time-related traits [time.traits]
20.11.4.1 treat_as_floating_point [time.traits.is_fp]
template <class Rep> struct treat_as_floating_point
: is_floating_point<Rep> { };
1 The duration template uses the treat_as_floating_point trait to help determine if a duration object can
be converted to another duration with a different tick period. If treat_as_floating_point<Rep>::value
is true, then implicit conversions are allowed among durations. Otherwise, the implicit convertibility
depends on the tick periods of the durations. [ Note: The intention of this trait is to indicate whether a
given class behaves like a floating-point type, and thus allows division of one value by another with acceptable
loss of precision. If treat_as_floating_point<Rep>::value is false, Rep will be treated as if it behaved
like an integral type for the purpose of these conversions. — end note ]
20.11.4.2 duration_values [time.traits.duration_values]
template <class Rep>
struct duration_values {
public:
static constexpr Rep zero();
static constexpr Rep min();
static constexpr Rep max();
};
1 The duration template uses the duration_values trait to construct special values of the durations representation (Rep). This is done because the representation might be a class type with behavior which requires
some other implementation to return these special values. In that case, the author of that class type should
specialize duration_values to return the indicated values.
static constexpr Rep zero();
2 Returns: Rep(0). [ Note: Rep(0) is specified instead of Rep() because Rep() may have some other
meaning, such as an uninitialized value. — end note ]
3 Remark: The value returned shall be the additive identity.
static constexpr Rep min();
4 Returns: numeric_limits<Rep>::lowest().
§ 20.11.4.2 599

 c ISO/IEC N3242=11-0012
5 Remark: The value returned shall compare less than or equal to zero().
static constexpr Rep max();
6 Returns: numeric_limits<Rep>::max().
7 Remark: The value returned shall compare greater than zero().
20.11.4.3 Specializations of common_type [time.traits.specializations]
template <class Rep1, class Period1, class Rep2, class Period2>
struct common_type<chrono::duration<Rep1, Period1>, chrono::duration<Rep2, Period2>> {
typedef chrono::duration<typename common_type<Rep1, Rep2>::type, see below> type;
};
1 The period of the duration indicated by this specialization of common_type shall be the greatest common divisor of Period1 and Period2. [ Note: This can be computed by forming a ratio of the greatest
common divisor of Period1::num and Period2::num and the least common multiple of Period1::den and
Period2::den. — end note ]
2 [ Note: The typedef name type is a synonym for the duration with the largest tick period possible where
both duration arguments will convert to it without requiring a division operation. The representation of
this type is intended to be able to hold any value resulting from this conversion with no truncation error,
although floating-point durations may have round-off errors. — end note ]
template <class Clock, class Duration1, class Duration2>
struct common_type<chrono::time_point<Clock, Duration1>, chrono::time_point<Clock, Duration2>> {
typedef chrono::time_point<Clock, typename common_type<Duration1, Duration2>::type> type;
};
3 The common type of two time_point types is a time_point with the same clock as the two types and the
common type of their two durations.
20.11.5 Class template duration [time.duration]
1 A duration type measures time between two points in time (time_points). A duration has a representation
which holds a count of ticks and a tick period. The tick period is the amount of time which occurs from one
tick to the next, in units of seconds. It is expressed as a rational constant using the template ratio.
template <class Rep, class Period = ratio<1>>
class duration {
public:
typedef Rep rep;
typedef Period period;
private:
rep rep_; // exposition only
public:
// 20.11.5.1, construct/copy/destroy:
constexpr duration() = default;
template <class Rep2>
constexpr explicit duration(const Rep2& r);
template <class Rep2, class Period2>
constexpr duration(const duration<Rep2, Period2>& d);
~duration() = default;
duration(const duration&) = default;
duration& operator=(const duration&) = default;
§ 20.11.5 600

 c ISO/IEC N3242=11-0012
// 20.11.5.2, observer:
constexpr rep count() const;
// 20.11.5.3, arithmetic:
constexpr duration operator+() const;
constexpr duration operator-() const;
duration& operator++();
duration operator++(int);
duration& operator--();
duration operator--(int);
duration& operator+=(const duration& d);
duration& operator-=(const duration& d);
duration& operator*=(const rep& rhs);
duration& operator/=(const rep& rhs);
duration& operator%=(const rep& rhs);
duration& operator%=(const duration& rhs);
// 20.11.5.4, special values:
static constexpr duration zero();
static constexpr duration min();
static constexpr duration max();
};
2 Requires: Rep shall be an arithmetic type or a class emulating an arithmetic type.
3 Remarks: If duration is instantiated with a duration type for the template argument Rep, the
program is ill-formed.
4 Remarks: If Period is not a specialization of ratio, the program is ill-formed.
5 Remarks: If Period::num is not positive, the program is ill-formed.
6 Requires: Members of duration shall not throw exceptions other than those thrown by the indicated
operations on their representations.
[ Example:
duration<long, ratio<60>> d0; // holds a count of minutes using a long
duration<long long, milli> d1; // holds a count of milliseconds using a long long
duration<double, ratio<1, 30>> d2; // holds a count with a tick period of 30 1 of a second
// (30 Hz) using a double
— end example ]
20.11.5.1 duration constructors [time.duration.cons]
template <class Rep2>
constexpr explicit duration(const Rep2& r);
1 Remarks: This constructor shall not participate in overload resolution unless Rep2 is implicitly convertible to rep and
— treat_as_floating_point<rep>::value is true or
— treat_as_floating_point<Rep2>::value is false.
§ 20.11.5.1 601

 c ISO/IEC N3242=11-0012
[ Example:
duration<int, milli> d(3); // OK
duration<int, milli> d(3.5); // error
— end example ]
2 Effects: Constructs an object of type duration.
3 Postcondition: count() == static_cast<rep>(r).
template <class Rep2, class Period2>
constexpr duration(const duration<Rep2, Period2>& d);
4 Remarks: This constructor shall not participate in overload resolution unless treat_as_floating_-
point<rep>::value is true or both ratio_divide<Period2, period>::den is 1 and treat_as_-
floating_point<Rep2>::value is false. [ Note: This requirement prevents implicit truncation error
when converting between integral-based duration types. Such a construction could easily lead to
confusion about the value of the duration. — end note ] [ Example:
duration<int, milli> ms(3);
duration<int, micro> us = ms; // OK
duration<int, milli> ms2 = us; // error
— end example ]
5 Effects: Constructs an object of type duration, constructing rep_ from duration_cast<duration>(d).count().
20.11.5.2 duration observer [time.duration.observer]
constexpr rep count() const;
1 Returns: rep_.
20.11.5.3 duration arithmetic [time.duration.arithmetic]
constexpr duration operator+() const;
1 Returns: *this.
constexpr duration operator-() const;
2 Returns: duration(-rep_);.
duration& operator++();
3 Effects: ++rep_.
4 Returns: *this.
duration operator++(int);
5 Returns: duration(rep_++);.
duration& operator--();
6 Effects: --rep_.
7 Returns: *this.
§ 20.11.5.3 602

 c ISO/IEC N3242=11-0012
duration operator--(int);
8 Returns: duration(rep_--);.
duration& operator+=(const duration& d);
9 Effects: rep_ += d.count().
10 Returns: *this.
duration& operator-=(const duration& d);
11 Effects: rep_ -= d.count().
12 Returns: *this.
duration& operator*=(const rep& rhs);
13 Effects: rep_ *= rhs.
14 Returns: *this.
duration& operator/=(const rep& rhs);
15 Effects: rep_ /= rhs.
16 Returns: *this.
duration& operator%=(const rep& rhs);
17 Effects: rep_ %= rhs.
18 Returns: *this.
duration& operator%=(const duration& rhs);
19 Effects: rep_ %= rhs.count().
20 Returns: *this.
20.11.5.4 duration special values [time.duration.special]
static constexpr duration zero();
1 Returns: duration(duration_values<rep>::zero()).
static constexpr duration min();
2 Returns: duration(duration_values<rep>::min()).
static constexpr duration max();
3 Returns: duration(duration_values<rep>::max()).
20.11.5.5 duration non-member arithmetic [time.duration.nonmember]
1 In the function descriptions that follow, CD represents the return type of the function. CR(A,B) represents
common_type<A, B>::type.
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>{>}::type
operator+(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
§ 20.11.5.5 603

 c ISO/IEC N3242=11-0012
2 Returns: CD(lhs) += rhs.
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>{>}::type
operator-(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
3 Returns: CD(lhs) -= rhs.
template <class Rep1, class Period, class Rep2>
constexpr duration<typename common_type<Rep1, Rep2>::type, Period>
operator*(const duration<Rep1, Period>& d, const Rep2& s);
4 Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2).
5 Returns: duration<CR(Rep1, Rep2), Period>(d) *= s.
template <class Rep1, class Period, class Rep2>
constexpr duration<typename common_type<Rep1, Rep2>::type, Period>
operator*(const Rep1& s, const duration<Rep2, Period>& d);
6 Remarks: This operator shall not participate in overload resolution unless Rep1 is implicitly convertible
to CR(Rep1, Rep2).
7 Returns: d * s.
template <class Rep1, class Period, class Rep2>
constexpr duration<typename common_type<Rep1, Rep2>::type, Period>
operator/(const duration<Rep1, Period>& d, const Rep2& s);
8 Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2) and Rep2 is not an instantiation of duration.
9 Returns: duration<CR(Rep1, Rep2), Period>(d) /= s.
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr typename common_type<Rep1, Rep2>::type
operator/(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
10 Returns: CD(lhs).count() / CD(rhs).count().
template <class Rep1, class Period, class Rep2>
constexpr duration<typename common_type<Rep1, Rep2>::type, Period>
operator%(const duration<Rep1, Period>& d, const Rep2& s);
11 Remarks: This operator shall not participate in overload resolution unless Rep2 is implicitly convertible
to CR(Rep1, Rep2) and Rep2 is not an instantiation of duration.
12 Returns: duration<CR(Rep1, Rep2), Period>(d) %= s
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr typename common_type<duration<Rep1, Period1>, duration<Rep2, Period2>>::type
operator%(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
13 Returns: common_type<duration<Rep1, Period1>, duration<Rep2, Period2> >::type(lhs) %=
rhs.
§ 20.11.5.5 604

 c ISO/IEC N3242=11-0012
20.11.5.6 duration comparisons [time.duration.comparisons]
1 In the function descriptions that follow, CT represents common_type<A, B>::type, where A and B are the
types of the two arguments to the function.
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator==(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
2 Returns: CT(lhs).count() == CT(rhs).count().
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator!=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
3 Returns: !(lhs == rhs).
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
4 Returns: CT(lhs).count() < CT(rhs).count().
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator<=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
5 Returns: !(rhs < lhs).
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
6 Returns: rhs < lhs.
template <class Rep1, class Period1, class Rep2, class Period2>
constexpr bool operator>=(const duration<Rep1, Period1>& lhs, const duration<Rep2, Period2>& rhs);
7 Returns: !(lhs < rhs).
20.11.5.7 duration_cast [time.duration.cast]
template <class ToDuration, class Rep, class Period>
constexpr ToDuration duration_cast(const duration<Rep, Period>& d);
1 Remarks: This function shall not participate in overload resolution unless ToDuration is an instantiation of duration.
2 Returns: Let CF be ratio_divide<Period, typename ToDuration::period>, and CR be common_-
type< typename ToDuration::rep, Rep, intmax_t>::type.
— If CF::num == 1 and CF::den == 1, returns
ToDuration(static_cast<typename ToDuration::rep>(d.count()))
— otherwise, if CF::num != 1 and CF::den == 1, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) * static_cast<CR>(CF::num)))
— otherwise, if CF::num == 1 and CF::den != 1, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) / static_cast<CR>(CF::den)))
§ 20.11.5.7 605

 c ISO/IEC N3242=11-0012
— otherwise, returns
ToDuration(static_cast<typename ToDuration::rep>(
static_cast<CR>(d.count()) * static_cast<CR>(CF::num) / static_cast<CR>(CF::den)))
Notes: This function does not use any implicit conversions; all conversions are done with static_cast.
It avoids multiplications and divisions when it is known at compile time that one or more arguments
is 1. Intermediate computations are carried out in the widest representation and only converted to the
destination representation at the final step.
20.11.6 Class template time_point [time.point]
template <class Clock, class Duration = typename Clock::duration>
class time_point {
public:
typedef Clock clock;
typedef Duration duration;
typedef typename duration::rep rep;
typedef typename duration::period period;
private:
duration d_; // exposition only
public:
// 20.11.6.1, construct:
time_point(); // has value epoch
explicit time_point(const duration& d); // same as time_point() + d
template <class Duration2>
time_point(const time_point<clock, Duration2>& t);
// 20.11.6.2, observer:
duration time_since_epoch() const;
// 20.11.6.3, arithmetic:
time_point& operator+=(const duration& d);
time_point& operator-=(const duration& d);
// 20.11.6.4, special values:
static constexpr time_point min();
static constexpr time_point max();
};
1 Clock shall meet the Clock requirements (20.11.7).
2 If Duration is not an instance of duration, the program is ill-formed.
20.11.6.1 time_point constructors [time.point.cons]
time_point();
1 Effects: Constructs an object of type time_point, initializing d_ with duration::zero(). Such a
time_point object represents the epoch.
time_point(const duration& d);
2 Effects: Constructs an object of type time_point, initializing d_ with d. Such a time_point object
represents the epoch + d.
§ 20.11.6.1 606

 c ISO/IEC N3242=11-0012
template <class Duration2>
time_point(const time_point<clock, Duration2>& t);
3 Remarks: This constructor shall not participate in overload resolution unless Duration2 is implicitly
convertible to duration.
4 Effects: Constructs an object of type time_point, initializing d_ with t.time_since_epoch().
20.11.6.2 time_point observer [time.point.observer]
duration time_since_epoch() const;
1 Returns: d_.
20.11.6.3 time_point arithmetic [time.point.arithmetic]
time_point& operator+=(const duration& d);
1 Effects: d_ += d.
2 Returns: *this.
time_point& operator-=(const duration& d);
3 Effects: d_ -= d.
4 Returns: *this.
20.11.6.4 time_point special values [time.point.special]
static constexpr time_point min();
1 Returns: time_point(duration::min()).
static constexpr time_point max();
2 Returns: time_point(duration::max()).
20.11.6.5 time_point non-member arithmetic [time.point.nonmember]
template <class Clock, class Duration1, class Rep2, class Period2>
time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
operator+(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
1 Returns: CT(lhs) += rhs, where CT is the type of the return value.
template <class Rep1, class Period1, class Clock, class Duration2>
time_point<Clock, typename common_type<duration<Rep1, Period1>, Duration2>::type>
operator+(const duration<Rep1, Period1>& lhs, const time_point<Clock, Duration2>& rhs);
2 Returns: rhs + lhs.
template <class Clock, class Duration1, class Rep2, class Period2>
time_point<Clock, typename common_type<Duration1, duration<Rep2, Period2>>::type>
operator-(const time_point<Clock, Duration1>& lhs, const duration<Rep2, Period2>& rhs);
3 Returns: lhs + (-rhs).
§ 20.11.6.5 607

 c ISO/IEC N3242=11-0012
template <class Clock, class Duration1, class Duration2>
typename common_type<Duration1, Duration2>::type
operator-(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
4 Returns: lhs.time_since_epoch() - rhs.time_since_epoch().
20.11.6.6 time_point comparisons [time.point.comparisons]
template <class Clock, class Duration1, class Duration2>
bool operator==(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
1 Returns: lhs.time_since_epoch() == rhs.time_since_epoch().
template <class Clock, class Duration1, class Duration2>
bool operator!=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
2 Returns: !(lhs == rhs).
template <class Clock, class Duration1, class Duration2>
bool operator<(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
3 Returns: lhs.time_since_epoch() < rhs.time_since_epoch().
template <class Clock, class Duration1, class Duration2>
bool operator<=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
4 Returns: !(rhs < lhs).
template <class Clock, class Duration1, class Duration2>
bool operator>(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
5 Returns: rhs < lhs.
template <class Clock, class Duration1, class Duration2>
bool operator>=(const time_point<Clock, Duration1>& lhs, const time_point<Clock, Duration2>& rhs);
6 Returns: !(lhs < rhs).
20.11.6.7 time_point_cast [time.point.cast]
template <class ToDuration, class Clock, class Duration>
time_point<Clock, ToDuration> time_point_cast(const time_point<Clock, Duration>& t);
1 Remarks: This function shall not participate in overload resolution unless ToDuration is an instantiation of duration.
2 Returns: time_point<Clock, ToDuration>(duration_cast<ToDuration>(t.time_since_epoch())).
20.11.7 Clocks [time.clock]
1 The types defined in this subclause shall satisfy the Clock requirements (20.11.3).
20.11.7.1 Class system_clock [time.clock.system]
1 Objects of class system_clock represent wall clock time from the system-wide realtime clock.
class system_clock {
public:
typedef see below rep;
§ 20.11.7.1 608

 c ISO/IEC N3242=11-0012
typedef ratio<unspecified , unspecified > period;
typedef chrono::duration<rep, period> duration;
typedef chrono::time_point<system_clock> time_point;
static const bool is_steady = unspecified;
static time_point now();
// Map to C API
static time_t to_time_t (const time_point& t);
static time_point from_time_t(time_t t);
};
typedef unspecified system_clock::rep;
2 Requires: system_clock::duration::min() < system_clock::duration::zero() shall be true.
[ Note: This implies that rep is a signed type. — end note ]
time_t to_time_t(const time_point& t);
3 Returns: A time_t object that represents the same point in time as t when both values are restricted
to the coarser of the precisions of time_t and time_point. It is implementation defined whether
values are rounded or truncated to the required precision.
time_point from_time_t(time_t t);
4 Returns: A time_point object that represents the same point in time as t when both values are
restricted to the coarser of the precisions of time_t and time_point. It is implementation defined
whether values are rounded or truncated to the required precision.
20.11.7.2 Class steady_clock [time.clock.steady]
1 Objects of class steady_clock represent clocks for which values of time_point never decrease as physical
time advances and for which values of time_point advance at a steady rate relative to real time. That is,
the clock may not be adjusted. [Editor’s note: Is “real time” different from “physical time”? If not, pick one
term to use in this paragraph. Also, the formulation in the table “Clock requirements” is that the interval
is “constant”, not that it’s “steady ... relative to real time”. Is the difference in expression intentional? If
so, what does it mean?]
class steady_clock {
public:
typedef unspecified rep;
typedef ratio<unspecified , unspecified > period;
typedef chrono::duration<rep, period> duration;
typedef chrono::time_point<unspecified, duration> time_point;
static const bool is_steady = true;
static time_point now();
};
20.11.7.3 Class high_resolution_clock [time.clock.hires]
1 Objects of class high_resolution_clock represent clocks with the shortest tick period. high_resolution_-
clock may be a synonym for system_clock or steady_clock.
class high_resolution_clock {
public:
§ 20.11.7.3 609

 c ISO/IEC N3242=11-0012
typedef unspecified rep;
typedef ratio<unspecified , unspecified > period;
typedef chrono::duration<rep, period> duration;
typedef chrono::time_point<unspecified , duration> time_point;
static const bool is_steady = unspecified ;
static time_point now();
};
20.11.8 Date and time functions [date.time]
1 Table 60 describes the header <ctime>.
Table 60 — Header <ctime> synopsis
Type Name(s)
Macros: NULL CLOCKS_PER_SEC
Types: size_t clock_t time_t
Struct: tm
Functions:
asctime clock difftime localtime strftime
ctime gmtime mktime time
2 The contents are the same as the Standard C library header <time.h>.229 The functions asctime, ctime,
gmtime, and localtime are not required to avoid data races (17.6.5.9).
See also: ISO C Clause 7.12, Amendment 1 Clause 4.6.4.
20.12 Class template scoped_allocator_adaptor [allocator.adaptor]
20.12.1 Header <scoped_allocator> synopsis [allocator.adaptor.syn]
// scoped allocator adaptor
template <class OuterAlloc, class... InnerAlloc>
class scoped_allocator_adaptor;
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
1 The class template scoped_allocator_adaptor is an allocator template that specifies the memory resource
(the outer allocator) to be used by a container (as any other allocator does) and also specifies an inner
allocator resource to be passed to the constructor of every element within the container. This adaptor is
instantiated with one outer and zero or more inner allocator types. If instantiated with only one allocator type, the inner allocator becomes the scoped_allocator_adaptor itself, thus using the same allocator
resource for the container and every element within the container and, if the elements themselves are containers, each of their elements recursively. If instantiated with more than one allocator, the first allocator
is the outer allocator for use by the container, the second allocator is passed to the constructors of the
container’s elements, and, if the elements themselves are containers, the third allocator is passed to the
229) strftime supports the C conversion specifiers C, D, e, F, g, G, h, r, R, t, T, u, V, and z, and the modifiers E and O.
§ 20.12.1 610

 c ISO/IEC N3242=11-0012
elements’ elements, and so on. If containers are nested to a depth greater than the number of allocators, the
last allocator is used repeatedly, as in the single-allocator case, for any remaining recursions. [ Note: The
scoped_allocator_adaptor is derived from the outer allocator type so it can be substituted for the outer
allocator type in most expressions. — end note ]
namespace std {
template <class OuterAlloc, class... InnerAllocs>
class scoped_allocator_adaptor : public OuterAlloc {
private:
typedef allocator_traits<OuterAlloc> OuterTraits; // exposition only
scoped_allocator_adaptor<InnerAllocs...> inner; // exposition only
public:
typedef OuterAlloc outer_allocator_type;
typedef see below inner_allocator_type;
typedef typename OuterTraits::value_type value_type;
typedef typename OuterTraits::size_type size_type;
typedef typename OuterTraits::difference_type difference_type;
typedef typename OuterTraits::pointer pointer;
typedef typename OuterTraits::const_pointer const_pointer;
typedef typename OuterTraits::void_pointer void_pointer;
typedef typename OuterTraits::const_void_pointer const_void_pointer;
typedef see below propagate_on_container_copy_assignment;
typedef see below propagate_on_container_move_assignment;
typedef see below propagate_on_container_swap;
template <class Tp>
struct rebind {
typedef scoped_allocator_adaptor<
OuterTraits::template rebind_alloc<Tp>, InnerAllocs...> other;
};
scoped_allocator_adaptor();
template <class OuterA2>
scoped_allocator_adaptor(OuterA2&& outerAlloc,
const InnerAllocs&... innerAllocs) noexcept;
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
template <class OuterA2>
scoped_allocator_adaptor(
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& other) noexcept;
template <class OuterA2>
scoped_allocator_adaptor(
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>&& other) noexcept;
~scoped_allocator_adaptor();
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
outer_allocator_type& outer_allocator() noexcept;
const outer_allocator_type& outer_allocator() const noexcept;
pointer allocate(size_type n);
§ 20.12.1 611

 c ISO/IEC N3242=11-0012
pointer allocate(size_type n, const_void_pointer hint);
void deallocate(pointer p, size_type n) noexcept;
size_type max_size() const;
template <class T, class... Args>
void construct(T* p, Args&& args);
template <class T1, class T2, class... Args1, class... Args2>
void construct(pair<T1, T2>* p, piecewise_construct_t,
tuple<Args1...> x, tuple<Args2...> y);
template <class T1, class T2>
void construct(pair<T1, T2>* p);
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, U&& x, V&& y);
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, const pair<U, V>& x);
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, pair<U, V>&& x);
template <class T>
void destroy(T* p);
scoped_allocator_adaptor select_on_container_copy_construction() const;
};
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
}
20.12.2 Scoped allocator adaptor member types [allocator.adaptor.types]
typedef see below inner_allocator_type;
1 Type: scoped_allocator_adaptor<OuterAlloc> if sizeof...(InnerAllocs) is zero; otherwise,
scoped_allocator_adaptor<InnerAllocs...>.
typedef see below propagate_on_container_copy_assignment;
2 Type: true_type if allocator_traits<A>::propagate_on_container_copy_assignment::value is
true for any A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.
typedef see below propagate_on_container_move_assignment;
3 Type: true_type if allocator_traits<A>::propagate_on_container_move_assignment::value is
true for any A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.
typedef see below propagate_on_container_swap;
4 Type: true_type if allocator_traits<A>::propagate_on_container_swap::value is true for any
A in the set of OuterAlloc and InnerAllocs...; otherwise, false_type.
20.12.3 Scoped allocator adaptor constructors [allocator.adaptor.cnstr]
§ 20.12.3 612

 c ISO/IEC N3242=11-0012
scoped_allocator_adaptor();
1 Effects: value-initializes the OuterAlloc base class and the inner allocator object.
template <class OuterA2>
scoped_allocator_adaptor(OuterA2&& outerAlloc,
const InnerAllocs&... innerAllocs) noexcept;
2 Requires: OuterAlloc shall be constructible from OuterA2.
3 Effects: initializes the OuterAlloc base class with std::forward<OuterA2>(outerAlloc) and inner
with innerAllocs... (hence recursively initializing each allocator within the adaptor with the corresponding allocator from the argument list).
scoped_allocator_adaptor(const scoped_allocator_adaptor& other) noexcept;
4 Effects: intializes each allocator within the adaptor with the corresponding allocator from other.
template <class OuterA2>
scoped_allocator_adaptor(const scoped_allocator_adaptor<OuterA2,
InnerAllocs...>& other) noexcept;
5 Requires: OuterAlloc shall be constructible from OuterA2.
6 Effects: intializes each allocator within the adaptor with the corresponding allocator from other.
template <class OuterA2>
scoped_allocator_adaptor(const scoped_allocator_adaptor<OuterA2,
InnerAllocs...>&& other) noexcept;
7 Requires: OuterAlloc shall be constructible from OuterA2.
8 Effects: intializes each allocator within the adaptor with the corresponding allocator rvalue from other.
20.12.4 Scoped allocator adaptor members [allocator.adaptor.members]
1 In the construct member functions, OUTERMOST(x) is x if x does not have an outer_allocator() member function and
OUTERMOST(x.outer_allocator()) otherwise; OUTERMOST_ALLOC_TRAITS(x) is
allocator_traits<decltype(OUTERMOST (x))>. [ Note: OUTERMOST (x) and
OUTERMOST_ALLOC_TRAITS(x) are recursive operations. It is incumbent upon the definition of
outer_allocator() to ensure that the recursion terminates. It will terminate for all instantiations of
scoped_allocator_adaptor. — end note ]
inner_allocator_type& inner_allocator() noexcept;
const inner_allocator_type& inner_allocator() const noexcept;
2 Returns: *this if sizeof...(InnerAllocs) is zero; otherwise, inner.
outer_allocator_type& outer_allocator() noexcept;
3 Returns: static_cast<Outer&>(*this).
const outer_allocator_type& outer_allocator() const noexcept;
4 Returns: static_cast<const Outer&>(*this).
pointer allocate(size_type n);
5 Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n).
§ 20.12.4 613

 c ISO/IEC N3242=11-0012
pointer allocate(size_type n, const_void_pointer hint);
6 Returns: allocator_traits<OuterAlloc>::allocate(outer_allocator(), n, hint).
void deallocate(pointer p, size_type n) noexcept;
7 Effects: allocator_traits<OuterAlloc>::deallocate(outer_allocator(), p, n);
size_type max_size() const;
8 Returns: allocator_traits<OuterAlloc>::max_size(outer_allocator()).
template <class T, class... Args>
void construct(T* p, Args&&... args);
9 Effects:
— If uses_allocator<T, inner_allocator_type>::value is false and is_constructible<T,
Args...>::value is true, calls OUTERMOST_ALLOC_TRAITS(*this):: construct(OUTERMOST (*this),
p, std::forward<Args>(args)...).
— Otherwise, if uses_allocator<T, inner_allocator_type>::value is true and is_constructible<T,
allocator_arg_t, inner_allocator_type, Args...>::value is true, calls OUTERMOST_-
ALLOC_TRAITS(*this):: construct(OUTERMOST (*this), p, allocator_arg, inner_allocator(),
std::forward<Args>(args)...).
— Otherwise, if uses_allocator<T, inner_allocator_type>::value is true and is_constructible<T,
Args..., inner_allocator_type>::value is true, calls OUTERMOST_ALLOC_TRAITS(*this)::
construct(OUTERMOST (*this), p, std::forward<Args>(args)..., inner_allocator()).
— Otherwise, the program is ill-formed. [ Note: An error will result if uses_allocator evaluates
to true but the specific constructor does not take an allocator. This definition prevents a silent
failure to pass an inner allocator to a contained element. — end note ]
template <class T1, class T2, class... Args1, class... Args2>
void construct(pair<T1, T2>* p,piecewise_construct_t,
tuple<Args1...> x, tuple<Args2...> y);
10 Requires: all of the types in Args1 and Args2 shall be CopyConstructible (Table 21).
11 Effects: Constructs a tuple object xprime from x by the following rules:
— If uses_allocator<T1, inner_allocator_type>::value is false and is_constructible<T1,
Args1...>::value is true, then xprime is x.
— Otherwise, if uses_allocator<T1, inner_allocator_type>::value is true and is_constructible<T1,
allocator_arg_t, inner_allocator_type, Args1...>::value is true, then xprime is tuple_-
cat(tuple<allocator_arg_t, inner_allocator_type&>( allocator_arg, inner_allocator_-
type()), x).
— Otherwise, if uses_allocator<T1, inner_allocator_type>::value is true and is_constructible<T1,
Args1..., inner_allocator_type>::value is true, then xprime is tuple_cat(x, tuple<inner_-
allocator_type&>(inner_allocator_type())).
— Otherwise, the program is ill-formed.
and constructs a tuple object yprime from y by the following rules:
— If uses_allocator<T2, inner_allocator_type>::value is false and is_constructible<T2,
Args2...>::value is true, then yprime is y.
§ 20.12.4 614

 c ISO/IEC N3242=11-0012
— Otherwise, if uses_allocator<T2, inner_allocator_type>::value is true and is_constructible<T2,
allocator_arg_t, inner_allocator_type, Args2...>::value is true, then yprime is tuple_-
cat(tuple<allocator_arg_t, inner_allocator_type&>( allocator_arg, inner_allocator_-
type()), y).
— Otherwise, if uses_allocator<T2, inner_allocator_type>::value is true and is_constructible<T2,
Args2..., inner_allocator_type>::value is true, then yprime is tuple_cat(y, tuple<inner_-
allocator_type&>(inner_allocator_type())).
— Otherwise, the program is ill-formed.
then calls OUTERMOST_ALLOC_TRAITS(*this)::construct(OUTERMOST (*this), p, piecewise_construct,
xprime, yprime).
template <class T1, class T2>
void construct(pair<T1, T2>* p);
12 Effects: equivalent to this->construct(p, piecewise_construct, tuple<>(), tuple<>()).
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, U&& x, V&& y);
13 Effects: equivalent to this->construct(p, piecewise_construct, forward_as_tuple(std::forward<U>(x)),
forward_as_tuple(std::forward<V>(y))).
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, const pair<U, V>& x);
14 Effects: equivalent to this->construct(p, piecewise_construct, forward_as_tuple(x.first),
forward_as_tuple(x.second)).
template <class T1, class T2, class U, class V>
void construct(pair<T1, T2>* p, pair<U, V>&& x);
15 Effects: equivalent to this->construct(p, piecewise_construct, forward_as_tuple(std::forward<U>(x.first)),
forward_as_tuple(std::forward<V>(x.second))).
template <class T>
void destroy(T* p);
16 Effects: calls OUTERMOST_ALLOC_TRAITS(*this)::destroy(OUTERMOST (*this), p).
scoped_allocator_adaptor select_on_container_copy_construction() const;
17 Returns: A new scoped_allocator_adaptor object where each allocator A in the adaptor is initialized
from the result of calling allocator_traits<A>::select_on_container_copy_construction() on
the corresponding allocator in *this.
20.12.5 Scoped allocator operators [scoped.adaptor.operators]
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator==(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
1 Returns: a.outer_allocator() == b.outer_allocator() if sizeof...(InnerAllocs) is zero; otherwise, a.outer_allocator() == b.outer_allocator() && a.inner_allocator() == b.inner_-
allocator().
§ 20.12.5 615

 c ISO/IEC N3242=11-0012
template <class OuterA1, class OuterA2, class... InnerAllocs>
bool operator!=(const scoped_allocator_adaptor<OuterA1, InnerAllocs...>& a,
const scoped_allocator_adaptor<OuterA2, InnerAllocs...>& b) noexcept;
2 Returns: !(a == b).
20.13 Class type_index [type.index]
20.13.1 Header <typeindex> synopsis [type.index.synopsis]
namespace std {
class type_index;
template <class T> struct hash;
template<> struct hash<type_index>;
}
20.13.2 type_index overview [type.index.overview]
namespace std {
class type_index {
public:
type_index(const type_info& rhs) noexcept;
bool operator==(const type_index& rhs) const noexcept;
bool operator!=(const type_index& rhs) const noexcept;
bool operator< (const type_index& rhs) const noexcept;
bool operator<= (const type_index& rhs) const noexcept;
bool operator> (const type_index& rhs) const noexcept;
bool operator>= (const type_index& rhs) const noexcept;
size_t hash_code() const;
const char* name() const;
private:
const type_info* target; // exposition only
// Note that the use of a pointer here, rather than a reference,
// means that the default copy/move constructor and assignment
// operators will be provided and work as expected.
};
}
1 The class type_index provides a simple wrapper for type_info which can be used as an index type in
associative containers (23.4) and in unordered associative containers (23.5).
20.13.3 type_index members [type.index.members]
type_index(const type_info& rhs) noexcept;
1 Effects: constructs a type_index object, the equivalent of target = &rhs.
bool operator==(const type_index& rhs) const noexcept;
2 Returns: *target == *rhs.target
bool operator!=(const type_index& rhs) const noexcept;
3 Returns: *target != *rhs.target
bool operator<(const type_index& rhs) const noexcept;
§ 20.13.3 616

 c ISO/IEC N3242=11-0012
4 Returns: target->before(*rhs.target)
bool operator<=(const type_index& rhs) const noexcept;
5 Returns: !rhs.target->before(*target)
bool operator>(const type_index& rhs) const noexcept;
6 Returns: rhs.target->before(*target)
bool operator>=(const type_index& rhs) const noexcept;
7 Returns: !target->before(*rhs.target)
size_t hash_code() const;
8 Returns: target->hash_code()
const char* name() const;
9 Returns: target->name()
20.13.4 Hash support [type.index.hash]
template <> struct hash<type_index>;
1 Requires: the template specialization shall meet the requirements of class template hash (20.8.12). For
an object index of type type_index, hash<type_index>()(index) shall evaluate to the same result
as index.hash_code().
§ 20.13.4 617

 c ISO/IEC N3242=11-0012
21 Strings library [strings]
21.1 General [strings.general]
1 This Clause describes components for manipulating sequences of any non-array POD (3.9) type. In this
Clause such types are called char-like types , and objects of char-like types are called char-like objects or
simply characters.
2 The following subclauses describe a character traits class, a string class, and null-terminated sequence
utilities, as summarized in Table 61.
Table 61 — Strings library summary
Subclause Header(s)
21.2 Character traits <string>
21.3 String classes <string>
<cctype>
<cwctype>
21.7 Null-terminated sequence utilities <cstring>
<cwchar>
<cstdlib>
<cuchar>
21.2 Character traits [char.traits]
1 This subclause defines requirements on classes representing character traits, and defines a class template
char_traits<charT>, along with four specializations, char_traits<char>, char_traits<char16_t>, char_-
traits <char32_t>, and char_traits<wchar_t>, that satisfy those requirements.
2 Most classes specified in Clauses 21.3 and 27 need a set of related types and functions to complete the
definition of their semantics. These types and functions are provided as a set of member typedefs and
functions in the template parameter ‘traits’ used by each such template. This subclause defines the semantics
guaranteed by these members.
3 To specialize those templates to generate a string or iostream class to handle a particular character container
type CharT, that and its related character traits class Traits are passed as a pair of parameters to the string
or iostream template as formal parameters charT and traits. Traits::char_type shall be the same as
CharT.
4 This subclause specifies a struct template, char_traits<charT>, and four explicit specializations of it,
char_traits<char>, char_traits<char16_t>, char_traits<char32_t>, and char_traits<wchar_t>, all
of which appear in the header <string> and satisfy the requirements below.
21.2.1 Character traits requirements [char.traits.require]
1 In Table 62, X denotes a Traits class defining types and functions for the character container type CharT;
c and d denote values of type CharT; p and q denote values of type const CharT*; s denotes a value of
type CharT*; n, i and j denote values of type std::size_t; e and f denote values of type X::int_type;
§ 21.2.1 618

 c ISO/IEC N3242=11-0012
pos denotes a value of type X::pos_type; state denotes a value of type X::state_type; and r denotes an
lvalue of type CharT. Operations on Traits shall not throw exceptions.
Table 62 — Character traits requirements
Expression Return type Assertion/note Complexity
pre-/post-condition
X::char_type charT (described in 21.2.2) compile-time
X::int_type (described in 21.2.2) compile-time
X::off_type (described in 21.2.2) compile-time
X::pos_type (described in 21.2.2) compile-time
X::state_type (described in 21.2.2) compile-time
X::eq(c,d) bool yields: whether c is to be
treated as equal to d.
constant
X::lt(c,d) bool yields: whether c is to be
treated as less than d.
constant
X::compare(p,q,n) int yields: 0 if for each i in [0,n),
X::eq(p[i],q[i]) is true; else,
a negative value if, for some j
in [0,n), X::lt(p[j],q[j]) is
true and for each i in [0,j)
X::eq(p[i],q[i]) is true; else
a positive value.
linear
X::length(p) std::size_t yields: the smallest i such that
X::eq(p[i],charT()) is true.
linear
X::find(p,n,c) const X::char_type* yields: the smallest q in
[p,p+n) such that
X::eq(*q,c) is true, zero
otherwise.
linear
X::move(s,p,n) X::char_type* for each i in [0,n), performs
X::assign(s[i],p[i]).
Copies correctly even where the
ranges [p,p+n) and [s,s+n)
overlap. yields: s.
linear
X::copy(s,p,n) X::char_type* pre: p not in [s,s+n). yields:
s. for each i in [0,n), performs
X::assign(s[i],p[i]).
linear
X::assign(r,d) (not used) assigns r=d. constant
X::assign(s,n,c) X::char_type* for each i in [0,n), performs
X::assign(s[i],c). yields: s.
linear
X::not_eof(e) int_type yields: e if
X::eq_int_type(e,X::eof())
is false, otherwise a value f
such that
X::eq_int_type(f,X::eof())
is false.
constant
X::to_char_type(e) X::char_type yields: if for some c,
X::eq_int_type(e,X::to_-
int_type(c)) is true, c; else
some unspecified value.
constant
§ 21.2.1 619

 c ISO/IEC N3242=11-0012
Table 62 — Character traits requirements (continued)
Expression Return type Assertion/note Complexity
pre-/post-condition
X::to_int_type(c) X::int_type yields: some value e,
constrained by the definitions of
to_char_type and
eq_int_type.
constant
X::eq_int_type(e,f) bool yields: for all c and d,
X::eq(c,d) is equal to
X::eq_int_type(X::to_int_-
type(c),
X::to_int_type(d));
otherwise, yields true if e and f
are both copies of X::eof();
otherwise, yields false if one of
e and f is a copy of X::eof()
and the other is not; otherwise
the value is unspecified.
constant
X::eof() X::int_type yields: a value e such that
X::eq_int_type(e,X::to_-
int_type(c)) is false for all
values c.
constant
2 The struct template
template<class charT> struct char_traits;
shall be provided in the header <string> as a basis for explicit specializations.
21.2.2 traits typedefs [char.traits.typedefs]
typedef CHAR_T char_type;
1 The type char_type is used to refer to the character container type in the implementation of the
library classes defined in 21.3 and Clause 27.
typedef INT_T int_type;
2 Requires: For a certain character container type char_type, a related container type INT_T shall be a
type or class which can represent all of the valid characters converted from the corresponding char_-
type values, as well as an end-of-file value, eof(). The type int_type represents a character container
type which can hold end-of-file to be used as a return type of the iostream class member functions.230
typedef implementation-defined off_type;
typedef implementation-defined pos_type;
3 Requires: Requirements for off_type and pos_type are described in 27.2.2.
typedef STATE_T state_type;
4 Requires: state_type shall meet the requirements of CopyAssignable (Table 23), CopyConstructible
(Table 21), and DefaultConstructible (Table 19) types.
230) If eof() can be held in char_type then some iostreams operations may give surprising results.
§ 21.2.2 620

 c ISO/IEC N3242=11-0012
21.2.3 char_traits specializations [char.traits.specializations]
namespace std {
template<> struct char_traits<char>;
template<> struct char_traits<char16_t>;
template<> struct char_traits<char32_t>;
template<> struct char_traits<wchar_t>;
}
1 The header <string> shall define four specializations of the template struct char_traits: char_traits<char>,
char_traits<char16_t>, char_traits<char32_t>, and char_traits<wchar_t>.
2 The requirements for the members of these specializations are given in Clause 21.2.1.
21.2.3.1 struct char_traits<char> [char.traits.specializations.char]
namespace std {
template<> struct char_traits<char> {
typedef char char_type;
typedef int int_type;
typedef streamoff off_type;
typedef streampos pos_type;
typedef mbstate_t state_type;
static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static int compare(const char_type* s1, const char_type* s2, size_t n) noexcept;
static size_t length(const char_type* s) noexcept;
static const char_type* find(const char_type* s, size_t n,
const char_type& a) noexcept;
static char_type* move(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* copy(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* assign(char_type* s, size_t n, char_type a) noexcept;
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The defined types for int_type, pos_type, off_type, and state_type shall be int, streampos, streamoff,
and mbstate_t respectively.
2 The type streampos shall be an implementation-defined type that satisfies the requirements for pos_type
in 21.2.2.
3 The type streamoff shall be an implementation-defined type that satisfies the requirements for off_type
in 21.2.2.
4 The type mbstate_t is defined in <cwchar> and can represent any of the conversion states that can occur
in an implementation-defined set of supported multibyte character encoding rules.
§ 21.2.3.1 621

 c ISO/IEC N3242=11-0012
5 The two-argument member assign shall be defined identically to the built-in operator =. The two-argument
members eq and lt shall be defined identically to the built-in operators == and < for type unsigned char.
6 The member eof() shall return EOF.
21.2.3.2 struct char_traits<char16_t> [char.traits.specializations.char16_t]
namespace std {
template<> struct char_traits<char16_t> {
typedef char16_t char_type;
typedef uint_least16_t int_type;
typedef streamoff off_type;
typedef u16streampos pos_type;
typedef mbstate_t state_type;
static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static int compare(const char_type* s1, const char_type* s2, size_t n) noexcept;
static size_t length(const char_type* s) noexcept;
static const char_type* find(const char_type* s, size_t n,
const char_type& a) noexcept;
static char_type* move(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* copy(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* assign(char_type* s, size_t n, char_type a) noexcept;
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The type u16streampos shall be an implementation-defined type that satisfies the requirements for pos_type
in 27.2.2.
2 The two-argument members assign, eq, and lt shall be defined identically to the built-in operators =, ==,
and < respectively.
3 The member eof() shall return an implementation-defined constant that cannot appear as a valid UTF-16
code unit.
21.2.3.3 struct char_traits<char32_t> [char.traits.specializations.char32_t]
namespace std {
template<> struct char_traits<char32_t> {
typedef char32_t char_type;
typedef uint_least32_t int_type;
typedef streamoff off_type;
typedef u32streampos pos_type;
typedef mbstate_t state_type;
static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
§ 21.2.3.3 622

 c ISO/IEC N3242=11-0012
static int compare(const char_type* s1, const char_type* s2, size_t n) noexcept;
static size_t length(const char_type* s) noexcept;
static const char_type* find(const char_type* s, size_t n,
const char_type& a) noexcept;
static char_type* move(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* copy(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* assign(char_type* s, size_t n, char_type a) noexcept;
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
1 The type u32streampos shall be an implementation-defined type that satisfies the requirements for pos_type
in 27.2.2.
2 The two-argument members assign, eq, and lt shall be defined identically to the built-in operators =, ==,
and < respectively.
3 The member eof() shall return an implementation-defined constant that cannot appear as a Unicode code
point.
21.2.3.4 struct char_traits<wchar_t> [char.traits.specializations.wchar.t]
namespace std {
template<> struct char_traits<wchar_t> {
typedef wchar_t char_type;
typedef wint_t int_type;
typedef streamoff off_type;
typedef wstreampos pos_type;
typedef mbstate_t state_type;
static void assign(char_type& c1, const char_type& c2) noexcept;
static constexpr bool eq(char_type c1, char_type c2) noexcept;
static constexpr bool lt(char_type c1, char_type c2) noexcept;
static int compare(const char_type* s1, const char_type* s2, size_t n) noexcept;
static size_t length(const char_type* s) noexcept;
static const char_type* find(const char_type* s, size_t n,
const char_type& a) noexcept;
static char_type* move(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* copy(char_type* s1, const char_type* s2, size_t n) noexcept;
static char_type* assign(char_type* s, size_t n, char_type a) noexcept;
static constexpr int_type not_eof(int_type c) noexcept;
static constexpr char_type to_char_type(int_type c) noexcept;
static constexpr int_type to_int_type(char_type c) noexcept;
static constexpr bool eq_int_type(int_type c1, int_type c2) noexcept;
static constexpr int_type eof() noexcept;
};
}
§ 21.2.3.4 623

 c ISO/IEC N3242=11-0012
1 The defined types for int_type, pos_type, and state_type shall be wint_t, wstreampos, and mbstate_t
respectively.
2 The type wstreampos shall be an implementation-defined type that satisfies the requirements for pos_type
in 27.2.2.
3 The type mbstate_t is defined in <cwchar> and can represent any of the conversion states that can occur
in an implementation-defined set of supported multibyte character encoding rules.
4 The two-argument members assign, eq, and lt shall be defined identically to the built-in operators =, ==,
and < respectively.
5 The member eof() shall return WEOF.
21.3 String classes [string.classes]
1 The header <string> defines the basic_string class template for manipulating varying-length sequences of
char-like objects and four typedefs, string, u16string, u32string, and wstring, that name the specializations basic_string<char>, basic_string<char16_t>, basic_string<char32_t>, and basic_string<wchar_-
t>, respectively.
Header <string> synopsis
#include <initializer_list>
namespace std {
// 21.2, character traits:
template<class charT> struct char_traits;
template <> struct char_traits<char>;
template <> struct char_traits<char16_t>;
template <> struct char_traits<char32_t>;
template <> struct char_traits<wchar_t>;
// 21.4, basic_string:
template<class charT, class traits = char_traits<charT>,
class Allocator = allocator<charT> >
class basic_string;
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
const basic_string<charT,traits,Allocator>& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>&& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
basic_string<charT,traits,Allocator>&& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
§ 21.3 624

 c ISO/IEC N3242=11-0012
operator+(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const charT* lhs,
basic_string<charT,traits,Allocator>&& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(charT lhs, basic_string<charT,traits,Allocator>&& rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
const charT* rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs, charT rhs);
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs, charT rhs);
template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
§ 21.3 625

 c ISO/IEC N3242=11-0012
template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
// 21.4.8.8, swap:
template<class charT, class traits, class Allocator>
void swap(basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>& rhs) noexcept;
// 21.4.8.9, inserters and extractors:
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
operator>>(basic_istream<charT,traits>&& is,
basic_string<charT,traits,Allocator>& str);
template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>&& os,
const basic_string<charT,traits,Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is,
basic_string<charT,traits,Allocator>& str,
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>&& is,
basic_string<charT,traits,Allocator>& str,
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
§ 21.3 626

 c ISO/IEC N3242=11-0012
getline(basic_istream<charT,traits>& is,
basic_string<charT,traits,Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>&& is,
basic_string<charT,traits,Allocator>& str);
// basic_string typedef names
typedef basic_string<char> string;
typedef basic_string<char16_t> u16string;
typedef basic_string<char32_t> u32string;
typedef basic_string<wchar_t> wstring;
// 21.5, numeric conversions:
int stoi(const string& str, size_t *idx = 0, int base = 10);
long stol(const string& str, size_t *idx = 0, int base = 10);
unsigned long stoul(const string& str, size_t *idx = 0, int base = 10);
long long stoll(const string& str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const string& str, size_t *idx = 0, int base = 10);
float stof(const string& str, size_t *idx = 0);
double stod(const string& str, size_t *idx = 0);
long double stold(const string& str, size_t *idx = 0);
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
int stoi(const wstring& str, size_t *idx = 0, int base = 10);
long stol(const wstring& str, size_t *idx = 0, int base = 10);
unsigned long stoul(const wstring& str, size_t *idx = 0, int base = 10);
long long stoll(const wstring& str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const wstring& str, size_t *idx = 0, int base = 10);
float stof(const wstring& str, size_t *idx = 0);
double stod(const wstring& str, size_t *idx = 0);
long double stold(const wstring& str, size_t *idx = 0);
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);
// 21.6, hash support:
template <class T> struct hash;
template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
§ 21.3 627

 c ISO/IEC N3242=11-0012
template <> struct hash<wstring>;
}
21.4 Class template basic_string [basic.string]
1 The class template basic_string describes objects that can store a sequence consisting of a varying number
of arbitrary char-like objects with the first element of the sequence at position zero. Such a sequence is also
called a “string” if the type of the char-like objects that it holds is clear from context. In the rest of this
Clause, the type of the char-like objects held in a basic_string object is designated by charT.
2 The member functions of basic_string use an object of the Allocator class passed as a template parameter
to allocate and free storage for the contained char-like objects. 231
3 The class template basic_string conforms to the requirements for a Sequence Container (23.2.3), for a
Reversible Container (23.2), and for an Allocator-aware container (Table 99), except that basic_string does
not construct or destroy its elements using allocator_traits<Alloc>::construct and allocator_traits<Alloc>::destroy
and that swap() for basic_string invalidates iterators.232 The iterators supported by basic_string are
random access iterators (24.2.7).
4 In all cases, size() <= capacity().
5 The functions described in this Clause can report two kinds of errors, each associated with an exception
type:
— a length error is associated with exceptions of type length_error (19.2.4);
— an out-of-range error is associated with exceptions of type out_of_range (19.2.5).
namespace std {
template<class charT, class traits = char_traits<charT>,
class Allocator = allocator<charT> >
class basic_string {
public:
// types:
typedef traits traits_type;
typedef typename traits::char_type value_type;
typedef Allocator allocator_type;
typedef typename allocator_traits<Allocator>::size_type size_type;
typedef typename allocator_traits<Allocator>::difference_type difference_type;
typedef value_type& reference;
typedef const value_type& const_reference;
typedef typename allocator_traits<Allocator>::pointer pointer;
typedef typename allocator_traits<Allocator>::const_pointer const_pointer;
typedef implementation-defined iterator; // See 23.2
typedef implementation-defined const_iterator; // See 23.2
typedef std::reverse_iterator<iterator> reverse_iterator;
typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
static const size_type npos = -1;
// 21.4.2, construct/copy/destroy:
explicit basic_string(const Allocator& a = Allocator());
basic_string(const basic_string& str);
231) [ Note: Allocator::value_type must name the same type as charT (21.4.1). — end note ]
232) swap() invalidates iterators to enable the small-string optimization.
§ 21.4 628

 c ISO/IEC N3242=11-0012
basic_string(basic_string&& str) noexcept;
basic_string(const basic_string& str, size_type pos, size_type n = npos,
const Allocator& a = Allocator());
basic_string(const charT* s,
size_type n, const Allocator& a = Allocator());
basic_string(const charT* s, const Allocator& a = Allocator());
basic_string(size_type n, charT c, const Allocator& a = Allocator());
template<class InputIterator>
basic_string(InputIterator begin, InputIterator end,
const Allocator& a = Allocator());
basic_string(initializer_list<charT>, const Allocator& = Allocator());
basic_string(const basic_string&, const Allocator&);
basic_string(basic_string&&, const Allocator&);
~basic_string();
basic_string& operator=(const basic_string& str);
basic_string& operator=(basic_string&& str) noexcept;
basic_string& operator=(const charT* s);
basic_string& operator=(charT c);
basic_string& operator=(initializer_list<charT>);
// 21.4.3, iterators:
iterator begin() noexcept;
const_iterator begin() const noexcept;
iterator end() noexcept;
const_iterator end() const noexcept;
reverse_iterator rbegin() noexcept;
const_reverse_iterator rbegin() const noexcept;
reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;
const_iterator cbegin() const noexcept;
const_iterator cend() const noexcept;
const_reverse_iterator crbegin() const noexcept;
const_reverse_iterator crend() const noexcept;
// 21.4.4, capacity:
size_type size() const noexcept;
size_type length() const noexcept;
size_type max_size() const noexcept;
void resize(size_type n, charT c);
void resize(size_type n);
size_type capacity() const noexcept;
void reserve(size_type res_arg = 0);
void shrink_to_fit();
void clear() noexcept;
bool empty() const noexcept;
// 21.4.5, element access:
const_reference operator[](size_type pos) const noexcept;
reference operator[](size_type pos) noexcept;
const_reference at(size_type n) const;
reference at(size_type n);
§ 21.4 629

 c ISO/IEC N3242=11-0012
const charT& front() const noexcept;
charT& front() noexcept;
const charT& back() const noexcept;
charT& back() noexcept;
// 21.4.6, modifiers:
basic_string& operator+=(const basic_string& str);
basic_string& operator+=(const charT* s);
basic_string& operator+=(charT c);
basic_string& operator+=(initializer_list<charT>);
basic_string& append(const basic_string& str);
basic_string& append(const basic_string& str, size_type pos,
size_type n);
basic_string& append(const charT* s, size_type n);
basic_string& append(const charT* s);
basic_string& append(size_type n, charT c);
template<class InputIterator>
basic_string& append(InputIterator first, InputIterator last);
basic_string& append(initializer_list<charT>);
void push_back(charT c);
basic_string& assign(const basic_string& str);
basic_string& assign(basic_string&& str) noexcept;
basic_string& assign(const basic_string& str, size_type pos,
size_type n);
basic_string& assign(const charT* s, size_type n);
basic_string& assign(const charT* s);
basic_string& assign(size_type n, charT c);
template<class InputIterator>
basic_string& assign(InputIterator first, InputIterator last);
basic_string& assign(initializer_list<charT>);
basic_string& insert(size_type pos1, const basic_string& str);
basic_string& insert(size_type pos1, const basic_string& str,
size_type pos2, size_type n);
basic_string& insert(size_type pos, const charT* s, size_type n);
basic_string& insert(size_type pos, const charT* s);
basic_string& insert(size_type pos, size_type n, charT c);
iterator insert(const_iterator p, charT c);
iterator insert(const_iterator p, size_type n, charT c);
template<class InputIterator>
iterator insert(const_iterator p, InputIterator first, InputIterator last);
iterator insert(const_iterator p, initializer_list<charT>);
basic_string& erase(size_type pos = 0, size_type n = npos);
iterator erase(const_iterator p);
iterator erase(const_iterator first, const_iterator last);
void pop_back() noexcept;
basic_string& replace(size_type pos1, size_type n1,
const basic_string& str);
basic_string& replace(size_type pos1, size_type n1,
const basic_string& str,
size_type pos2, size_type n2);
§ 21.4 630

 c ISO/IEC N3242=11-0012
basic_string& replace(size_type pos, size_type n1, const charT* s,
size_type n2);
basic_string& replace(size_type pos, size_type n1, const charT* s);
basic_string& replace(size_type pos, size_type n1, size_type n2,
charT c);
basic_string& replace(const_iterator i1, const_iterator i2,
const basic_string& str);
basic_string& replace(const_iterator i1, const_iterator i2, const charT* s,
size_type n);
basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
basic_string& replace(const_iterator i1, const_iterator i2,
size_type n, charT c);
template<class InputIterator>
basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);
basic_string& replace(const_iterator, const_iterator, initializer_list<charT>);
size_type copy(charT* s, size_type n, size_type pos = 0) const;
void swap(basic_string& str) noexcept;
// 21.4.7, string operations:
const charT* c_str() const noexcept;
const charT* data() const noexcept;
allocator_type get_allocator() const noexcept;
size_type find (const basic_string& str, size_type pos = 0) const noexcept;
size_type find (const charT* s, size_type pos, size_type n) const noexcept;
size_type find (const charT* s, size_type pos = 0) const noexcept;
size_type find (charT c, size_type pos = 0) const noexcept;
size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;
size_type rfind(const charT* s, size_type pos, size_type n) const noexcept;
size_type rfind(const charT* s, size_type pos = npos) const noexcept;
size_type rfind(charT c, size_type pos = npos) const noexcept;
size_type find_first_of(const basic_string& str,
size_type pos = 0) const noexcept;
size_type find_first_of(const charT* s,
size_type pos, size_type n) const noexcept;
size_type find_first_of(const charT* s, size_type pos = 0) const noexcept;
size_type find_first_of(charT c, size_type pos = 0) const noexcept;
size_type find_last_of (const basic_string& str,
size_type pos = npos) const noexcept;
size_type find_last_of (const charT* s,
size_type pos, size_type n) const noexcept;
size_type find_last_of (const charT* s, size_type pos = npos) const noexcept;
size_type find_last_of (charT c, size_type pos = npos) const noexcept;
size_type find_first_not_of(const basic_string& str,
size_type pos = 0) const noexcept;
size_type find_first_not_of(const charT* s, size_type pos,
size_type n) const noexcept;
size_type find_first_not_of(const charT* s, size_type pos = 0) const noexcept;
size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
size_type find_last_not_of (const basic_string& str,
§ 21.4 631

 c ISO/IEC N3242=11-0012
size_type pos = npos) const noexcept;
size_type find_last_not_of (const charT* s, size_type pos,
size_type n) const noexcept;
size_type find_last_not_of (const charT* s,
size_type pos = npos) const noexcept;
size_type find_last_not_of (charT c, size_type pos = npos) const noexcept;
basic_string substr(size_type pos = 0, size_type n = npos) const;
int compare(const basic_string& str) const noexcept;
int compare(size_type pos1, size_type n1,
const basic_string& str) const;
int compare(size_type pos1, size_type n1,
const basic_string& str,
size_type pos2, size_type n2) const;
int compare(const charT* s) const noexcept;
int compare(size_type pos1, size_type n1,
const charT* s) const;
int compare(size_type pos1, size_type n1,
const charT* s, size_type n2) const;
};
}
21.4.1 basic_string general requirements [string.require]
1 If any operation would cause size() to exceed max_size(), that operation shall throw an exception object
of type length_error.
2 If any member function or operator of basic_string throws an exception, that function or operator shall
have no other effect.
3 No erase() or pop_back() member function shall throw any exceptions. [Editor’s note: N3180 says to
modify the preceding sentence, but the new text is the same as the old.]
4 In every specialization basic_string<charT, traits, Allocator>, the type allocator_traits<Allocator>::value_-
type shall name the same type as charT. Every object of type basic_string<charT, traits, Allocator>
shall use an object of type Allocator to allocate and free storage for the contained charT objects as needed.
The Allocator object used shall be obtained as described in 23.2.1.
5 The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string
object s, the identity &*(s.begin() + n) == &*s.begin() + n shall hold for all values of n such that 0
<= n < s.size().
6 References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated
by the following uses of that basic_string object:
— as an argument to any standard library function taking a reference to non-const basic_string as an
argument.233
— Calling non-const member functions, except operator[], at, front, back, begin, rbegin, end, and
rend.
233) For example, as an argument to non-member functions swap() (21.4.8.8), operator>>() (21.4.8.9), and
getline() (21.4.8.9), or as an argument to basic_string::swap()
§ 21.4.1 632

 c ISO/IEC N3242=11-0012
21.4.2 basic_string constructors and assignment operators [string.cons]
explicit basic_string(const Allocator& a = Allocator());
1 Effects: Constructs an object of class basic_string. The postconditions of this function are indicated
in Table 63.
Table 63 — basic_string(const Allocator&) effects
Element Value
data() a non-null pointer that is copyable and can have 0
added to it
size() 0
capacity() an unspecified value
basic_string(const basic_string<charT,traits,Allocator>& str);
basic_string(basic_string<charT,traits,Allocator>&& str) noexcept;
2 Effects: Constructs an object of class basic_string as indicated in Table 64. In the second form, str
is left in a valid state with an unspecified value.
3 Throws: The second form throws nothing if the allocator’s move constructor throws nothing.
Table 64 — basic_string(const basic_string&) effects
Element Value
data() points at the first element of an allocated copy
of the array whose first element is pointed at by
str.data()
size() str.size()
capacity() a value at least as large as size()
basic_string(const basic_string<charT,traits,Allocator>& str,
size_type pos, size_type n = npos,
const Allocator& a = Allocator());
4 Requires: pos <= str.size()
5 Throws: out_of_range if pos > str.size().
6 Effects: Constructs an object of class basic_string and determines the effective length rlen of the
initial string value as the smaller of n and str.size() - pos, as indicated in Table 65.
Table 65 — basic_string(const basic_string&, size_type, size_type, const Allocator&) effects
Element Value
data() points at the first element of an allocated copy of
rlen consecutive elements of the string controlled
by str beginning at position pos
size() rlen
capacity() a value at least as large as size()
basic_string(const charT* s, size_type n,
const Allocator& a = Allocator());
§ 21.4.2 633

 c ISO/IEC N3242=11-0012
7 Requires: s shall not be a null pointer and n < npos.
8 Effects: Constructs an object of class basic_string and determines its initial string value from the
array of charT of length n whose first element is designated by s, as indicated in Table 66.
Table 66 — basic_string(const charT*, size_type, const Allocator&) effects
Element Value
data() points at the first element of an allocated copy of
the array whose first element is pointed at by s
size() n
capacity() a value at least as large as size()
basic_string(const charT* s, const Allocator& a = Allocator());
9 Requires: s shall not be a null pointer.
10 Effects: Constructs an object of class basic_string and determines its initial string value from the
array of charT of length traits::length(s) whose first element is designated by s, as indicated in
Table 67.
Table 67 — basic_string(const charT*, const Allocator&) effects
Element Value
data() points at the first element of an allocated copy of
the array whose first element is pointed at by s
size() traits::length(s)
capacity() a value at least as large as size()
11 Remarks: Uses traits::length().
basic_string(size_type n, charT c, const Allocator& a = Allocator());
12 Requires: n < npos
13 Effects: Constructs an object of class basic_string and determines its initial string value by repeating
the char-like object c for all n elements, as indicated in Table 68.
Table 68 — basic_string(size_t, charT, const Allocator&) effects
Element Value
data() points at the first element of an allocated array of
n elements, each storing the initial value c
size() n
capacity() a value at least as large as size()
template<class InputIterator>
basic_string(InputIterator begin, InputIterator end,
const Allocator& a = Allocator());
14 Effects: If InputIterator is an integral type, equivalent to
basic_string(static_cast<size_type>(begin), static_cast<value_type>(end), a)
15 Otherwise constructs a string from the values in the range [begin, end), as indicated in the Sequence
Requirements table (see 23.2.3).
§ 21.4.2 634

 c ISO/IEC N3242=11-0012
basic_string(initializer_list<charT> il, const Allocator& a = Allocator());
16 Effects: Same as basic_string(il.begin(), il.end(), a).
basic_string(const basic_string& str, const Allocator& alloc);
basic_string(basic_string&& str, const Allocator& alloc);
Effects: Constructs an object of class basic_string as indicated in Table 69. The stored allocator is
constructed from alloc. In the second form, str is left in a valid state with an unspecified value.
Table 69 — basic_string(const basic_string&, const Allocator&) and
basic_string(basic_string&&, const Allocator&) effects
Element Value
data() points at the first element of an allocated copy of
the array whose first element is pointed at by the
original value of str.data().
size() the original value of str.size()
capacity() a value at least as large as size()
get_allocator() alloc
17 Throws: The second form throws nothing if alloc == str.get_allocator() unless the copy constructor for Allocator throws.
basic_string<charT,traits,Allocator>&
operator=(const basic_string<charT,traits,Allocator>& str);
18 Effects: If *this and str are not the same object, modifies *this as shown in Table 70.
19 If *this and str are the same object, the member has no effect.
20 Returns: *this
Table 70 — operator=(const basic_string<charT, traits, Allocator>&) effects
Element Value
data() points at the first element of an allocated copy
of the array whose first element is pointed at by
str.data()
size() str.size()
capacity() a value at least as large as size()
basic_string<charT,traits,Allocator>&
operator=(basic_string<charT,traits,Allocator>&& str) noexcept;
21 Effects: If *this and str are not the same object, modifies *this as shown in Table 71. The
constructor leaves str in a valid but unspecified state. [ Note: A valid implementation is swap(str).
— end note ]
22 If *this and str are the same object, the member has no effect.
23 Returns: *this
basic_string<charT,traits,Allocator>&
operator=(const charT* s);
§ 21.4.2 635

 c ISO/IEC N3242=11-0012
Table 71 — operator=(const basic_string<charT, traits, Allocator>&&) effects
Element Value
data() points at the array whose first element was pointed
at by str.data()
size() previous value of str.size()
capacity() a value at least as large as size()
24 Returns: *this = basic_string<charT,traits,Allocator>(s).
25 Remarks: Uses traits::length().
basic_string<charT,traits,Allocator>& operator=(charT c);
26 Returns: *this = basic_string<charT,traits,Allocator>(1,c).
basic_string& operator=(initializer_list<charT> il);
27 Effects: *this = basic_string(il).
28 Returns: *this.
21.4.3 basic_string iterator support [string.iterators]
iterator begin() noexcept;
const_iterator begin() const noexcept;
const_iterator cbegin() const noexcept;
1 Returns: An iterator referring to the first character in the string.
iterator end() noexcept;
const_iterator end() const noexcept;
const_iterator cend() const noexcept;
2 Returns: An iterator which is the past-the-end value.
reverse_iterator rbegin() noexcept;
const_reverse_iterator rbegin() const noexcept;
const_reverse_iterator crbegin() const noexcept;
3 Returns: An iterator which is semantically equivalent to reverse_iterator(end()).
reverse_iterator rend() noexcept;
const_reverse_iterator rend() const noexcept;
const_reverse_iterator crend() const noexcept;
4 Returns: An iterator which is semantically equivalent to reverse_iterator(begin()).
21.4.4 basic_string capacity [string.capacity]
size_type size() const noexcept;
1 Returns: A count of the number of char-like objects currently in the string.
2 Complexity: constant time.
size_type length() const noexcept;
§ 21.4.4 636

 c ISO/IEC N3242=11-0012
3 Returns: size().
size_type max_size() const noexcept;
4 Returns: The size of the largest possible string.
5 Complexity: constant time.
void resize(size_type n, charT c);
6 Requires: n <= max_size()
7 Throws: length_error if n > max_size().
8 Effects: Alters the length of the string designated by *this as follows:
— If n <= size(), the function replaces the string designated by *this with a string of length n
whose elements are a copy of the initial elements of the original string designated by *this.
— If n > size(), the function replaces the string designated by *this with a string of length n
whose first size() elements are a copy of the original string designated by *this, and whose
remaining elements are all initialized to c.
void resize(size_type n);
9 Effects: resize(n,charT()).
size_type capacity() const noexcept;
10 Returns: The size of the allocated storage in the string.
void reserve(size_type res_arg=0);
11 The member function reserve() is a directive that informs a basic_string object of a planned change
in size, so that it can manage the storage allocation accordingly.
12 Effects: After reserve(), capacity() is greater or equal to the argument of reserve. [ Note: Calling
reserve() with a res_arg argument less than capacity() is in effect a non-binding shrink request.
A call with res_arg <= size() is in effect a non-binding shrink-to-fit request. — end note ]
13 Throws: length_error if res_arg > max_size().234
void shrink_to_fit();
14 Remarks: shrink_to_fit is a non-binding request to reduce capacity() to size(). [ Note: The
request is non-binding to allow latitude for implementation-specific optimizations. — end note ]
void clear() noexcept;
15 Effects: Behaves as if the function calls:
erase(begin(), end());
bool empty() const noexcept;
16 Returns: size() == 0.
234) reserve() uses allocator_traits<Allocator>::allocate() which may throw an appropriate exception.
§ 21.4.4 637

 c ISO/IEC N3242=11-0012
21.4.5 basic_string element access [string.access]
const_reference operator[](size_type pos) const noexcept;
reference operator[](size_type pos) noexcept;
1 Requires: pos <= size().
2 Returns: *(begin() + pos) if pos < size(), otherwise a reference to an object of type T with value
charT(); the referenced value shall not be modified.
3 Complexity: constant time.
const_reference at(size_type pos) const;
reference at(size_type pos);
4 Requires: pos < size()
5 Throws: out_of_range if pos >= size().
6 Returns: operator[](pos).
const charT& front() const noexcept;
charT& front() noexcept;
7 Requires: !empty()
8 Effects: Equivalent to operator[](0).
const charT& back() const noexcept;
charT& back() noexcept;
9 Requires: !empty()
10 Effects: Equivalent to operator[](size() - 1).
21.4.6 basic_string modifiers [string.modifiers]
21.4.6.1 basic_string::operator+= [string::op+=]
basic_string&
operator+=(const basic_string& str);
1 Effects: Calls append(str.data, str.size()).
2 Returns: *this.
basic_string& operator+=(const charT* s);
3 Effects: Calls append(s).
4 Returns: *this.
basic_string& operator+=(charT c);
5 Effects: Calls append(1, c);
6 Returns: *this.
basic_string& operator+=(initializer_list<charT> il);
§ 21.4.6.1 638

 c ISO/IEC N3242=11-0012
7 Effects: Calls append(il.first(), il.size()).
8 Returns: *this.
21.4.6.2 basic_string::append [string::append]
basic_string&
append(const basic_string& str);
1 Effects: Calls append(str.data(), str.size()).
2 Returns: *this.
basic_string&
append(const basic_string& str, size_type pos, size_type n);
3 Requires: pos <= str.size()
4 Throws: out_of_range if pos > str.size().
5 Effects: Determines the effective length rlen of the string to append as the smaller of n and str.size()
- pos and calls append(str.data() + pos, rlen).
6 Returns: *this.
basic_string&
append(const charT* s, size_type n);
7 Requires: s points to an array of at least n elements of charT.
8 Throws: length_error if size() + n > max_size().
9 Effects: The function replaces the string controlled by *this with a string of length size() + n
whose first size() elements are a copy of the original string controlled by *this and whose remaining
elements are a copy of the initial n elements of s.
10 Returns: *this.
basic_string& append(const charT* s);
11 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
12 Effects: Calls append(s, traits::length(s)).
13 Returns: *this.
basic_string& append(size_type n, charT c);
14 Effects: Equivalent to append(basic_string(n, c)).
15 Returns: *this.
template<class InputIterator>
basic_string& append(InputIterator first, InputIterator last);
16 Requires: [first,last) is a valid range.
17 Effects: Equivalent to append(basic_string(first, last)).
18 Returns: *this.
basic_string& append(initializer_list<charT> il);
§ 21.4.6.2 639

 c ISO/IEC N3242=11-0012
19 Effects: Calls append(il.begin(), il.size()).
20 *this.
void push_back(charT c)
21 Effects: Equivalent to append(static_cast<size_type>(1), c).
21.4.6.3 basic_string::assign [string::assign]
basic_string& assign(const basic_string& str);
1 Effects: Equivalent to assign(str, 0, npos).
2 Returns: *this.
basic_string& assign(basic_string&& str) noexcept;
Effects: The function replaces the string controlled by *this with a string of length str.size() whose
elements are a copy of the string controlled by str. Leaves str in a valid but unspecified state. [ Note:
A valid implementation is swap(str). — end note ]
3 Returns: *this.
basic_string&
assign(const basic_string& str, size_type pos,
size_type n);
4 Requires: pos <= str.size()
5 Throws: out_of_range if pos > str.size().
6 Effects: Determines the effective length rlen of the string to assign as the smaller of n and str.size()
- pos and calls assign(str.data() + pos rlen).
7 Returns: *this.
basic_string& assign(const charT* s, size_type n);
8 Requires: s points to an array of at least n elements of charT.
9 Throws: length_error if n > max_size().
10 Effects: Replaces the string controlled by *this with a string of length n whose elements are a copy
of those pointed to by s.
11 Returns: *this.
basic_string& assign(const charT* s);
12 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
13 Effects: Calls assign(s, traits::length(s)).
14 Returns: *this.
basic_string& assign(initializer_list<charT> il);
15 Effects: Calls assign(il.begin(), il.size()).
16 *this.
basic_string& assign(size_type n, charT c);
§ 21.4.6.3 640

 c ISO/IEC N3242=11-0012
18 7 Effects: Equivalent to assign(basic_string(n, c)).
19 Returns: *this.
template<class InputIterator>
basic_string& assign(InputIterator first, InputIterator last);
20 Effects: Equivalent to assign(basic_string(first, last)).
21 Returns: *this.
21.4.6.4 basic_string::insert [string::insert]
basic_string&
insert(size_type pos1,
const basic_string& str);
1 Requires: pos <= size().
2 Throws: out_of_range if pos > size().
3 Effects: Calls insert(pos, str.data(), str.size()).
4 Returns: *this.
basic_string&
insert(size_type pos1,
const basic_string& str,
size_type pos2, size_type n);
5 Requires: pos1 <= size() and pos2 <= str.size()
6 Throws: out_of_range if pos1 > size() or pos2 > str.size().
7 Effects: Determines the effective length rlen of the string to insert as the smaller of n and str.size()
- pos2 and calls insert(pos1, str.data() + pos2, rlen).
8 Returns: *this.
basic_string&
insert(size_type pos, const charT* s, size_type n);
9 Requires: s points to an array of at least n elements of charT and pos <= size().
10 Throws: out_of_range if pos > size() or length_error if size() + n > max_size().
11 Effects: Replaces the string controlled by *this with a string of length size() + n whose first pos
elements are a copy of the initial elements of the original string controlled by *this and whose next
n elements are a copy of the elements in s and whose remaining elements are a copy of the remaining
elements of the original string controlled by *this.
12 Returns: *this.
basic_string&
insert(size_type pos, const charT* s);
13 Requires: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of
charT.
14 Effects: Calls insert(pos, s, traits::length(s)).
15 Returns: *this.
§ 21.4.6.4 641

 c ISO/IEC N3242=11-0012
basic_string&
insert(size_type pos, size_type n, charT c);
16 Effects: Equivalent to insert(pos basic_string(n, c)).
17 Returns: *this.
iterator insert(const_iterator p, charT c);
18 Requires: p is a valid iterator on *this.
19 Effects: inserts a copy of c before the character referred to by p.
20 Returns: An iterator which refers to the copy of the inserted character.
iterator insert(const_iterator p, size_type n, charT c);
21 Requires: p is a valid iterator on *this.
22 Effects: inserts n copies of c before the character referred to by p.
23 Returns: An iterator which refers to the copy of the first inserted character, or p if n == 0.
template<class InputIterator>
iterator insert(const_iterator p, InputIterator first, InputIterator last);
24 Requires: p is a valid iterator on *this. [first,last) is a valid range.
25 Effects: Equivalent to insert(p - begin(), basic_string(first, last)).
26 Returns: An iterator which refers to the copy of the first inserted character, or p if first == last.
iterator insert(const_iterator p, initializer_list<charT> il);
27 Effects: insert(p, il.begin(), il.end()).
28 Returns: An iterator which refers to the copy of the first inserted character, or p if i1 is empty.
21.4.6.5 basic_string::erase [string::erase]
basic_string<charT,traits,Allocator>&
erase(size_type pos = 0, size_type n = npos);
1 Requires: pos <= size()
2 Throws: out_of_range if pos > size().
3 Effects: Determines the effective length xlen of the string to be removed as the smaller of n and
size() - pos.
4 The function then replaces the string controlled by *this with a string of length size() - xlen
whose first pos elements are a copy of the initial elements of the original string controlled by *this,
and whose remaining elements are a copy of the elements of the original string controlled by *this
beginning at position pos + xlen.
5 Returns: *this.
iterator erase(const_iterator p);
6 Effects: removes the character referred to by p.
7 Returns: An iterator which points to the element immediately following p prior to the element being
erased. If no such element exists, end() is returned.
§ 21.4.6.5 642

 c ISO/IEC N3242=11-0012
iterator erase(const_iterator first, const_iterator last);
8 Requires: first and last are valid iterators on *this, defining a range [first,last).
9 Effects: removes the characters in the range [first,last).
10 Returns: An iterator which points to the element pointed to by last prior to the other elements being
erased. If no such element exists, end() is returned.
void pop_back() noexcept;
11 Requires: !empty()
12 Effects: Equivalent to erase(size() - 1, 1).
21.4.6.6 basic_string::replace [string::replace]
basic_string&
replace(size_type pos1, size_type n1,
const basic_string& str);
1 Requires: pos1 <= size().
2 Throws: out_of_range if pos1 > size().
3 Effects: Calls replace(pos1, n1, str.data(), str.size()).
4 Returns: *this.
basic_string&
replace(size_type pos1, size_type n1,
const basic_string& str,
size_type pos2, size_type n2);
5 Requires: pos1 <= size() and pos2 <= str.size().
6 Throws: out_of_range if pos1 > size() or pos2 > str.size().
7 Effects: Determines the effective length rlen of the string to be inserted as the smaller of n2 and
str.size() - pos2 and calls replace(pos1, n1, str.data() + pos2, rlen).
8 Returns: *this.
basic_string&
replace(size_type pos1, size_type n1, const charT* s, size_type n2);
9 Requires: pos1 <= size() and s points to an array of at least n2 elements of charT.
10 Throws: out_of_range if pos1 > size() or length_error if the length of the resulting string would
exceed max_size() (see below).
11 Effects: Determines the effective length xlen of the string to be removed as the smaller of n1 and
size() - pos1. If size() - xlen >= max_size() - n2 throws length_error. Otherwise, the function replaces the string controlled by *this with a string of length size() - xlen + n2 whose first
pos1 elements are a copy of the initial elements of the original string controlled by *this, whose next
n2 elements are a copy of the initial n2 elements of s, and whose remaining elements are a copy of the
elements of the original string controlled by *this beginning at position pos + xlen.
12 Returns: *this.
§ 21.4.6.6 643

 c ISO/IEC N3242=11-0012
basic_string&
replace(size_type pos, size_type n, const charT* s);
13 Requires: pos <= size() and s points to an array of at least traits::length(s) + 1 elements of
charT.
14 Effects: Calls replace(pos, n, s, traits::length(s)).
15 Returns: *this.
basic_string&
replace(size_type pos1, size_type n1,
size_type n2, charT c);
16 Effects: Equivalent to replace(pos1, n1, basic_string(n2, c)).
17 Returns: *this.
basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);
18 Requires: [begin(),i1) and [i1,i2) are valid ranges.
19 Effects: Calls replace(i1 - begin(), i2 - i1, str).
20 Returns: *this.
basic_string&
replace(const_iterator i1, const_iterator i2, const charT* s, size_type n);
21 Requires: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least n elements
of charT.
22 Effects: Calls replace(i1 - begin(), i2 - i1, s, n).
23 Returns: *this.
basic_string& replace(const_iterator i1, const_iterator i2, const charT* s);
24 Requires: [begin(),i1) and [i1,i2) are valid ranges and s points to an array of at least traits::length(s)
+ 1 elements of charT.
25 Effects: Calls replace(i1 - begin(), i2 - i1, s, traits::length(s)).
26 Returns: *this.
basic_string& replace(const_iterator i1, const_iterator i2, size_type n,
charT c);
27 Requires: [begin(),i1) and [i1,i2) are valid ranges.
28 Effects: Calls replace(i1 - begin(), i2 - i1, basic_string(n, c)).
29 Returns: *this.
template<class InputIterator>
basic_string& replace(const_iterator i1, const_iterator i2,
InputIterator j1, InputIterator j2);
30 Requires: [begin(),i1), [i1,i2) and [j1,j2) are valid ranges.
31 Effects: Calls replace(i1 - begin(), i2 - i1, basic_string(j1, j2)).
32 Returns: *this.
§ 21.4.6.6 644

 c ISO/IEC N3242=11-0012
basic_string& replace(const_iterator i1, const_iterator i2,
initializer_list<charT> il);
33 Requires: [begin(),i1) and [i1,i2) are valid ranges.
34 Effects: Calls replace(i1 - begin(), i2 - i1, il.begin(), il.size()).
35 *this.
21.4.6.7 basic_string::copy [string::copy]
size_type copy(charT* s, size_type n, size_type pos = 0) const;
1 Requires: pos <= size()
2 Throws: out_of_range if pos > size().
3 Effects: Determines the effective length rlen of the string to copy as the smaller of n and size() -
pos. s shall designate an array of at least rlen elements.
The function then replaces the string designated by s with a string of length rlen whose elements are
a copy of the string controlled by *this beginning at position pos.
The function does not append a null object to the string designated by s.
4 Returns: rlen.
21.4.6.8 basic_string::swap [string::swap]
void swap(basic_string<charT,traits,Allocator>& s) noexcept;
1 Postcondition: *this contains the same sequence of characters that was in s, s contains the same
sequence of characters that was in *this.
2 Complexity: constant time.
21.4.7 basic_string string operations [string.ops]
21.4.7.1 basic_string accessors [string.accessors]
const charT* c_str() const noexcept;
const charT* data() const noexcept;
1 Returns: A pointer p such that p + i == &operator[](i) for each i in [0,size()].
2 Complexity: constant time.
3 Requires: The program shall not alter any of the values stored in the character array.
allocator_type get_allocator() const noexcept;
4 Returns: A copy of the Allocator object used to construct the string or, if that allocator has been
replaced, a copy of the most recent replacement.
§ 21.4.7.1 645

 c ISO/IEC N3242=11-0012
21.4.7.2 basic_string::find [string::find]
size_type find(const basic_string& str,
size_type pos = 0) const noexcept;
1 Effects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
— pos <= xpos and xpos + str.size() <= size();
— traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type find(const charT* s, size_type pos, size_type n) const noexcept;
4 Returns: find(basic_string<charT,traits,Allocator>(s,n),pos).
size_type find(const charT* s, size_type pos = 0) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: find(basic_string(s), pos).
size_type find(charT c, size_type pos = 0) const noexcept;
7 Returns: find(basic_string<charT,traits,Allocator>(1,c),pos).
21.4.7.3 basic_string::rfind [string::rfind]
size_type rfind(const basic_string& str,
size_type pos = npos) const noexcept;
1 Effects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
— xpos <= pos and xpos + str.size() <= size();
— traits::eq(at(xpos+I), str.at(I)) for all elements I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type rfind(const charT* s, size_type pos, size_type n) const noexcept;
4 Returns: rfind(basic_string(s, n), pos).
size_type rfind(const charT* s, size_type pos = npos) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: rfind(basic_string(s), pos).
size_type rfind(charT c, size_type pos = npos) const noexcept;
7 Returns: rfind(basic_string<charT,traits,Allocator>(1,c),pos).
§ 21.4.7.3 646

 c ISO/IEC N3242=11-0012
21.4.7.4 basic_string::find_first_of [string::find.first.of]
size_type
find_first_of(const basic_string& str,
size_type pos = 0) const noexcept;
1 Effects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
— pos <= xpos and xpos < size();
— traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type
find_first_of(const charT* s, size_type pos, size_type n) const noexcept;
4 Returns: find_first_of(basic_string(s, n), pos).
size_type find_first_of(const charT* s, size_type pos = 0) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: find_first_of(basic_string(s), pos).
size_type find_first_of(charT c, size_type pos = 0) const noexcept;
7 Returns: find_first_of(basic_string<charT,traits,Allocator>(1,c),pos).
21.4.7.5 basic_string::find_last_of [string::find.last.of]
size_type
find_last_of(const basic_string& str,
size_type pos = npos) const noexcept;
1 Effects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
— xpos <= pos and xpos < size();
— traits::eq(at(xpos), str.at(I)) for some element I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type find_last_of(const charT* s, size_type pos, size_type n) const noexcept;
4 Returns: find_last_of(basic_string(s, n), pos).
size_type find_last_of(const charT* s, size_type pos = npos) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: find_last_of(basic_string(s), pos).
size_type find_last_of(charT c, size_type pos = npos) const noexcept;
7 Returns: find_last_of(basic_string<charT,traits,Allocator>(1,c),pos).
§ 21.4.7.5 647

 c ISO/IEC N3242=11-0012
21.4.7.6 basic_string::find_first_not_of [string::find.first.not.of]
size_type
find_first_not_of(const basic_string& str,
size_type pos = 0) const noexcept;
1 Effects: Determines the lowest position xpos, if possible, such that both of the following conditions
obtain:
— pos <= xpos and xpos < size();
— traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type
find_first_not_of(const charT* s, size_type pos, size_type n) const noexcept;
4 Returns: find_first_not_of(basic_string(s, n), pos).
size_type find_first_not_of(const charT* s, size_type pos = 0) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: find_first_not_of(basic_string(s), pos).
size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
7 Returns: find_first_not_of(basic_string(1, c), pos).
21.4.7.7 basic_string::find_last_not_of [string::find.last.not.of]
size_type
find_last_not_of(const basic_string& str,
size_type pos = npos) const noexcept;
1 Effects: Determines the highest position xpos, if possible, such that both of the following conditions
obtain:
— xpos <= pos and xpos < size();
— traits::eq(at(xpos), str.at(I)) for no element I of the string controlled by str.
2 Returns: xpos if the function can determine such a value for xpos. Otherwise, returns npos.
3 Remarks: Uses traits::eq().
size_type find_last_not_of(const charT* s, size_type pos,
size_type n) const noexcept;
4 Returns: find_last_not_of(basic_string(s, n), pos).
size_type find_last_not_of(const charT* s, size_type pos = npos) const noexcept;
5 Requires: s points to an array of at least traits::length(s) + 1 elements of charT.
6 Returns: find_last_not_of(basic_string(s), pos).
size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
§ 21.4.7.7 648

 c ISO/IEC N3242=11-0012
7 Returns: find_last_not_of(basic_string(1, c), pos).
21.4.7.8 basic_string::substr [string::substr]
basic_string<charT,traits,Allocator>
substr(size_type pos = 0, size_type n = npos) const;
1 Requires: pos <= size()
2 Throws: out_of_range if pos > size().
3 Effects: Determines the effective length rlen of the string to copy as the smaller of n and size() -
pos.
4 Returns: basic_string<charT,traits,Allocator>(data()+pos,rlen).
21.4.7.9 basic_string::compare [string::compare]
int compare(const basic_string& str) const noexcept;
1 Effects: Determines the effective length rlen of the strings to compare as the smallest of size()
and str.size(). The function then compares the two strings by calling traits::compare(data(),
str.data(), rlen).
2 Returns: The nonzero result if the result of the comparison is nonzero. Otherwise, returns a value as
indicated in Table 72.
Table 72 — compare() results
Condition Return Value
size() < str.size() < 0
size() == str.size() 0
size() > str.size() > 0
int compare(size_type pos1, size_type n1,
const basic_string& str) const;
3 Returns: basic_string(*this,pos1,n1).compare(str).
int compare(size_type pos1, size_type n1,
const basic_string& str,
size_type pos2, size_type n2 ) const;
4 Returns: basic_string(*this, pos1, n1).compare(basic_string(str, pos2, n2)).
int compare(const charT *s) const noexcept;
5 Returns: compare(basic_string(s)).
int compare(size_type pos, size_type n1,
const charT *s) const;
6 Returns: basic_string(*this, pos, n1).compare(basic_string(s)).
int compare(size_type pos, size_type n1,
const charT *s, size_type n2) const;
7 Returns: basic_string(*this, pos, n1).compare(basic_string(s, n2)).
§ 21.4.7.9 649

 c ISO/IEC N3242=11-0012
21.4.8 basic_string non-member functions [string.nonmembers]
21.4.8.1 operator+ [string::op+]
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs);
1 Returns: basic_string<charT,traits,Allocator>(lhs).append(rhs)
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
const basic_string<charT,traits,Allocator>& rhs);
2 Returns: std::move(lhs.append(rhs))
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>&& rhs);
3 Returns: std::move(rhs.insert(0, lhs))
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
basic_string<charT,traits,Allocator>&& rhs);
4 Returns: std::move(lhs.append(rhs)) [ Note: Or equivalently std::move(rhs.insert(0, lhs))
— end note ]
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs);
5 Returns: basic_string<charT,traits,Allocator>(lhs) + rhs.
6 Remarks: Uses traits::length().
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const charT* lhs,
basic_string<charT,traits,Allocator>&& rhs);
7 Returns: std::move(rhs.insert(0, lhs)).
8 Remarks: Uses traits::length().
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(charT lhs,
const basic_string<charT,traits,Allocator>& rhs);
9 Returns: basic_string<charT,traits,Allocator>(1,lhs) + rhs.
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
§ 21.4.8.1 650

 c ISO/IEC N3242=11-0012
operator+(charT lhs,
basic_string<charT,traits,Allocator>&& rhs);
10 Returns: std::move(rhs.insert(0, 1, lhs)).
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs);
11 Returns: lhs + basic_string<charT,traits,Allocator>(rhs).
12 Remarks: Uses traits::length().
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
const charT* rhs);
13 Returns: std::move(lhs.append(rhs)).
14 Remarks: Uses traits::length().
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(const basic_string<charT,traits,Allocator>& lhs,
charT rhs);
15 Returns: lhs + basic_string<charT,traits,Allocator>(1,rhs).
template<class charT, class traits, class Allocator>
basic_string<charT,traits,Allocator>
operator+(basic_string<charT,traits,Allocator>&& lhs,
charT rhs);
16 Returns: std::move(lhs.append(1, rhs)).
21.4.8.2 operator== [string::operator==]
template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: lhs.compare(rhs) == 0.
template<class charT, class traits, class Allocator>
bool operator==(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs == lhs.
template<class charT, class traits, class Allocator>
bool operator==(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
3 Requires: rhs points to an array of at least traits::length(rhs) + 1 elements of charT.
4 Returns: lhs.compare(rhs) == 0.
§ 21.4.8.2 651

 c ISO/IEC N3242=11-0012
21.4.8.3 operator!= [string::op!=]
template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: !(lhs == rhs).
template<class charT, class traits, class Allocator>
bool operator!=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs != lhs.
template<class charT, class traits, class Allocator>
bool operator!=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
3 Requires: rhs points to an array of at least traits::length(rhs) + 1 elements of charT.
4 Returns: lhs.compare(rhs) != 0.
21.4.8.4 operator< [string::op<]
template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: lhs.compare(rhs) < 0.
template<class charT, class traits, class Allocator>
bool operator< (const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs.compare(lhs) > 0.
template<class charT, class traits, class Allocator>
bool operator< (const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
3 Returns: lhs.compare(rhs) < 0.
21.4.8.5 operator> [string::op>]
template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: lhs.compare(rhs) > 0.
template<class charT, class traits, class Allocator>
bool operator> (const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs.compare(lhs) < 0.
template<class charT, class traits, class Allocator>
bool operator> (const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
§ 21.4.8.5 652

 c ISO/IEC N3242=11-0012
3 Returns: lhs.compare(rhs) > 0.
21.4.8.6 operator<= [string::op<=]
template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: lhs.compare(rhs) <= 0.
template<class charT, class traits, class Allocator>
bool operator<=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs.compare(lhs) >= 0.
template<class charT, class traits, class Allocator>
bool operator<=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
3 Returns: lhs.compare(rhs) <= 0.
21.4.8.7 operator>= [string::op>=]
template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Returns: lhs.compare(rhs) >= 0.
template<class charT, class traits, class Allocator>
bool operator>=(const charT* lhs,
const basic_string<charT,traits,Allocator>& rhs) noexcept;
2 Returns: rhs.compare(lhs) <= 0.
template<class charT, class traits, class Allocator>
bool operator>=(const basic_string<charT,traits,Allocator>& lhs,
const charT* rhs) noexcept;
3 Returns: lhs.compare(rhs) >= 0.
21.4.8.8 swap [string.special]
template<class charT, class traits, class Allocator>
void swap(basic_string<charT,traits,Allocator>& lhs,
basic_string<charT,traits,Allocator>& rhs) noexcept;
1 Effects: lhs.swap(rhs);
21.4.8.9 Inserters and extractors [string.io]
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
operator>>(basic_istream<charT,traits>& is,
basic_string<charT,traits,Allocator>& str);
§ 21.4.8.9 653

 c ISO/IEC N3242=11-0012
1 Effects: Behaves as a formatted input function (27.7.2.2.1). After constructing a sentry object, if the
sentry converts to true, calls str.erase() and then extracts characters from is and appends them to
str as if by calling str.append(1,c). If is.width() is greater than zero, the maximum number n
of characters appended is is.width(); otherwise n is str.max_size(). Characters are extracted and
appended until any of the following occurs:
— n characters are stored;
— end-of-file occurs on the input sequence;
— isspace(c,is.getloc()) is true for the next available input character c.
2 After the last character (if any) is extracted, is.width(0) is called and the sentry object k is destroyed.
3 If the function extracts no characters, it calls is.setstate(ios::failbit), which may throw ios_-
base::failure (27.5.5.4).
4 Returns: is
template<class charT, class traits, class Allocator>
basic_ostream<charT, traits>&
operator<<(basic_ostream<charT, traits>& os,
const basic_string<charT,traits,Allocator>& str);
5 Effects: Behaves as a formatted output function (27.7.3.6.1). After constructing a sentry object,
if this object returns true when converted to a value of type bool, determines padding as described
in 22.4.2.2.2, then inserts the resulting sequence of characters seq as if by calling os.rdbuf()->sputn(seq,
n), where n is the larger of os.width() and str.size(); then calls os.width(0).
6 Returns: os
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is,
basic_string<charT,traits,Allocator>& str,
charT delim);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>&& is,
basic_string<charT,traits,Allocator>& str,
charT delim);
7 Effects: Behaves as an unformatted input function (27.7.2.3), except that it does not affect the value
returned by subsequent calls to basic_istream<>::gcount(). After constructing a sentry object,
if the sentry converts to true, calls str.erase() and then extracts characters from is and appends
them to str as if by calling str.append(1, c) until any of the following occurs:
— end-of-file occurs on the input sequence (in which case, the getline function calls is.setstate(ios_-
base::eofbit)).
— traits::eq(c, delim) for the next available input character c (in which case, c is extracted but
not appended) (27.5.5.4)
— str.max_size() characters are stored (in which case, the function calls is.setstate(ios_base
::failbit)) (27.5.5.4)
8 The conditions are tested in the order shown. In any case, after the last character is extracted, the
sentry object k is destroyed.
§ 21.4.8.9 654

 c ISO/IEC N3242=11-0012
9 If the function extracts no characters, it calls is.setstate(ios_base::failbit) which may throw
ios_base::failure (27.5.5.4).
10 Returns: is.
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>& is,
basic_string<charT,traits,Allocator>& str);
template<class charT, class traits, class Allocator>
basic_istream<charT,traits>&
getline(basic_istream<charT,traits>&& is,
basic_string<charT,traits,Allocator>& str);
11 Returns: getline(is,str,is.widen(’\n’))
21.5 Numeric conversions [string.conversions]
int stoi(const string& str, size_t *idx = 0, int base = 10);
long stol(const string& str, size_t *idx = 0, int base = 10);
unsigned long stoul(const string& str, size_t *idx = 0, int base = 10);
long long stoll(const string& str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const string& str, size_t *idx = 0, int base = 10);
1 Effects: the first two functions call strtol(str.c_str(), ptr, base), and the last three functions
call strtoul(str.c_str(), ptr, base), strtoll(str.c_str(), ptr, base), and strtoull(str.c_-
str(), ptr, base), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception and idx != 0, the function stores in *idx the
index of the first unconverted element of str.
2 Returns: The converted result.
3 Throws: invalid_argument if strtol, strtoul, strtoll, or strtoull reports that no conversion
could be performed. Throws out_of_range if the converted value is outside the range of representable
values for the return type.
float stof(const string& str, size_t *idx = 0);
double stod(const string& str, size_t *idx = 0);
long double stold(const string& str, size_t *idx = 0);
4 Effects: the first two functions call strtod(str.c_str(), ptr) and the third function calls strtold(str.c_-
str(), ptr). Each function returns the converted result, if any. The argument ptr designates a
pointer to an object internal to the function that is used to determine what to store at *idx. If the
function does not throw an exception and idx != 0, the function stores in *idx the index of the first
unconverted element of str.
5 Returns: The converted result.
6 Throws: invalid_argument if strtod or strtold reports that no conversion could be performed.
Throws out_of_range if strtod or strtold sets errno to ERANGE.
string to_string(int val);
string to_string(unsigned val);
string to_string(long val);
string to_string(unsigned long val);
string to_string(long long val);
§ 21.5 655

 c ISO/IEC N3242=11-0012
string to_string(unsigned long long val);
string to_string(float val);
string to_string(double val);
string to_string(long double val);
7 Returns: Each function returns a string object holding the character representation of the value of
its argument that would be generated by calling sprintf(buf, fmt, val) with a format specifier of
"%d", "%u", "%ld", "%lu", "%lld", "%llu", "%f", "%f", or "%Lf", respectively, where buf designates
an internal character buffer of sufficient size.
int stoi(const wstring& str, size_t *idx = 0, int base = 10);
long stol(const wstring& str, size_t *idx = 0, int base = 10);
unsigned long stoul(const wstring& str, size_t *idx = 0, int base = 10);
long long stoll(const wstring& str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const wstring& str, size_t *idx = 0, int base = 10);
8 Effects: the first two functions call wcstol(str.c_str(), ptr, base), and the last three functions
call wcstoul(str.c_str(), ptr, base), wcstoll(str.c_str(), ptr, base), and wcstoull(str.c_-
str(), ptr, base), respectively. Each function returns the converted result, if any. The argument
ptr designates a pointer to an object internal to the function that is used to determine what to store
at *idx. If the function does not throw an exception and idx != 0, the function stores in *idx the
index of the first unconverted element of str.
9 Returns: The converted result.
10 Throws: invalid_argument if wcstol, wcstoul, wcstoll, or wcstoull reports that no conversion
could be performed. Throws out_of_range if the converted value is outside the range of representable
values for the return type.
float stof(const wstring& str, size_t *idx = 0);
double stod(const wstring& str, size_t *idx = 0);
long double stold(const wstring& str, size_t *idx = 0);
11 Effects: the first two functions call wcstod(str.c_str(), ptr) and the third function calls wcstold(str.c_-
str(), ptr). Each function returns the converted result, if any. The argument ptr designates a
pointer to an object internal to the function that is used to determine what to store at *idx. If the
function does not throw an exception and idx != 0, the function stores in *idx the index of the first
unconverted element of str.
12 Returns: The converted result.
13 Throws: invalid_argument if wcstod or wcstold reports that no conversion could be performed.
Throws out_of_range if wcstod or wcstold sets errno to ERANGE.
wstring to_wstring(int val);
wstring to_wstring(unsigned val);
wstring to_wstring(long val);
wstring to_wstring(unsigned long val);
wstring to_wstring(long long val);
wstring to_wstring(unsigned long long val);
wstring to_wstring(float val);
wstring to_wstring(double val);
wstring to_wstring(long double val);
14 Returns: Each function returns a wstring object holding the character representation of the value of
its argument that would be generated by calling swprintf(buf, buffsz, fmt, val) with a format
§ 21.5 656

 c ISO/IEC N3242=11-0012
specifier of L"%d", L"%u", L"%ld", L"%lu", L"%lld", L"%llu", L"%f", L"%f", or L"%Lf", respectively,
where buf designates an internal character buffer of sufficient size buffsz.
21.6 Hash support [basic.string.hash]
template <> struct hash<string>;
template <> struct hash<u16string>;
template <> struct hash<u32string>;
template <> struct hash<wstring>;
1 Requires: the template specializations shall meet the requirements of class template hash (20.8.12).
21.7 Null-terminated sequence utilities [c.strings]
1 Tables 74, 75, 76, 77, 78, and 79 describe headers <cctype>, <cwctype>, <cstring>, <cwchar>, <cstdlib>
(character conversions), and <cuchar>, respectively.
2 The contents of these headers shall be the same as the Standard C Library headers <ctype.h>, <wctype.h>,
<string.h>, <wchar.h>, and <stdlib.h> and the C Unicode TR header <uchar.h>, respectively, with the
following modifications:
3 The headers shall not define the types char16_t, char32_t, and wchar_t (2.12).
4 The function signature strchr(const char*, int) shall be replaced by the two declarations:
const char* strchr(const char* s, int c);
char* strchr( char* s, int c);
both of which shall have the same behavior as the original declaration.
5 The function signature strpbrk(const char*, const char*) shall be replaced by the two declarations:
const char* strpbrk(const char* s1, const char* s2);
char* strpbrk( char* s1, const char* s2);
both of which shall have the same behavior as the original declaration.
6 The function signature strrchr(const char*, int) shall be replaced by the two declarations:
const char* strrchr(const char* s, int c);
char* strrchr( char* s, int c);
both of which shall have the same behavior as the original declaration.
7 The function signature strstr(const char*, const char*) shall be replaced by the two declarations:
const char* strstr(const char* s1, const char* s2);
char* strstr( char* s1, const char* s2);
both of which shall have the same behavior as the original declaration.
8 The function signature memchr(const void*, int, size_t) shall be replaced by the two declarations:
const void* memchr(const void* s, int c, size_t n);
void* memchr( void* s, int c, size_t n);
both of which shall have the same behavior as the original declaration.
9 The function signature wcschr(const wchar_t*, wchar_t) shall be replaced by the two declarations:
§ 21.7 657

 c ISO/IEC N3242=11-0012
const wchar_t* wcschr(const wchar_t* s, wchar_t c);
wchar_t* wcschr( wchar_t* s, wchar_t c);
both of which shall have the same behavior as the original declaration.
10 The function signature wcspbrk(const wchar_t*, const wchar_t*) shall be replaced by the two declarations:
const wchar_t* wcspbrk(const wchar_t* s1, const wchar_t* s2);
wchar_t* wcspbrk( wchar_t* s1, const wchar_t* s2);
both of which shall have the same behavior as the original declaration.
11 The function signature wcsrchr(const wchar_t*, wchar_t) shall be replaced by the two declarations:
const wchar_t* wcsrchr(const wchar_t* s, wchar_t c);
wchar_t* wcsrchr( wchar_t* s, wchar_t c);
both of which shall have the same behavior as the original declaration.
12 The function signature wcsstr(const wchar_t*, const wchar_t*) shall be replaced by the two declarations:
const wchar_t* wcsstr(const wchar_t* s1, const wchar_t* s2);
wchar_t* wcsstr( wchar_t* s1, const wchar_t* s2);
both of which shall have the same behavior as the original declaration.
13 The function signature wmemchr(const wwchar_t*, int, size_t) shall be replaced by the two declarations:
const wchar_t* wmemchr(const wchar_t* s, wchar_t c, size_t n);
wchar_t* wmemchr( wchar_t* s, wchar_t c, size_t n);
both of which shall have the same behavior as the original declaration.
14 The functions strerror and strtok are not required to avoid data races (17.6.5.9).
15 Calling the functions listed in Table 73 with an mbstate_t* argument of NULL may introduce a data
race (17.6.5.9) with other calls to these functions with an mbstate_t* argument of NULL.
Table 73 — Potential mbstate_t data races
mbrlen mbrtowc mbsrtowc mbtowc wcrtomb
wcsrtomb wctomb
See also: ISO C 7.3, 7.10.7, 7.10.8, and 7.11. Amendment 1 4.4, 4.5, and 4.6.
Table 74 — Header <cctype> synopsis
Type Name(s)
Functions:
isalnum isblank isdigit isprint isupper
tolower isalpha isgraph ispunct isxdigit
toupper iscntrl islower isspace
§ 21.7 658

 c ISO/IEC N3242=11-0012
Table 75 — Header <cwctype> synopsis
Type Name(s)
Macro: WEOF <cwctype>
Types: wctrans_t wctype_t wint_t <cwctype>
Functions:
iswalnum iswcntrl iswgraph iswpunct iswxdigit towupper
iswalpha iswctype iswlower iswspace towctrans wctrans
iswblank iswdigit iswprint iswupper towlower wctype
Table 76 — Header <cstring> synopsis
Type Name(s)
Macro: NULL <cstring>
Type: size_t <cstring>
Functions:
memchr strcat strcspn strncpy strtok
memcmp strchr strerror strpbrk strxfrm
memcpy strcmp strlen strrchr
memmove strcoll strncat strspn
memset strcpy strncmp strstr
Table 77 — Header <cwchar> synopsis
Type Name(s)
Macros: NULL <cwchar> WCHAR_MAX WCHAR_MIN WEOF <cwchar>
Types: mbstate_t wint_t <cwchar> size_t tm
Functions:
btowc mbrlen vfwscanf wcscpy wcsspn wcsxfrm
fgetwc mbrtowc vswscanf wcscspn wcsstr wctob
fgetws mbsinit vswprintf wcsftime wcstod wmemchr
fputwc mbsrtowcs vwprintf wcslen wcstof wmemcmp
fputws putwc vwscanf wcsncat wcstok wmemcpy
fwide putwchar wcrtomb wcsncmp wcstol wmemmove
fwprintf swprintf wcscat wcsncpy wcstold wmemset
fwscanf swscanf wcschr wcspbrk wcstoll wprintf
getwc ungetwc wcscmp wcsrchr wcstoul wscanf
getwchar vfwprintf wcscoll wcsrtombs wcstoull
Table 78 — Header <cstdlib> synopsis
Type Name(s)
Macros: MB_CUR_MAX
Functions:
atof mblen strtof strtoul
atoi mbtowc strtol strtoull
atol mbstowcs strtold wctomb
atoll strtod strtoll wcstombs
§ 21.7 659

 c ISO/IEC N3242=11-0012
Table 79 — Header <cuchar> synopsis
Type Name(s)
Macros: __STDC_UTF_16__ __STDC_UTF_32__
Functions: mbrtoc16 c16rtomb
mbrtoc32 c32rtomb
§ 21.7 660

 c ISO/IEC N3242=11-0012
22 Localization library [localization]
22.1 General [localization.general]
1 This Clause describes components that C++ programs may use to encapsulate (and therefore be more
portable when confronting) cultural differences. The locale facility includes internationalization support for
character classification and string collation, numeric, monetary, and date/time formatting and parsing, and
message retrieval.
2 The following subclauses describe components for locales themselves, the standard facets, and facilities from
the ISO C library, as summarized in Table 80.
Table 80 — Localization library summary
Subclause Header(s)
22.3 Locales <locale>
22.4 Standard locale Categories
22.5 Standard code conversion facets <codecvt>
22.6 C library locales <clocale>
22.2 Header <locale> synopsis [locale.syn]
namespace std {
// 22.3.1, locale:
class locale;
template <class Facet> const Facet& use_facet(const locale&);
template <class Facet> bool has_facet(const locale&) noexcept;
// 22.3.3, convenience interfaces:
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
template <class charT> charT toupper(charT c, const locale& loc);
template <class charT> charT tolower(charT c, const locale& loc);
template <class Codecvt, class Elem = wchar_t,
class Wide_alloc = std::allocator<Elem>,
class Byte_alloc = std::allocator<char> > class wstring_convert;
template <class Codecvt, class Elem = wchar_t,
class Tr = char_traits<Elem>> class wbuffer_convert;
// 22.4.1, ctype:
§ 22.2 661

 c ISO/IEC N3242=11-0012
class ctype_base;
template <class charT> class ctype;
template <> class ctype<char>; // specialization
template <class charT> class ctype_byname;
class codecvt_base;
template <class internT, class externT, class stateT> class codecvt;
template <class internT, class externT, class stateT> class codecvt_byname;
// 22.4.2, numeric:
template <class charT, class InputIterator = istreambuf_iterator<charT> > class num_get;
template <class charT, class OutputIterator = osterambuf_iterator<charT> > class num_put;
template <class charT> class numpunct;
template <class charT> class numpunct_byname;
// 22.4.4, collation:
template <class charT> class collate;
template <class charT> class collate_byname;
// 22.4.5, date and time:
class time_base;
template <class charT, class InputIterator = istreambuf_iterator<charT> > class time_get;
template <class charT, class InputIterator> = istreambuf_iterator<charT> > class time_get_byname;
template <class charT, class OutputIterator> = ostreambuf_iterator<charT> > class time_put;
template <class charT, class OutputIterator> = ostreambuf_iterator<charT> > class time_put_byname;
// 22.4.6, money:
class money_base;
template <class charT, class InputIterator = istreambuf_iterator<charT> > > class money_get;
template <class charT, class OutputIterator = ostreambuf_iterator<charT> > > class money_put;
template <class charT, bool Intl = false> class moneypunct;
template <class charT, bool Intl = false> class moneypunct_byname;
// 22.4.7, message retrieval:
class messages_base;
template <class charT> class messages;
template <class charT> class messages_byname;
}
1 The header <locale> defines classes and declares functions that encapsulate and manipulate the information
peculiar to a locale.235
22.3 Locales [locales]
22.3.1 Class locale [locale]
namespace std {
class locale {
public:
// types:
class facet;
class id;
typedef int category;
static const category // values assigned here are for exposition only
235) In this subclause, the type name struct tm is an incomplete type that is defined in <ctime>.
§ 22.3.1 662

 c ISO/IEC N3242=11-0012
none = 0,
collate = 0x010, ctype = 0x020,
monetary = 0x040, numeric = 0x080,
time = 0x100, messages = 0x200,
all = collate | ctype | monetary | numeric | time | messages;
// construct/copy/destroy:
locale() noexcept;
locale(const locale& other) noexcept;
explicit locale(const char* std_name);
explicit locale(const string& std_name);
locale(const locale& other, const char* std_name, category);
locale(const locale& other, const string& std_name, category);
template <class Facet> locale(const locale& other, Facet* f);
locale(const locale& other, const locale& one, category);
~locale(); // not virtual
const locale& operator=(const locale& other) noexcept;
template <class Facet> locale combine(const locale& other) const;
// locale operations:
basic_string<char> name() const;
bool operator==(const locale& other) const;
bool operator!=(const locale& other) const;
template <class charT, class traits, class Allocator>
bool operator()(const basic_string<charT,traits,Allocator>& s1,
const basic_string<charT,traits,Allocator>& s2) const;
// global locale objects:
static locale global(const locale&);
static const locale& classic();
};
}
1 Class locale implements a type-safe polymorphic set of facets, indexed by facet type. In other words, a
facet has a dual role: in one sense, it’s just a class interface; at the same time, it’s an index into a locale’s
set of facets.
2 Access to the facets of a locale is via two function templates, use_facet<> and has_facet<>.
3 [ Example: An iostream operator<< might be implemented as:236
template <class charT, class traits>
basic_ostream<charT,traits>&
operator<< (basic_ostream<charT,traits>& s, Date d) {
typename basic_ostream<charT,traits>::sentry cerberos(s);
if (cerberos) {
ios_base::iostate err = ios_base::iostate::goodbit;
tm tmbuf; d.extract(tmbuf);
use_facet< time_put<charT,ostreambuf_iterator<charT,traits> > >(
s.getloc()).put(s, s, s.fill(), err, &tmbuf, ’x’);
s.setstate(err); // might throw
}
236) Note that in the call to put the stream is implicitly converted to an ostreambuf_iterator<charT,traits>.
§ 22.3.1 663

 c ISO/IEC N3242=11-0012
return s;
} —
end example ]
4 In the call to use_facet<Facet>(loc), the type argument chooses a facet, making available all members
of the named type. If Facet is not present in a locale, it throws the standard exception bad_cast. A C++
program can check if a locale implements a particular facet with the function template has_facet<Facet>().
User-defined facets may be installed in a locale, and used identically as may standard facets (22.4.8).
5 [ Note: All locale semantics are accessed via use_facet<> and has_facet<>, except that:
— A member operator template operator()(const basic_string<C,T,A>&, const basic_string<C,T,A>&)
is provided so that a locale may be used as a predicate argument to the standard collections, to collate
strings.
— Convenient global interfaces are provided for traditional ctype functions such as isdigit() and
isspace(), so that given a locale object loc a C++ program can call isspace(c,loc). (This eases
upgrading existing extractors (27.7.2.2).) — end note ]
6 Once a facet reference is obtained from a locale object by calling use_facet<>, that reference remains usable,
and the results from member functions of it may be cached and re-used, as long as some locale object refers
to that facet.
7 In successive calls to a locale facet member function on a facet object installed in the same locale, the
returned result shall be identical.
8 A locale constructed from a name string (such as "POSIX"), or from parts of two named locales, has a
name; all others do not. Named locales may be compared for equality; an unnamed locale is equal only to
(copies of) itself. For an unnamed locale, locale::name() returns the string "*".
9 Whether there is one global locale object for the entire program or one global locale object per thread is
implementation-defined. Implementations should provide one global locale object per thread. If there is a
single global locale object for the entire program, implementations are not required to avoid data races on
it (17.6.5.9).
22.3.1.1 locale types [locale.types]
22.3.1.1.1 Type locale::category [locale.category]
typedef int category;
1 Valid category values include the locale member bitmask elements collate, ctype, monetary, numeric,
time, and messages, each of which represents a single locale category. In addition, locale member bitmask
constant none is defined as zero and represents no category. And locale member bitmask constant all is
defined such that the expression
(collate | ctype | monetary | numeric | time | messages | all) == all
is true, and represents the union of all categories. Further, the expression (X | Y), where X and Y each
represent a single category, represents the union of the two categories.
§ 22.3.1.1.1 664

 c ISO/IEC N3242=11-0012
Table 81 — Locale category facets
Category Includes facets
collate collate<char>, collate<wchar_t>
ctype ctype<char>, ctype<wchar_t>
codecvt<char,char,mbstate_t>
codecvt<char16_t,char,mbstate_t>
codecvt<char32_t,char,mbstate_t>
codecvt<wchar_t,char,mbstate_t>
monetary moneypunct<char>, moneypunct<wchar_t>
moneypunct<char,true>, moneypunct<wchar_t,true>
money_get<char>, money_get<wchar_t>
money_put<char>, money_put<wchar_t>
numeric numpunct<char>, numpunct<wchar_t>
num_get<char>, num_get<wchar_t>
num_put<char>, num_put<wchar_t>
time time_get<char>, time_get<wchar_t>
time_put<char>, time_put<wchar_t>
messages messages<char>, messages<wchar_t>
2 locale member functions expecting a category argument require one of the category values defined above,
or the union of two or more such values. Such a category value identifies a set of locale categories. Each
locale category, in turn, identifies a set of locale facets, including at least those shown in Table 81.
3 For any locale loc either constructed, or returned by locale::classic(), and any facet Facet shown in
Table 81, has_facet<Facet>(loc) is true. Each locale member function which takes a locale::category
argument operates on the corresponding set of facets.
4 An implementation is required to provide those specializations for facet templates identified as members of
a category, and for those shown in Table 82.
5 The provided implementation of members of facets num_get<charT> and num_put<charT> calls use_facet <F> (l) only for facet F of types numpunct<charT> and ctype<charT>, and for locale l the value obtained
by calling member getloc() on the ios_base& argument to these functions.
6 In declarations of facets, a template formal parameter with name InputIterator or OutputIterator indicates the set of all possible specializations on parameters that satisfy the requirements of an Input Iterator
or an Output Iterator, respectively (24.2). A template formal parameter with name C represents the set of
types containing char, wchar_t, and any other implementation-defined character types that satisfy the requirements for a character on which any of the iostream components can be instantiated. A template formal
parameter with name International represents the set of all possible specializations on a bool parameter.
22.3.1.1.2 Class locale::facet [locale.facet]
namespace std {
class locale::facet {
protected:
explicit facet(size_t refs = 0);
virtual ~facet();
facet(const facet&) = delete;
void operator=(const facet&) = delete;
};
}
§ 22.3.1.1.2 665

 c ISO/IEC N3242=11-0012
Table 82 — Required specializations
Category Includes facets
collate collate_byname<char>, collate_byname<wchar_t>
ctype ctype_byname<char>, ctype_byname<wchar_t>
codecvt_byname<char,char,mbstate_t>
codecvt_byname<char16_t,char,mbstate_t>
codecvt_byname<char32_t,char,mbstate_t>
codecvt_byname<wchar_t,char,mbstate_t>
monetary moneypunct_byname<char,International>
moneypunct_byname<wchar_t,International>
money_get<C,InputIterator>
money_put<C,OutputIterator>
numeric numpunct_byname<char>, numpunct_byname<wchar_t>
num_get<C,InputIterator>, num_put<C,OutputIterator>
time time_get<char,InputIterator>
time_get_byname<char,InputIterator>
time_get<wchar_t,InputIterator>
time_get_byname<wchar_t,InputIterator>
time_put<char,OutputIterator>
time_put_byname<char,OutputIterator>
time_put<wchar_t,OutputIterator>
time_put_byname<wchar_t,OutputIterator>
messages messages_byname<char>, messages_byname<wchar_t>
1 Template parameters in this Clause which are required to be facets are those named Facet in declarations. A
program that passes a type that is not a facet, or a type that refers to a volatile-qualified facet, as an (explicit
or deduced) template parameter to a locale function expecting a facet, is ill-formed. A const-qualified facet
is a valid template argument to any locale function that expects a Facet template parameter.
2 The refs argument to the constructor is used for lifetime management.
— For refs == 0, the implementation performs delete static_cast<locale::facet*>(f) (where f is
a pointer to the facet) when the last locale object containing the facet is destroyed; for refs == 1,
the implementation never destroys the facet.
3 Constructors of all facets defined in this Clause take such an argument and pass it along to their facet
base class constructor. All one-argument constructors defined in this Clause are explicit, preventing their
participation in automatic conversions.
4 For some standard facets a standard “. . ._byname” class, derived from it, implements the virtual function
semantics equivalent to that facet of the locale constructed by locale(const char*) with the same name.
Each such facet provides a constructor that takes a const char* argument, which names the locale, and a
refs argument, which is passed to the base class constructor. Each such facet also provides a constructor
that takes a string argument str and a refs argument, which has the same effect as calling the first
constructor with the two arguments str.c_str() and refs. If there is no “. . ._byname” version of a facet,
the base class implements named locale semantics itself by reference to other facets.
22.3.1.1.3 Class locale::id [locale.id]
namespace std {
class locale::id {
§ 22.3.1.1.3 666

 c ISO/IEC N3242=11-0012
public:
id();
void operator=(const id&) = delete;
id(const id&) = delete;
};
}
1 The class locale::id provides identification of a locale facet interface, used as an index for lookup and to
encapsulate initialization.
2 [ Note: Because facets are used by iostreams, potentially while static constructors are running, their initialization cannot depend on programmed static initialization. One initialization strategy is for locale to
initialize each facet’s id member the first time an instance of the facet is installed into a locale. This depends
only on static storage being zero before constructors run (3.6.2). — end note ]
22.3.1.2 locale constructors and destructor [locale.cons]
locale() noexcept;
1 Default constructor: a snapshot of the current global locale.
2 Effects: Constructs a copy of the argument last passed to locale::global(locale&), if it has been
called; else, the resulting facets have virtual function semantics identical to those of locale::classic().
[ Note: This constructor is commonly used as the default value for arguments of functions that take a
const locale& argument. — end note ]
locale(const locale& other) noexcept;
3 Effects: Constructs a locale which is a copy of other.
4 Effects: Creates a copy of other, replacing the current value.
5 Returns: *this
explicit locale(const char* std_name);
6 Effects: Constructs a locale using standard C locale names, e.g., "POSIX". The resulting locale implements semantics defined to be associated with that name.
7 Throws: runtime_error if the argument is not valid, or is null.
8 Remarks: The set of valid string argument values is "C", "", and any implementation-defined values.
explicit locale(const string& std_name);
9 Effects: The same as locale(std_name.c_str()).
locale(const locale& other, const char* std_name, category);
10 Effects: Constructs a locale as a copy of other except for the facets identified by the category
argument, which instead implement the same semantics as locale(std_name).
11 Throws: runtime_error if the argument is not valid, or is null.
12 Remarks: The locale has a name if and only if other has a name.
locale(const locale& other, const string& std_name, category cat);
13 Effects: The same as locale(other, std_name.c_str(), cat).
template <class Facet> locale(const locale& other, Facet* f);
§ 22.3.1.2 667

 c ISO/IEC N3242=11-0012
14 Effects: Constructs a locale incorporating all facets from the first argument except that of type Facet,
and installs the second argument as the remaining facet. If f is null, the resulting object is a copy of
other.
15 Remarks: The resulting locale has no name.
locale(const locale& other, const locale& one, category cats);
16 Effects: Constructs a locale incorporating all facets from the first argument except those that implement cats, which are instead incorporated from the second argument.
17 Remarks: The resulting locale has a name if and only if the first two arguments have names.
const locale& operator=(const locale& other) noexcept;
~locale();
18 A non-virtual destructor that throws no exceptions.
22.3.1.3 locale members [locale.members]
template <class Facet> locale combine(const locale& other) const;
1 Effects: Constructs a locale incorporating all facets from *this except for that one facet of other that
is identified by Facet.
2 Returns: The newly created locale.
3 Throws: runtime_error if has_facet<Facet>(other) is false.
4 Remarks: The resulting locale has no name.
basic_string<char> name() const;
5 Returns: The name of *this, if it has one; otherwise, the string "*". If *this has a name, then
locale(name().c_str()) is equivalent to *this. Details of the contents of the resulting string are
otherwise implementation-definedreturn value of locale::name.
22.3.1.4 locale operators [locale.operators]
bool operator==(const locale& other) const;
1 Returns: true if both arguments are the same locale, or one is a copy of the other, or each has a name
and the names are identical; false otherwise.
bool operator!=(const locale& other) const;
2 Returns: The result of the expression: !(*this == other).
template <class charT, class traits, class Allocator>
bool operator()(const basic_string<charT,traits,Allocator>& s1,
const basic_string<charT,traits,Allocator>& s2) const;
3 Effects: Compares two strings according to the collate<charT> facet.
4 Remarks: This member operator template (and therefore locale itself) satisfies requirements for a
comparator predicate template argument (Clause 25) applied to strings.
5 Returns: The result of the following expression:
§ 22.3.1.4 668

 c ISO/IEC N3242=11-0012
use_facet< collate<charT> >(*this).compare
(s1.data(), s1.data()+s1.size(), s2.data(), s2.data()+s2.size()) < 0;
6 [ Example: A vector of strings v can be collated according to collation rules in locale loc simply
by (25.4.1, 23.3.6):
std::sort(v.begin(), v.end(), loc);
— end example ]
22.3.1.5 locale static members [locale.statics]
static locale global(const locale& loc);
1 Sets the global locale to its argument.
2 Effects: Causes future calls to the constructor locale() to return a copy of the argument. If the
argument has a name, does
std::setlocale(LC_ALL, loc.name().c_str());
otherwise, the effect on the C locale, if any, is implementation-defined. No library function other
than locale::global() shall affect the value returned by locale(). [ Note: See 22.6 for data race
considerations when setlocale is invoked. — end note ]
3 Returns: The previous value of locale().
static const locale& classic();
4 The "C" locale.
5 Returns: A locale that implements the classic "C" locale semantics, equivalent to the value locale("C").
6 Remarks: This locale, its facets, and their member functions, do not change with time.
22.3.2 locale globals [locale.global.templates]
template <class Facet> const Facet& use_facet(const locale& loc);
1 Requires: Facet is a facet class whose definition contains the public static member id as defined
in 22.3.1.1.2.
2 Returns: A reference to the corresponding facet of loc, if present.
3 Throws: bad_cast if has_facet<Facet>(loc) is false.
4 Remarks: The reference returned remains valid at least as long as any copy of loc exists.
template <class Facet> bool has_facet(const locale& loc) noexcept;
5 Returns: True if the facet requested is present in loc; otherwise false.
22.3.3 Convenience interfaces [locale.convenience]
22.3.3.1 Character classification [classification]
§ 22.3.3.1 669

 c ISO/IEC N3242=11-0012
template <class charT> bool isspace (charT c, const locale& loc);
template <class charT> bool isprint (charT c, const locale& loc);
template <class charT> bool iscntrl (charT c, const locale& loc);
template <class charT> bool isupper (charT c, const locale& loc);
template <class charT> bool islower (charT c, const locale& loc);
template <class charT> bool isalpha (charT c, const locale& loc);
template <class charT> bool isdigit (charT c, const locale& loc);
template <class charT> bool ispunct (charT c, const locale& loc);
template <class charT> bool isxdigit(charT c, const locale& loc);
template <class charT> bool isalnum (charT c, const locale& loc);
template <class charT> bool isgraph (charT c, const locale& loc);
1 Each of these functions isF returns the result of the expression:
use_facet< ctype<charT> >(loc).is(ctype_base::F, c)
where F is the ctype_base::mask value corresponding to that function (22.4.1).237
22.3.3.2 Conversions [conversions]
22.3.3.2.1 Character conversions [conversions.character]
template <class charT> charT toupper(charT c, const locale& loc);
1 Returns: use_facet<ctype<charT> >(loc).toupper(c).
template <class charT> charT tolower(charT c, const locale& loc);
2 Returns: use_facet<ctype<charT> >(loc).tolower(c).
22.3.3.2.2 string conversions [conversions.string]
1 Class template wstring_convert performs conversions between a wide string and a byte string. It lets you
specify a code conversion facet (like class template codecvt) to perform the conversions, without affecting
any streams or locales. [ Example: Say, for example, you have a code conversion facet called codecvt_utf8
that you want to use to output to cout a UTF-8 multibyte sequence corresponding to a wide string, but
you don’t want to alter the locale for cout. You can write something like:
wstring_convert<codecvt_utf8<wchar_t>> myconv;
std::string mbstring = myconv.to_bytes(L"Hello\n");
std::cout << mbstring;
— end example ]
2 Class template wstring_convert synopsis
namespace std {
template<class Codecvt, class Elem = wchar_t,
class Wide_alloc = std::allocator<Elem>,
class Byte_alloc = std::allocator<char> > class wstring_convert {
public:
typedef std::basic_string<char, char_traits<char>, Byte_alloc> byte_string;
typedef std::basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;
typedef typename Codecvt::state_type state_type;
typedef typename wide_string::traits_type::int_type int_type;
237) When used in a loop, it is faster to cache the ctype<> facet and use it directly, or use the vector form of ctype<>::is.
§ 22.3.3.2.2 670

 c ISO/IEC N3242=11-0012
wstring_convert(Codecvt *pcvt = new Codecvt);
wstring_convert(Codecvt *pcvt, state_type state);
wstring_convert(const byte_string& byte_err,
const wide_string& wide_err = wide_string());
~wstring_convert();
wide_string from_bytes(char byte);
wide_string from_bytes(const char *ptr);
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char *first, const char *last);
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem *wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem *first, const Elem *last);
size_t converted() const;
state_type state() const;
private:
byte_string byte_err_string; // exposition only
wide_string wide_err_string; // exposition only
Codecvt *cvtptr; // exposition only
state_type cvtstate; // exposition only
size_t cvtcount; // exposition only
};
}
3 The class template describes an object that controls conversions between wide string objects of class
std::basic_string<Elem, char_traits<Elem>, Wide_alloc> and byte string objects of class std::basic_-
string<char, char_traits<char>, Byte_alloc>. The class template defines the types wide_string and
byte_string as synonyms for these two types. Conversion between a sequence of Elem values (stored
in a wide_string object) and multibyte sequences (stored in a byte_string object) is performed by an
object of class Codecvt<Elem, char, std::mbstate_t>, which meets the requirements of the standard
code-conversion facet std::codecvt<Elem, char, std::mbstate_t>.
4 An object of this class template stores:
— byte_err_string — a byte string to display on errors
— wide_err_string — a wide string to display on errors
— cvtptr — a pointer to the allocated conversion object (which is freed when the wstring_convert
object is destroyed)
— cvtstate — a conversion state object
— cvtcount — a conversion count
typedef std::basic_string<char> byte_string;
5 The type shall be a synonym for std::basic_string<char>
size_t converted() const;
6 Returns: cvtcount.
wide_string from_bytes(char byte);
wide_string from_bytes(const char *ptr);
§ 22.3.3.2.2 671

 c ISO/IEC N3242=11-0012
wide_string from_bytes(const byte_string& str);
wide_string from_bytes(const char *first, const char *last);
7 Effects: The first member function shall convert the single-element sequence byte to a wide string.
The second member function shall convert the nul-terminated sequence beginning at ptr to a wide
string. The third member function shall convert the sequence stored in str to a wide string. The fourth
member function shall convert the sequence defined by the range [first,last) to a wide string.
8 In all cases:
— If the cvtstate object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.
— The number of input elements successfully converted shall be stored in cvtcount.
9 Returns: If no conversion error occurs, the member function shall return the converted wide string.
Otherwise, if the object was constructed with a wide-error string, the member function shall return
the wide-error string. Otherwise, the member function throws an object of class std::range_error.
typedef typename wide_string::traits_type::int_type int_type;
The type shall be a synonym for wide_string::traits_type::int_type.
state_type state() const;
10 returns cvtstate.
typedef typename Codecvt::state_type state_type;
11 The type shall be a synonym for Codecvt::state_type.
byte_string to_bytes(Elem wchar);
byte_string to_bytes(const Elem *wptr);
byte_string to_bytes(const wide_string& wstr);
byte_string to_bytes(const Elem *first, const Elem *last);
12 Effects: The first member function shall convert the single-element sequence wchar to a byte string.
The second member function shall convert the nul-terminated sequence beginning at wptr to a byte
string. The third member function shall convert the sequence stored in wstr to a byte string. The
fourth member function shall convert the sequence defined by the range [first,last) to a byte string.
13 In all cases:
— If the cvtstate object was not constructed with an explicit value, it shall be set to its default value
(the initial conversion state) before the conversion begins. Otherwise it shall be left unchanged.
— The number of input elements successfully converted shall be stored in cvtcount.
14 Returns: If no conversion error occurs, the member function shall return the converted byte string.
Otherwise, if the object was constructed with a byte-error string, the member function shall return the
byte-error string. Otherwise, the member function shall throw an object of class std::range_error.
typedef std::basic_string<Elem> wide_string;
15 The type shall be a synonym for std::basic_string<Elem>.
wstring_convert(Codecvt *pcvt = new Codecvt);
wstring_convert(Codecvt *pcvt, state_type state);
wstring_convert(const byte_string& byte_err,
const wide_string& wide_err = wide_string());
§ 22.3.3.2.2 672

 c ISO/IEC N3242=11-0012
16 Effects: The first constructor shall store pcvt in cvtptr and default values in cvtstate, byte_-
err_string, and wide_err_string. The second constructor shall store pcvt in cvtptr, state in
cvtstate, and default values in byte_err_string and wide_err_string; moreover the stored state
shall be retained between calls to from_bytes and to_bytes. The third constructor shall store new
Codecvt in cvtptr, state_type() in cvtstate, byte_err in byte_err_string, and wide_err in
wide_err_string.
~wstring_convert();
17 Effects: The destructor shall delete cvtptr.
22.3.3.2.3 Buffer conversions [conversions.buffer]
1 Class template wbuffer_convert looks like a wide stream buffer, but performs all its I/O through an
underlying byte stream buffer that you specify when you construct it. Like class template wstring_convert,
it lets you specify a code conversion facet to perform the conversions, without affecting any streams or locales.
2 Class template wbuffer_convert synopsis
namespace std {
template<class Codecvt,
class Elem = wchar_t,
class Tr = std::char_traits<Elem> >
class wbuffer_convert
: public std::basic_streambuf<Elem, Tr> {
public:
typedef typename Tr::state_type state_type;
wbuffer_convert(std::streambuf *bytebuf = 0,
Codecvt *pcvt = new Codecvt,
state_type state = state_type());
std::streambuf *rdbuf() const;
std::streambuf *rdbuf(std::streambuf *bytebuf);
state_type state() const;
private:
std::streambuf *bufptr; // exposition only
Codecvt *cvtptr; // exposition only
state_type cvtstate; // exposition only
};
}
3 The class template describes a stream buffer that controls the transmission of elements of type Elem, whose
character traits are described by the class Tr, to and from a byte stream buffer of type std::streambuf.
Conversion between a sequence of Elem values and multibyte sequences is performed by an object of
class Codecvt<Elem, char, std::mbstate_t>, which shall meet the requirements of the standard codeconversion facet std::codecvt<Elem, char, std::mbstate_t>.
4 An object of this class template stores:
— bufptr — a pointer to its underlying byte stream buffer
— cvtptr — a pointer to the allocated conversion object (which is freed when the wbuffer_convert
object is destroyed)
§ 22.3.3.2.3 673

 c ISO/IEC N3242=11-0012
— cvtstate — a conversion state object
state_type state() const;
5 Returns: cvtstate.
std::streambuf *rdbuf() const;
6 Returns: bufptr.
std::streambuf *rdbuf(std::streambuf *bytebuf);
7 Effects: stores bytebuf in bufptr.
8 Returns: The previous value of bufptr.
typedef typename Codecvt::state_type state_type;
9 The type shall be a synonym for Codecvt::state_type.
wbuffer_convert(std::streambuf *bytebuf = 0,
Codecvt *pcvt = new Codecvt, state_type state = state_type());
10 Effects: The constructor constructs a stream buffer object, initializes bufptr to bytebuf, initializes
cvtptr to pcvt, and initializes cvtstate to state.
~wbuffer_convert();
11 Effects: The destructor shall delete cvtptr.
22.4 Standard locale categories [locale.categories]
1 Each of the standard categories includes a family of facets. Some of these implement formatting or parsing of
a datum, for use by standard or users’ iostream operators << and >>, as members put() and get(), respectively. Each such member function takes an ios_base& argument whose members flags(), precision(),
and width(), specify the format of the corresponding datum (27.5.3). Those functions which need to use
other facets call its member getloc() to retrieve the locale imbued there. Formatting facets use the character
argument fill to fill out the specified width where necessary.
2 The put() members make no provision for error reporting. (Any failures of the OutputIterator argument
must be extracted from the returned iterator.) The get() members take an ios_base::iostate& argument
whose value they ignore, but set to ios_base::failbit in case of a parse error.
3 Within this clause it is unspecified whether one virtual function calls another virtual function.
22.4.1 The ctype category [category.ctype]
namespace std {
class ctype_base {
public:
typedef T mask;
// numeric values are for exposition only.
static const mask space = 1 << 0;
static const mask print = 1 << 1;
static const mask cntrl = 1 << 2;
static const mask upper = 1 << 3;
static const mask lower = 1 << 4;
static const mask alpha = 1 << 5;
§ 22.4.1 674

 c ISO/IEC N3242=11-0012
static const mask digit = 1 << 6;
static const mask punct = 1 << 7;
static const mask xdigit = 1 << 8;
static const mask alnum = alpha | digit;
static const mask graph = alnum | punct;
};
}
1 The type mask is a bitmask type (17.5.2.1.3).
22.4.1.1 Class template ctype [locale.ctype]
namespace std {
template <class charT>
class ctype : public locale::facet, public ctype_base {
public:
typedef charT char_type;
explicit ctype(size_t refs = 0);
bool is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high, mask* vec) const;
const charT* scan_is(mask m,
const charT* low, const charT* high) const;
const charT* scan_not(mask m,
const charT* low, const charT* high) const;
charT toupper(charT c) const;
const charT* toupper(charT* low, const charT* high) const;
charT tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
charT widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
char narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT*, char dfault,
char* to) const;
static locale::id id;
protected:
~ctype();
virtual bool do_is(mask m, charT c) const;
virtual const charT* do_is(const charT* low, const charT* high,
mask* vec) const;
virtual const charT* do_scan_is(mask m,
const charT* low, const charT* high) const;
virtual const charT* do_scan_not(mask m,
const charT* low, const charT* high) const;
virtual charT do_toupper(charT) const;
virtual const charT* do_toupper(charT* low, const charT* high) const;
virtual charT do_tolower(charT) const;
virtual const charT* do_tolower(charT* low, const charT* high) const;
virtual charT do_widen(char) const;
virtual const char* do_widen(const char* low, const char* high,
charT* dest) const;
virtual char do_narrow(charT, char dfault) const;
§ 22.4.1.1 675

 c ISO/IEC N3242=11-0012
virtual const charT* do_narrow(const charT* low, const charT* high,
char dfault, char* dest) const;
};
}
1 Class ctype encapsulates the C library <cctype> features. istream members are required to use ctype<>
for character classing during input parsing.
2 The specializations required in Table 81 (22.3.1.1.1), namely ctype<char> and ctype<wchar_t>, implement
character classing appropriate to the implementation’s native character set.
22.4.1.1.1 ctype members [locale.ctype.members]
bool is(mask m, charT c) const;
const charT* is(const charT* low, const charT* high,
mask* vec) const;
1 Returns: do_is(m,c) or do_is(low,high,vec)
const charT* scan_is(mask m,
const charT* low, const charT* high) const;
2 Returns: do_scan_is(m,low,high)
const charT* scan_not(mask m,
const charT* low, const charT* high) const;
3 Returns: do_scan_not(m,low,high)
charT toupper(charT) const;
const charT* toupper(charT* low, const charT* high) const;
4 Returns: do_toupper(c) or do_toupper(low,high)
charT tolower(charT c) const;
const charT* tolower(charT* low, const charT* high) const;
5 Returns: do_tolower(c) or do_tolower(low,high)
charT widen(char c) const;
const char* widen(const char* low, const char* high, charT* to) const;
6 Returns: do_widen(c) or do_widen(low,high,to)
char narrow(charT c, char dfault) const;
const charT* narrow(const charT* low, const charT*, char dfault,
char* to) const;
7 Returns: do_narrow(c,dfault) or do_narrow(low,high,dfault,to)
22.4.1.1.2 ctype virtual functions [locale.ctype.virtuals]
bool do_is(mask m, charT c) const;
const charT* do_is(const charT* low, const charT* high,
mask* vec) const;
1 Effects: Classifies a character or sequence of characters. For each argument character, identifies a
value M of type ctype_base::mask. The second form identifies a value M of type ctype_base::mask
for each *p where (low<=p && p<high), and places it into vec[p-low].
§ 22.4.1.1.2 676

 c ISO/IEC N3242=11-0012
2 Returns: The first form returns the result of the expression (M & m) != 0; i.e., true if the character
has the characteristics specified. The second form returns high.
const charT* do_scan_is(mask m,
const charT* low, const charT* high) const;
3 Effects: Locates a character in a buffer that conforms to a classification m.
4 Returns: The smallest pointer p in the range [low, high) such that is(m,*p) would return true;
otherwise, returns high.
const charT* do_scan_not(mask m,
const charT* low, const charT* high) const;
5 Effects: Locates a character in a buffer that fails to conform to a classification m.
6 Returns: The smallest pointer p, if any, in the range [low,high) such that is(m,*p) would return
false; otherwise, returns high.
charT do_toupper(charT c) const;
const charT* do_toupper(charT* low, const charT* high) const;
7 Effects: Converts a character or characters to upper case. The second form replaces each character *p
in the range [low,high) for which a corresponding upper-case character exists, with that character.
8 Returns: The first form returns the corresponding upper-case character if it is known to exist, or its
argument if not. The second form returns high.
charT do_tolower(charT c) const;
const charT* do_tolower(charT* low, const charT* high) const;
9 Effects: Converts a character or characters to lower case. The second form replaces each character *p in
the range [low,high) and for which a corresponding lower-case character exists, with that character.
10 Returns: The first form returns the corresponding lower-case character if it is known to exist, or its
argument if not. The second form returns high.
charT do_widen(char c) const;
const char* do_widen(const char* low, const char* high,
charT* dest) const;
11 Effects: Applies the simplest reasonable transformation from a char value or sequence of char values
to the corresponding charT value or values.238 The only characters for which unique transformations
are required are those in the basic source character set (2.3).
For any named ctype category with a ctype<charT> facet ctc and valid ctype_base::mask value M,
(ctc.is(M, c) || !is(M, do_widen(c)) ) is true.239
The second form transforms each character *p in the range [low,high), placing the result in dest[p-low].
12 Returns: The first form returns the transformed value. The second form returns high.
char do_narrow(charT c, char dfault) const;
const charT* do_narrow(const charT* low, const charT* high,
char dfault, char* dest) const;
238) The char argument of do_widen is intended to accept values derived from character literals for conversion to the locale’s
encoding.
239) In other words, the transformed character is not a member of any character classification that c is not also a member of.
§ 22.4.1.1.2 677

 c ISO/IEC N3242=11-0012
13 Effects: Applies the simplest reasonable transformation from a charT value or sequence of charT values
to the corresponding char value or values.
For any character c in the basic source character set (2.3) the transformation is such that
do_widen(do_narrow(c,0)) == c
For any named ctype category with a ctype<char> facet ctc however, and ctype_base::mask value
M,
(is(M,c) || !ctc.is(M, do_narrow(c,dfault)) )
is true (unless do_narrow returns dfault). In addition, for any digit character c, the expression (do_-
narrow(c, dfault) - ’0’) evaluates to the digit value of the character. The second form transforms
each character *p in the range [low,high), placing the result (or dfault if no simple transformation
is readily available) in dest[p-low].
14 Returns: The first form returns the transformed value; or dfault if no mapping is readily available.
The second form returns high.
22.4.1.2 Class template ctype_byname [locale.ctype.byname]
namespace std {
template <class charT>
class ctype_byname : public ctype<charT> {
public:
typedef typename ctype<charT>::mask mask;
explicit ctype_byname(const char*, size_t refs = 0);
explicit ctype_byname(const string&, size_t refs = 0);
protected:
~ctype_byname();
};
}
22.4.1.3 ctype specializations [facet.ctype.special]
namespace std {
template <> class ctype<char>
: public locale::facet, public ctype_base {
public:
typedef char char_type;
explicit ctype(const mask* tab = 0, bool del = false,
size_t refs = 0);
bool is(mask m, char c) const;
const char* is(const char* low, const char* high, mask* vec) const;
const char* scan_is (mask m,
const char* low, const char* high) const;
const char* scan_not(mask m,
const char* low, const char* high) const;
char toupper(char c) const;
const char* toupper(char* low, const char* high) const;
char tolower(char c) const;
const char* tolower(char* low, const char* high) const;
§ 22.4.1.3 678

 c ISO/IEC N3242=11-0012
char widen(char c) const;
const char* widen(const char* low, const char* high, char* to) const;
char narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high, char dfault,
char* to) const;
static locale::id id;
static const size_t table_size = implementation-defined;
const mask* table() const noexcept;
static const mask* classic_table() noexcept;
protected:
~ctype();
virtual char do_toupper(char c) const;
virtual const char* do_toupper(char* low, const char* high) const;
virtual char do_tolower(char c) const;
virtual const char* do_tolower(char* low, const char* high) const;
virtual char do_widen(char c) const;
virtual const char* do_widen(const char* low,
const char* high,
char* to) const;
virtual char do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low,
const char* high,
char dfault, char* to) const;
};
}
1 A specialization ctype<char> is provided so that the member functions on type char can be implemented
inline.240 The implementation-defined value of member table_size is at least 256.
22.4.1.3.1 ctype<char> destructor [facet.ctype.char.dtor]
~ctype();
1 Effects: If the constructor’s first argument was nonzero, and its second argument was true, does delete
[] table().
22.4.1.3.2 ctype<char> members [facet.ctype.char.members]
1 In the following member descriptions, for unsigned char values v where v >= table_size, table()[v]
is assumed to have an implementation-specific value (possibly different for each such value v) without
performing the array lookup.
explicit ctype(const mask* tbl = 0, bool del = false,
size_t refs = 0);
2 Requires: tbl either 0 or an array of at least table_size elements.
3 Effects: Passes its refs argument to its base class constructor.
240) Only the char (not unsigned char and signed char) form is provided. The specialization is specified in the standard,
and not left as an implementation detail, because it affects the derivation interface for ctype<char>.
§ 22.4.1.3.2 679

 c ISO/IEC N3242=11-0012
bool is(mask m, char c) const;
const char* is(const char* low, const char* high,
mask* vec) const;
4 Effects: The second form, for all *p in the range [low,high), assigns into vec[p-low] the value
table()[ (unsigned char)*p].
5 Returns: The first form returns table()[(unsigned char)c] & m; the second form returns high.
const char* scan_is(mask m,
const char* low, const char* high) const;
6 Returns: The smallest p in the range [low,high) such that
table()[(unsigned char) *p] & m
is true.
const char* scan_not(mask m,
const char* low, const char* high) const;
7 Returns: The smallest p in the range [low,high) such that
table()[(unsigned char) *p] & m
is false.
char toupper(char c) const;
const char* toupper(char* low, const char* high) const;
8 Returns: do_toupper(c) or do_toupper(low,high), respectively.
char tolower(char c) const;
const char* tolower(char* low, const char* high) const;
9 Returns: do_tolower(c) or do_tolower(low,high), respectively.
char widen(char c) const;
const char* widen(const char* low, const char* high,
char* to) const;
10 Returns: do_widen(c) or do_widen(low, high, to), respectively.
char narrow(char c, char dfault) const;
const char* narrow(const char* low, const char* high,
char dfault, char* to) const;
11 Returns: do_narrow(c, dfault) or do_narrow(low, high, dfault, to), respectively.
const mask* table() const noexcept;
12 Returns: The first constructor argument, if it was non-zero, otherwise classic_table().
22.4.1.3.3 ctype<char> static members [facet.ctype.char.statics]
static const mask* classic_table() noexcept;
1 Returns: A pointer to the initial element of an array of size table_size which represents the classifications of characters in the "C" locale.
§ 22.4.1.3.3 680

 c ISO/IEC N3242=11-0012
22.4.1.3.4 ctype<char> virtual functions [facet.ctype.char.virtuals]
char do_toupper(char) const;
const char* do_toupper(char* low, const char* high) const;
char do_tolower(char) const;
const char* do_tolower(char* low, const char* high) const;
virtual char do_widen(char c) const;
virtual const char* do_widen(const char* low,
const char* high,
char* to) const;
virtual char do_narrow(char c, char dfault) const;
virtual const char* do_narrow(const char* low,
const char* high,
char dfault, char* to) const;
These functions are described identically as those members of the same name in the ctype class template (22.4.1.1.1).
22.4.1.4 Class template codecvt [locale.codecvt]
namespace std {
class codecvt_base {
public:
enum result { ok, partial, error, noconv };
};
template <class internT, class externT, class stateT>
class codecvt : public locale::facet, public codecvt_base {
public:
typedef internT intern_type;
typedef externT extern_type;
typedef stateT state_type;
explicit codecvt(size_t refs = 0);
result out(stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
result unshift(stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
result in(stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
int encoding() const noexcept;
bool always_noconv() const noexcept;
int length(stateT&, const externT* from, const externT* end,
size_t max) const;
int max_length() const noexcept;
static locale::id id;
protected:
~codecvt();
virtual result do_out(stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
§ 22.4.1.4 681

 c ISO/IEC N3242=11-0012
externT* to, externT* to_end, externT*& to_next) const;
virtual result do_in(stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
virtual result do_unshift(stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
virtual int do_encoding() const noexcept;
virtual bool do_always_noconv() const noexcept;
virtual int do_length(stateT&, const externT* from,
const externT* end, size_t max) const;
virtual int do_max_length() const noexcept;
};
}
1 The class codecvt<internT,externT,stateT> is for use when converting from one character encoding to
another, such as from wide characters to multibyte characters or between wide character encodings such as
Unicode and EUC.
2 The stateT argument selects the pair of character encodings being mapped between.
3 The specializations required in Table 81 (22.3.1.1.1) convert the implementation-defined native character
set. codecvt<char, char, mbstate_t> implements a degenerate conversion; it does not convert at all. The
specialization codecvt<char16_t, char, mbstate_t> converts between the UTF-16 and UTF-8 encoding
schemes, and the specialization codecvt <char32_t, char, mbstate_t> converts between the UTF-32 and
UTF-8 encoding schemes. codecvt<wchar_t,char,mbstate_t> converts between the native character sets
for narrow and wide characters. Specializations on mbstate_t perform conversion between encodings known
to the library implementor. Other encodings can be converted by specializing on a user-defined stateT type.
The stateT object can contain any state that is useful to communicate to or from the specialized do_in or
do_out members.
22.4.1.4.1 codecvt members [locale.codecvt.members]
result out(stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
1 Returns: do_out(state, from, from_end, from_next, to, to_end, to_next)
result unshift(stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
2 Returns: do_unshift(state, to, to_end, to_next)
result in(stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
3 Returns: do_in(state, from, from_end, from_next, to, to_end, to_next)
int encoding() const noexcept;
4 Returns: do_encoding()
bool always_noconv() const noexcept;
5 Returns: do_always_noconv()
int length(stateT& state, const externT* from, const externT* from_end,
§ 22.4.1.4.1 682

 c ISO/IEC N3242=11-0012
size_t max) const;
6 Returns: do_length(state, from,from_end,max)
int max_length() const noexcept;
7 Returns: do_max_length()
22.4.1.4.2 codecvt virtual functions [locale.codecvt.virtuals]
result do_out(stateT& state,
const internT* from, const internT* from_end, const internT*& from_next,
externT* to, externT* to_end, externT*& to_next) const;
result do_in(stateT& state,
const externT* from, const externT* from_end, const externT*& from_next,
internT* to, internT* to_end, internT*& to_next) const;
1 Requires: (from<=from_end && to<=to_end) well-defined and true; state initialized, if at the beginning of a sequence, or else equal to the result of converting the preceding characters in the sequence.
2 Effects: Translates characters in the source range [from,from_end), placing the results in sequential
positions starting at destination to. Converts no more than (from_end-from) source elements, and
stores no more than (to_end-to) destination elements.
Stops if it encounters a character it cannot convert. It always leaves the from_next and to_next
pointers pointing one beyond the last element successfully converted. If returns noconv, internT
and externT are the same type and the converted sequence is identical to the input sequence [from,
from_next). to_next is set equal to to, the value of state is unchanged, and there are no changes
to the values in [to, to_end).
3 A codecvt facet that is used by basic_filebuf (27.9) shall have the property that if
do_out(state, from, from_end, from_next, to, to_end, to_next)
would return ok, where from != from_end, then
do_out(state, from, from + 1, from_next, to, to_end, to_next)
shall also return ok, and that if
do_in(state, from, from_end, from_next, to, to_end, to_next)
would return ok, where to != to_end, then
do_in(state, from, from_end, from_next, to, to + 1, to_next)
shall also return ok.241 [ Note: As a result of operations on state, it can return ok or partial and
set from_next == from and to_next != to. — end note ]
4 Remarks: Its operations on state are unspecified. [ Note: This argument can be used, for example, to
maintain shift state, to specify conversion options (such as count only), or to identify a cache of seek
offsets. — end note ]
5 Returns: An enumeration value, as summarized in Table 83.
241) Informally, this means that basic_filebuf assumes that the mappings from internal to external characters is 1 to N: a
codecvt facet that is used by basic_filebuf must be able to translate characters one internal character at a time.
§ 22.4.1.4.2 683

 c ISO/IEC N3242=11-0012
Table 83 — do_in/do_out result values
Value Meaning
ok completed the conversion
partial not all source characters converted
error encountered a character in [from,from_end) that
it could not convert
noconv internT and externT are the same type, and input sequence is identical to converted sequence
A return value of partial, if (from_next==from_end), indicates that either the destination sequence
has not absorbed all the available destination elements, or that additional source elements are needed
before another destination element can be produced.
result do_unshift(stateT& state,
externT* to, externT* to_end, externT*& to_next) const;
6 Requires: (to <= to_end) well defined and true; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the sequence.
7 Effects: Places characters starting at to that should be appended to terminate a sequence when the
current stateT is given by state.242 Stores no more than (to_end-to) destination elements, and
leaves the to_next pointer pointing one beyond the last element successfully stored.
8 Returns: An enumeration value, as summarized in Table 84.
Table 84 — do_unshift result values
Value Meaning
ok completed the sequence
partial space for more than to_end-to destination elements
was needed to terminate a sequence given the value of
state
error an unspecified error has occurred
noconv no termination is needed for this state_type
int do_encoding() const noexcept;
9 Returns:-1 if the encoding of the externT sequence is state-dependent; else the constant number of
externT characters needed to produce an internal character; or 0 if this number is not a constant243.
bool do_always_noconv() const noexcept;
10 Returns: true if do_in() and do_out() return noconv for all valid argument values. codecvt<char,
char, mbstate_t> returns true.
int do_length(stateT& state, const externT* from, const externT* from_end,
size_t max) const;
11 Requires: (from<=from_end) well-defined and true; state initialized, if at the beginning of a sequence,
or else equal to the result of converting the preceding characters in the sequence.
242) Typically these will be characters to return the state to stateT()
243) If encoding() yields -1, then more than max_length() externT elements may be consumed when producing a single internT
character, and additional externT elements may appear at the end of a sequence after those that yield the final internT character.
§ 22.4.1.4.2 684

 c ISO/IEC N3242=11-0012
12 Effects: The effect on the state argument is “as if” it called do_in(state, from, from_end, from,
to, to+max, to) for to pointing to a buffer of at least max elements.
13 Returns: (from_next-from) where from_next is the largest value in the range [from,from_end] such
that the sequence of values in the range [from,from_next) represents max or fewer valid complete
characters of type internT. The specialization codecvt<char, char, mbstate_t>, returns the lesser
of max and (from_end-from).
int do_max_length() const noexcept;
14 Returns: The maximum value that do_length(state, from, from_end, 1) can return for any
valid range [from, from_end) and stateT value state. The specialization codecvt<char, char,
mbstate_t>::do_max_length() returns 1.
22.4.1.5 Class template codecvt_byname [locale.codecvt.byname]
namespace std {
template <class internT, class externT, class stateT>
class codecvt_byname : public codecvt<internT, externT, stateT> {
public:
explicit codecvt_byname(const char*, size_t refs = 0);
explicit codecvt_byname(const string&, size_t refs = 0);
protected:
~codecvt_byname();
};
}
22.4.2 The numeric category [category.numeric]
1 The classes num_get<> and num_put<> handle numeric formatting and parsing. Virtual functions are provided for several numeric types. Implementations may (but are not required to) delegate extraction of
smaller types to extractors for larger types.244
2 All specifications of member functions for num_put and num_get in the subclauses of 22.4.2 only apply to the
specializations required in Tables 81 and 82 (22.3.1.1.1), namely num_get<char>, num_get<wchar_t>, num_-
get<C, InputIterator>, num_put<char>, num_put<wchar_t>, and num_put<C,OutputIterator>. These
specializations refer to the ios_base& argument for formatting specifications (22.4), and to its imbued locale
for the numpunct<> facet to identify all numeric punctuation preferences, and also for the ctype<> facet to
perform character classification.
3 Extractor and inserter members of the standard iostreams use num_get<> and num_put<> member functions
for formatting and parsing numeric values (27.7.2.2.1, 27.7.3.6.1).
22.4.2.1 Class template num_get [locale.num.get]
namespace std {
template <class charT, class InputIterator = istreambuf_iterator<charT> >
class num_get : public locale::facet {
public:
typedef charT char_type;
typedef InputIterator iter_type;
explicit num_get(size_t refs = 0);
244) Parsing "-1" correctly into, e.g., an unsigned short requires that the corresponding member get() at least extract the
sign before delegating.
§ 22.4.2.1 685

 c ISO/IEC N3242=11-0012
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, bool& v) const;
iter_type get(iter_type in, iter_type end, ios_base& ,
ios_base::iostate& err, long& v) const;
iter_type get(iter_type in, iter_type end, ios_base& ,
ios_base::iostate& err, long long& v) const;}
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned short& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned int& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, unsigned long& v) const;
iter_type get(iter_type in, iter_type end, ios_base& ,
ios_base::iostate& err, unsigned long long& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, float& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, double& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, long double& v) const;
iter_type get(iter_type in, iter_type end, ios_base&,
ios_base::iostate& err, void*& v) const;
static locale::id id;
protected:
~num_get();
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, bool& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned short& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned int& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, unsigned long long& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, float& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, double& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, long double& v) const;
virtual iter_type do_get(iter_type, iter_type, ios_base&,
ios_base::iostate& err, void*& v) const;
};
}
§ 22.4.2.1 686

 c ISO/IEC N3242=11-0012
1 The facet num_get is used to parse numeric values from an input sequence such as an istream.
22.4.2.1.1 num_get members [facet.num.get.members]
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, bool& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned short& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned int& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long long& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, float& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long double& val) const;
iter_type get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, void*& val) const;
1 Returns: do_get(in, end, str, err, val).
22.4.2.1.2 num_get virtual functions [facet.num.get.virtuals]
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned short& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned int& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, unsigned long long& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, float& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, long double& val) const;
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, void*& val) const;
1 Effects: Reads characters from in, interpreting them according to str.flags(), use_facet<ctype<charT>
>(loc), and use_facet< numpunct<charT> >(loc), where loc is str.getloc().
2 The details of this operation occur in three stages
§ 22.4.2.1.2 687

 c ISO/IEC N3242=11-0012
— Stage 1: Determine a conversion specifier
— Stage 2: Extract characters from in and determine a corresponding char value for the format
expected by the conversion specification determined in stage 1.
— Stage 3: Store results
3 The details of the stages are presented below.
Stage 1: The function initializes local variables via
fmtflags flags = str .flags();
fmtflags basefield = (flags & ios_base::basefield);
fmtflags uppercase = (flags & ios_base::uppercase);
fmtflags boolalpha = (flags & ios_base::boolalpha);
For conversion to an integral type, the function determines the integral conversion specifier as
indicated in Table 85. The table is ordered. That is, the first line whose condition is true applies.
Table 85 — Integer conversions
State stdio equivalent
basefield == oct %o
basefield == hex %X
basefield == 0 %i
signed integral type %d
unsigned integral type %u
For conversions to a floating type the specifier is %g.
For conversions to void* the specifier is %p.
A length modifier is added to the conversion specification, if needed, as indicated in Table 86.
Table 86 — Length modifier
Type Length modifier
short h
unsigned short h
long l
unsigned long l
long long ll
unsigned long long ll
double l
long double L
Stage 2: If in==end then stage 2 terminates. Otherwise a charT is taken from in and local variables
are initialized as if by
char_type ct = *in ;
char c = src[find(atoms, atoms + sizeof(src) - 1, ct) - atoms];
if (ct == use_facet<numpunct<charT> >(loc).decimal_point())
c = ’.’;
bool discard =
ct == use_facet<numpunct<charT> >(loc).thousands_sep()
&& use_facet<numpunct<charT> >(loc).grouping().length() != 0;
§ 22.4.2.1.2 688

 c ISO/IEC N3242=11-0012
where the values src and atoms are defined as if by:
static const char src[] = "0123456789abcdefxABCDEFX+-";
char_type atoms[sizeof(src)];
use_facet<ctype<charT> >(loc).widen(src, src + sizeof(src), atoms);
for this value of loc.
If discard is true, then if ’.’ has not yet been accumulated, then the position of the character
is remembered, but the character is otherwise ignored. Otherwise, if ’.’ has already been
accumulated, the character is discarded and Stage 2 terminates.
If the character is either discarded or accumulated then in is advanced by ++in and processing
returns to the beginning of stage 2.
Stage 3: The sequence of chars accumulated in stage 2 (the field) is converted to a numeric value
by the rules of one of the functions declared in the header <cstdlib>:
— For a signed integer value, the function strtoll.
— For an unsigned integer value, the function strtoull.
— For a floating-point value, the function strtold.
The numeric value to be stored can be one of:
— zero, if the conversion function fails to convert the entire field. ios_base::failbit is assigned
to err.
— the most positive representable value, if the field represents a value too large positive to be
represented in val. ios_base::failbit is assigned to err.
— the most negative representable value or zero for an unsigned integer type, if the field represents a value too large negative to be represented in val. ios_base::failbit is assigned to
err.
— the converted value, otherwise.
The resultant numeric value is stored in val.
4 Digit grouping is checked. That is, the positions of discarded separators is examined for consistency with use_facet<numpunct<charT> >(loc).grouping(). If they are not consistent then ios_-
base::failbit is assigned to err.
5 In any case, if stage 2 processing was terminated by the test for in==end then err |=ios_base::eofbit
is performed.
iter_type do_get(iter_type in, iter_type end, ios_base& str,
ios_base::iostate& err, bool& val) const;
6 Effects: If (str.flags()&ios_base::boolalpha)==0 then input proceeds as it would for a long
except that if a value is being stored into val, the value is determined according to the following: If
the value to be stored is 0 then false is stored. If the value is 1 then true is stored. Otherwise true
is stored and ios_base::failbit is assigned to err.
7 Otherwise target sequences are determined “as if” by calling the members falsename() and truename()
of the facet obtained by use_facet<numpunct<charT> >(str.getloc()). Successive characters in the
range [in,end) (see 23.2.3) are obtained and matched against corresponding positions in the target
sequences only as necessary to identify a unique match. The input iterator in is compared to end
§ 22.4.2.1.2 689

 c ISO/IEC N3242=11-0012
only when necessary to obtain a character. If a target sequence is uniquely matched, val is set to the
corresponding value. Otherwise false is stored and ios_base::failbit is assigned to err.
8 The in iterator is always left pointing one position beyond the last character successfully matched.
If val is set, then err is set to str.goodbit; or to str.eofbit if, when seeking another character
to match, it is found that (in == end). If val is not set, then err is set to str.failbit; or to
(str.failbit|str.eofbit) if the reason for the failure was that (in == end). [ Example: For targets
true: "a" and false: "abb", the input sequence "a" yields val == true and err == str.eofbit;
the input sequence "abc" yields err = str.failbit, with in ending at the ’c’ element. For targets
true: "1" and false: "0", the input sequence "1" yields val == true and err == str.goodbit.
For empty targets (""), any input sequence yields err == str.failbit. — end example ]
9 Returns: in.
22.4.2.2 Class template num_put [locale.nm.put]
namespace std {
template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class num_put : public locale::facet {
public:
typedef charT char_type;
typedef OutputIterator iter_type;
explicit num_put(size_t refs = 0);
iter_type put(iter_type s, ios_base& f, char_type fill, bool v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill, long long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
unsigned long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
unsigned long long v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
double v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
long double v) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
const void* v) const;
static locale::id id;
protected:
~num_put();
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
bool v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
long v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
long long v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
unsigned long) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
unsigned long long) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
double v) const;
§ 22.4.2.2 690

 c ISO/IEC N3242=11-0012
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
long double v) const;
virtual iter_type do_put(iter_type, ios_base&, char_type fill,
const void* v) const;
};
}
1 The facet num_put is used to format numeric values to a character sequence such as an ostream.
22.4.2.2.1 num_put members [facet.num.put.members]
iter_type put(iter_type out, ios_base& str, char_type fill,
bool val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
unsigned long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
unsigned long long val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
long double val) const;
iter_type put(iter_type out, ios_base& str, char_type fill,
const void* val) const;
1 Returns: do_put(out, str, fill, val).
22.4.2.2.2 num_put virtual functions [facet.num.put.virtuals]
iter_type do_put(iter_type out, ios_base& str, char_type fill,
long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
unsigned long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
unsigned long long val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
long double val) const;
iter_type do_put(iter_type out, ios_base& str, char_type fill,
const void* val) const;
1 Effects: Writes characters to the sequence out, formatting val as desired. In the following description,
a local variable initialized with
locale loc = str.getloc();
2 The details of this operation occur in several stages:
— Stage 1: Determine a printf conversion specifier spec and determining the characters that would
be printed by printf (27.9.2) given this conversion specifier for
§ 22.4.2.2.2 691

 c ISO/IEC N3242=11-0012
printf(spec, val )
assuming that the current locale is the "C" locale.
— Stage 2: Adjust the representation by converting each char determined by stage 1 to a charT using
a conversion and values returned by members of use_facet< numpunct<charT> >(str.getloc())
— Stage 3: Determine where padding is required.
— Stage 4: Insert the sequence into the out.
3 Detailed descriptions of each stage follow.
4 Returns: out.
5
Stage 1: The first action of stage 1 is to determine a conversion specifier. The tables that describe
this determination use the following local variables
fmtflags flags = str.flags() ;
fmtflags basefield = (flags & (ios_base::basefield));
fmtflags uppercase = (flags & (ios_base::uppercase));
fmtflags floatfield = (flags & (ios_base::floatfield));
fmtflags showpos = (flags & (ios_base::showpos));
fmtflags showbase = (flags & (ios_base::showbase));
All tables used in describing stage 1 are ordered. That is, the first line whose condition is true
applies. A line without a condition is the default behavior when none of the earlier lines apply.
For conversion from an integral type other than a character type, the function determines the
integral conversion specifier as indicated in Table 87.
Table 87 — Integer conversions
State stdio equivalent
basefield == ios_base::oct %o
(basefield == ios_base::hex) && !uppercase %x
(basefield == ios_base::hex) %X
for a signed integral type %d
for an unsigned integral type %u
For conversion from a floating-point type, the function determines the floating-point conversion
specifier as indicated in Table 88.
Table 88 — Floating-point conversions
State stdio equivalent
floatfield == ios_base::fixed %f
floatfield == ios_base::scientific && !uppercase %e
floatfield == ios_base::scientific %E
floatfield == (ios_base::fixed | ios_base::scientific) && !uppercase %a
floatfield == (ios_base::fixed | ios_base::scientific) %A
!uppercase %g
otherwise %G
§ 22.4.2.2.2 692

 c ISO/IEC N3242=11-0012
For conversions from an integral or floating-point type a length modifier is added to the conversion
specifier as indicated in Table 89.
Table 89 — Length modifier
Type Length modifier
long l
long long ll
unsigned long l
unsigned long long ll
long double L
otherwise none
The conversion specifier has the following optional additional qualifiers prepended as indicated in
Table 90.
Table 90 — Numeric conversions
Type(s) State stdio equivalent
an integral type flags & showpos +
flags & showbase #
a floating-point type flags & showpos +
flags & showpoint #
For conversion from a floating-point type, if floatfield != (ios_base::fixed | ios_base::scientific),
str.precision() is specified as precision in the conversion specification. Otherwise, no precision
is specified.
For conversion from void* the specifier is %p.
The representations at the end of stage 1 consists of the char’s that would be printed by a call
of printf(s, val) where s is the conversion specifier determined above.
Stage 2: Any character c other than a decimal point(.) is converted to a charT via use_-
facet<ctype<charT> >(loc).widen( c )
A local variable punct is initialized via
const numpunct<charT>& punct = use_facet< numpunct<charT> >(str.getloc());
For arithmetic types, punct.thousands_sep() characters are inserted into the sequence as determined by the value returned by punct.do_grouping() using the method described in 22.4.3.1.2
Decimal point characters(.) are replaced by punct.decimal_point()
Stage 3: A local variable is initialized as
fmtflags adjustfield= (flags & (ios_base::adjustfield));
The location of any padding245 is determined according to Table 91.
If str.width() is nonzero and the number of charT’s in the sequence after stage 2 is less than
str.width(), then enough fill characters are added to the sequence at the position indicated
for padding to bring the length of the sequence to str.width().
245) The conversion specification #o generates a leading 0 which is not a padding character.
§ 22.4.2.2.2 693

 c ISO/IEC N3242=11-0012
Table 91 — Fill padding
State Location
adjustfield == ios_base::left pad after
adjustfield == ios_base::right pad before
adjustfield == internal and a sign occurs in
the representation
pad after the sign
adjustfield == internal and representation
after stage 1 began with 0x or 0X
pad after x or X
otherwise pad before
str.width(0) is called.
Stage 4: The sequence of charT’s at the end of stage 3 are output via
*out++ = c
iter_type do_put(iter_type out, ios_base& str, char_type fill,
bool val) const;
6 Returns: If (str.flags() & ios_base::boolalpha) == 0 returns do_put(out, str, fill, (int)val),
otherwise obtains a string s as if by
string_type s =
val ? use_facet<ctype<charT> >(loc).truename()
: use_facet<ctype<charT> >(loc).falsename();
and then inserts each character c of s into out via *out++ = c and returns out.
22.4.3 The numeric punctuation facet [facet.numpunct]
22.4.3.1 Class template numpunct [locale.numpunct]
namespace std {
template <class charT>
class numpunct : public locale::facet {
public:
typedef charT char_type;
typedef basic_string<charT> string_type;
explicit numpunct(size_t refs = 0);
char_type decimal_point() const;
char_type thousands_sep() const;
string grouping() const;
string_type truename() const;
string_type falsename() const;
static locale::id id;
protected:
~numpunct(); // virtual
virtual char_type do_decimal_point() const;
virtual char_type do_thousands_sep() const;
§ 22.4.3.1 694

 c ISO/IEC N3242=11-0012
virtual string do_grouping() const;
virtual string_type do_truename() const; // for bool
virtual string_type do_falsename() const; // for bool
};
}
1 numpunct<> specifies numeric punctuation. The specializations required in Table 81 (22.3.1.1.1), namely
numpunct<wchar_t> and numpunct<char>, provide classic "C" numeric formats, i.e., they contain information equivalent to that contained in the "C" locale or their wide character counterparts as if obtained by a
call to widen.
2 The syntax for number formats is as follows, where digit represents the radix set specified by the fmtflags
argument value, and thousands-sep and decimal-point are the results of corresponding numpunct<charT>
members. Integer values have the format:
integer ::= [sign] units
sign ::= plusminus
plusminus ::= ’+’ | ’-’
units ::= digits [thousands-sep units]
digits ::= digit [digits]
and floating-point values have:
floatval ::= [sign] units [decimal-point [digits]] [e [sign] digits] |
[sign] decimal-point digits [e [sign] digits]
e ::= ’e’ | ’E’
where the number of digits between thousands-seps is as specified by do_grouping(). For parsing, if the
digits portion contains no thousands-separators, no grouping constraint is applied.
22.4.3.1.1 numpunct members [facet.numpunct.members]
char_type decimal_point() const;
1 Returns: do_decimal_point()
char_type thousands_sep() const;
2 Returns: do_thousands_sep()
string grouping() const;
3 Returns: do_grouping()
string_type truename() const;
string_type falsename() const;
4 Returns: do_truename() or do_falsename(), respectively.
22.4.3.1.2 numpunct virtual functions [facet.numpunct.virtuals]
char_type do_decimal_point() const;
1 Returns: A character for use as the decimal radix separator. The required specializations return ’.’
or L’.’.
char_type do_thousands_sep() const;
§ 22.4.3.1.2 695

 c ISO/IEC N3242=11-0012
2 Returns: A character for use as the digit group separator. The required specializations return ’,’ or
L’,’.
string do_grouping() const;
3 Returns: A basic_string<char> vec used as a vector of integer values, in which each element vec[i]
represents the number of digits246 in the group at position i, starting with position 0 as the rightmost
group. If vec.size() <= i, the number is the same as group (i-1); if (i<0 || vec[i]<=0 ||
vec[i]==CHAR_MAX), the size of the digit group is unlimited.
4 The required specializations return the empty string, indicating no grouping.
string_type do_truename() const;
string_type do_falsename() const;
5 Returns: A string representing the name of the boolean value true or false, respectively.
6 In the base class implementation these names are "true" and "false", or L"true" and L"false".
22.4.3.2 Class template numpunct_byname [locale.numpunct.byname]
namespace std {
template <class charT>
class numpunct_byname : public numpunct<charT> {
// this class is specialized for char and wchar_t.
public:
typedef charT char_type;
typedef basic_string<charT> string_type;
explicit numpunct_byname(const char*, size_t refs = 0);
explicit numpunct_byname(const string&, size_t refs = 0);
protected:
~numpunct_byname();
};
}
22.4.4 The collate category [category.collate]
22.4.4.1 Class template collate [locale.collate]
namespace std {
template <class charT>
class collate : public locale::facet {
public:
typedef charT char_type;
typedef basic_string<charT> string_type;
explicit collate(size_t refs = 0);
int compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
string_type transform(const charT* low, const charT* high) const;
long hash(const charT* low, const charT* high) const;
static locale::id id;
246) Thus, the string "\003" specifies groups of 3 digits each, and "3" probably indicates groups of 51 (!) digits each, because
51 is the ASCII value of "3".
§ 22.4.4.1 696

 c ISO/IEC N3242=11-0012
protected:
~collate();
virtual int do_compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
virtual string_type do_transform(const charT* low, const charT* high) const;
virtual long do_hash (const charT* low, const charT* high) const;
};
}
1 The class collate<charT> provides features for use in the collation (comparison) and hashing of strings.
A locale member function template, operator(), uses the collate facet to allow a locale to act directly
as the predicate argument for standard algorithms (Clause 25) and containers operating on strings. The
specializations required in Table 81 (22.3.1.1.1), namely collate<char> and collate<wchar_t>, apply
lexicographic ordering (25.4.8).
2 Each function compares a string of characters *p in the range [low,high).
22.4.4.1.1 collate members [locale.collate.members]
int compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
1 Returns: do_compare(low1, high1, low2, high2)
string_type transform(const charT* low, const charT* high) const;
2 Returns: do_transform(low, high)
long hash(const charT* low, const charT* high) const;
3 Returns: do_hash(low, high)
22.4.4.1.2 collate virtual functions [locale.collate.virtuals]
int do_compare(const charT* low1, const charT* high1,
const charT* low2, const charT* high2) const;
1 Returns: 1 if the first string is greater than the second, -1 if less, zero otherwise. The specializations required in Table 81 (22.3.1.1.1), namely collate<char> and collate<wchar_t>, implement a
lexicographical comparison (25.4.8).
string_type do_transform(const charT* low, const charT* high) const;
2 Returns: A basic_string<charT> value that, compared lexicographically with the result of calling
transform() on another string, yields the same result as calling do_compare() on the same two
strings.247
long do_hash(const charT* low, const charT* high) const;
3 Returns: An integer value equal to the result of calling hash() on any other string for which do_-
compare() returns 0 (equal) when passed the two strings. [ Note: The probability that the result
equals that for another string which does not compare equal should be very small, approaching
(1.0/numeric_limits<unsigned long>::max()). — end note ]
247) This function is useful when one string is being compared to many other strings.
§ 22.4.4.1.2 697

 c ISO/IEC N3242=11-0012
22.4.4.2 Class template collate_byname [locale.collate.byname]
namespace std {
template <class charT>
class collate_byname : public collate<charT> {
public:
typedef basic_string<charT> string_type;
explicit collate_byname(const char*, size_t refs = 0);
explicit collate_byname(const string&, size_t refs = 0);
protected:
~collate_byname();
};
}
22.4.5 The time category [category.time]
1 Templates time_get<charT,InputIterator> and time_put<charT,OutputIterator> provide date and
time formatting and parsing. All specifications of member functions for time_put and time_get in the
subclauses of 22.4.5 only apply to the specializations required in Tables 81 and 82 (22.3.1.1.1). Their
members use their ios_base&, ios_base::iostate&, and fill arguments as described in (22.4), and the
ctype<> facet, to determine formatting details.
22.4.5.1 Class template time_get [locale.time.get]
namespace std {
class time_base {
public:
enum dateorder { no_order, dmy, mdy, ymd, ydm };
};
template <class charT, class InputIterator = istreambuf_iterator<charT> >
class time_get : public locale::facet, public time_base {
public:
typedef charT char_type;
typedef InputIterator iter_type;
explicit time_get(size_t refs = 0);
dateorder date_order() const { return do_date_order(); }
iter_type get_time(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_date(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_weekday(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get_year(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm* t) const;
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, char format, char modifier = 0) const;
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, const char_type *fmt, const char_type *fmtend) const;
static locale::id id;
§ 22.4.5.1 698

 c ISO/IEC N3242=11-0012
protected:
~time_get();
virtual dateorder do_date_order() const;
virtual iter_type do_get_time(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_date(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_weekday(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_monthname(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get_year(iter_type s, iter_type end, ios_base&,
ios_base::iostate& err, tm* t) const;
virtual iter_type do_get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, char format, char modifier) const;
};
}
1 time_get is used to parse a character sequence, extracting components of a time or date into a struct
tm record. Each get member parses a format as produced by a corresponding format specifier to time_-
put<>::put. If the sequence being parsed matches the correct format, the corresponding members of the
struct tm argument are set to the values used to produce the sequence; otherwise either an error is reported
or unspecified values are assigned.248
2 If the end iterator is reached during parsing by any of the get() member functions, the member sets ios_-
base::eofbit in err.
22.4.5.1.1 time_get members [locale.time.get.members]
dateorder date_order() const;
1 Returns: do_date_order()
iter_type get_time(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
2 Returns: do_get_time(s, end, str, err, t)
iter_type get_date(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
3 Returns: do_get_date(s, end, str, err, t)
iter_type get_weekday(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
iter_type get_monthname(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
4 Returns: do_get_weekday(s, end, str, err, t) or do_get_monthname(s, end, str, err, t)
iter_type get_year(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
5 Returns: do_get_year(s, end, str, err, t)
248) In other words, user confirmation is required for reliable parsing of user-entered dates and times, but machine-generated
formats can be parsed reliably. This allows parsers to be aggressive about interpreting user variations on standard formats.
§ 22.4.5.1.1 699

 c ISO/IEC N3242=11-0012
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, char format, char modifier = 0) const;
6 Returns: do_get(s, end, f, err, t, format, modifier)
iter_type get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, const char_type *fmt, const char_type *fmtend) const;
7 Requires: [fmt,fmtend) shall be a valid range.
8 Effects: The function starts by evaluating err = ios_base::goodbit. It then enters a loop, reading
zero or more characters from s at each iteration. Unless otherwise specified below, the loop terminates
when the first of the following conditions holds:
— The expression fmt == fmtend evaluates to true.
— The expression err == ios_base::goodbit evaluates to false.
— The expression s == end evaluates to true, in which case the function evaluates err = ios_-
base::eofbit | ios_base::failbit.
— The next element of fmt is equal to ’%’, optionally followed by a modifier character, followed
by a conversion specifier character, format, together forming a conversion specification valid for
the ISO/IEC 9945 function strptime. If the number of elements in the range [fmt,fmtend) is
not sufficient to unambiguously determine whether the conversion specification is complete and
valid, the function evaluates err = ios_base::failbit. Otherwise, the function evaluates s =
do_get(s, end, f, err, t, format, modifier), where the value of modifier is ’\0’ when
the optional modifier is absent from the conversion specification. If err == ios_base::goodbit
holds after the evaluation of the expression, the function increments fmt to point just past the
end of the conversion specification and continues looping.
— The expression isspace(*fmt, f.getloc()) evaluates to true, in which case the function first
increments fmt until fmt == fmtend || !isspace(*fmt, f.getloc()) evaluates to true, then
advances s until s == end || !isspace(*s, f.getloc()) is true, and finally resumes looping.
— The next character read from s matches the element pointed to by fmt in a case-insensitive
comparison, in which case the function evaluates ++fmt, ++s and continues looping. Otherwise,
the function evaluates err = ios_base::failbit.
9 [ Note: The function uses the ctype<charT> facet installed in f’s locale to determine valid whitespace
characters. It is unspecified by what means the function performs case-insensitive comparison or
whether multi-character sequences are considered while doing so.
10 Returns: s
22.4.5.1.2 time_get virtual functions [locale.time.get.virtuals]
dateorder do_date_order() const;
1 Returns: An enumeration value indicating the preferred order of components for those date formats
that are composed of day, month, and year.249 Returns no_order if the date format specified by ’x’
contains other variable components (e.g., Julian day, week number, week day).
iter_type do_get_time(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
249) This function is intended as a convenience only, for common formats, and may return no_order in valid locales.
§ 22.4.5.1.2 700

 c ISO/IEC N3242=11-0012
2 Effects: Reads characters starting at s until it has extracted those struct tm members, and remaining
format characters, used by time_put<>::put to produce the format specified by "%H:%M:%S", or until
it encounters an error or end of sequence.
3 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid time.
iter_type do_get_date(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
4 Effects: Reads characters starting at s until it has extracted those struct tm members and remaining
format characters used by time_put<>::put to produce one of the following formats, or until it
encounters an error. The format depends on the value returned by date_order() as shown in Table 92.
Table 92 — do_get_date effects
date_order() Format
no_order "%m%d%y"
dmy "%d%m%y"
mdy "%m%d%y"
ymd "%y%m%d"
ydm "%y%d%m"
5 An implementation may also accept additional implementation-defined formats.
6 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid date.
iter_type do_get_weekday(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
iter_type do_get_monthname(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
7 Effects: Reads characters starting at s until it has extracted the (perhaps abbreviated) name of a
weekday or month. If it finds an abbreviation that is followed by characters that could match a full
name, it continues reading until it matches the full name or fails. It sets the appropriate struct tm
member accordingly.
8 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid
name.
iter_type do_get_year(iter_type s, iter_type end, ios_base& str,
ios_base::iostate& err, tm* t) const;
9 Effects: Reads characters starting at s until it has extracted an unambiguous year identifier. It is
implementation-defined whether two-digit year numbers are accepted, and (if so) what century they
are assumed to lie in. Sets the t->tm_year member accordingly.
10 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid year
identifier.
iter_type do_get(iter_type s, iter_type end, ios_base& f,
ios_base::iostate& err, tm *t, char format, char modifier) const;
11 Requires: t shall be dereferenceable.
§ 22.4.5.1.2 701

 c ISO/IEC N3242=11-0012
12 Effects: The function starts by evaluating err = ios_base::goodbit. It then reads characters starting at s until it encounters an error, or until it has extracted and assigned those struct tm members,
and any remaining format characters, corresponding to a conversion directive appropriate for the
ISO/IEC 9945 function strptime, formed by concatenating ’%’, the modifier character, when nonNUL, and the format character. When the concatenation fails to yield a complete valid directive
the function leaves the object pointed to by t unchanged and evaluates err |= ios_base::failbit.
When s == end evaluates to true after reading a character the function evaluates err |= ios_-
base::eofbit.
13 For complex conversion directives such as %c, %x, or %X, or directives that involve the optional modifiers
E or O, when the function is unable to unambiguously determine some or all struct tm members from
the input sequence [s,end), it evaluates err |= ios_base::eofbit. In such cases the values of those
struct tm members are unspecified and may be outside their valid range.
14 Remark: It is unspecified whether multiple calls to do_get() with the address of the same struct
tm object will update the current contents of the object or simply overwrite its members. Portable
programs must zero out the object before invoking the function.
15 Returns: An iterator pointing immediately beyond the last character recognized as possibly part of a
valid input sequence for the given format and modifier.
22.4.5.2 Class template time_get_byname [locale.time.get.byname]
namespace std {
template <class charT, class InputIterator = istreambuf_iterator<charT> >
class time_get_byname : public time_get<charT, InputIterator> {
public:
typedef time_base::dateorder dateorder;
typedef InputIterator iter_type;
explicit time_get_byname(const char*, size_t refs = 0);
explicit time_get_byname(const string&, size_t refs = 0);
protected:
~time_get_byname();
};
}
22.4.5.3 Class template time_put [locale.time.put]
namespace std {
template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class time_put : public locale::facet {
public:
typedef charT char_type;
typedef OutputIterator iter_type;
explicit time_put(size_t refs = 0);
// the following is implemented in terms of other member functions.
iter_type put(iter_type s, ios_base& f, char_type fill, const tm* tmb,
const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base& f, char_type fill,
const tm* tmb, char format, char modifier = 0) const;
static locale::id id;
§ 22.4.5.3 702

 c ISO/IEC N3242=11-0012
protected:
~time_put();
virtual iter_type do_put(iter_type s, ios_base&, char_type, const tm* t,
char format, char modifier) const;
};
}
22.4.5.3.1 time_put members [locale.time.put.members]
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
const charT* pattern, const charT* pat_end) const;
iter_type put(iter_type s, ios_base& str, char_type fill, const tm* t,
char format, char modifier = 0) const;
1 Effects: The first form steps through the sequence from pattern to pat_end, identifying characters
that are part of a format sequence. Each character that is not part of a format sequence is written
to s immediately, and each format sequence, as it is identified, results in a call to do_put; thus,
format elements and other characters are interleaved in the output in the order in which they appear
in the pattern. Format sequences are identified by converting each character c to a char value as
if by ct.narrow(c,0), where ct is a reference to ctype<charT> obtained from str.getloc(). The
first character of each sequence is equal to ’%’, followed by an optional modifier character mod250
and a format specifier character spec as defined for the function strftime. If no modifier character
is present, mod is zero. For each valid format sequence identified, calls do_put(s, str, fill, t,
spec, mod).
2 The second form calls do_put(s, str, fill, t, format, modifier).
3 [ Note: The fill argument may be used in the implementation-defined formats or by derivations. A
space character is a reasonable default for this argument. — end note ]
4 Returns: An iterator pointing immediately after the last character produced.
22.4.5.3.2 time_put virtual functions [locale.time.put.virtuals]
iter_type do_put(iter_type s, ios_base&, char_type fill, const tm* t,
char format, char modifier) const;
1 Effects: Formats the contents of the parameter t into characters placed on the output sequence s.
Formatting is controlled by the parameters format and modifier, interpreted identically as the format
specifiers in the string argument to the standard library function strftime().251 except that the
sequence of characters produced for those specifiers that are described as depending on the C locale
are instead implementation-defined.252
2 Returns: An iterator pointing immediately after the last character produced. [ Note: The fill argument may be used in the implementation-defined formats or by derivations. A space character is a
reasonable default for this argument. — end note ]
22.4.5.4 Class template time_put_byname [locale.time.put.byname]
250) Although the C programming language defines no modifiers, most vendors do.
251) Interpretation of the modifier argument is implementation-defined, but should follow POSIX conventions.
252) Implementations are encouraged to refer to other standards such as POSIX for these definitions.
§ 22.4.5.4 703

 c ISO/IEC N3242=11-0012
namespace std {
template <class charT, class OutputIterator = ostreambuf_iterator<charT> >
class time_put_byname : public time_put<charT, OutputIterator>
{
public:
typedef charT char_type;
typedef OutputIterator iter_type;
explicit time_put_byname(const char*, size_t refs = 0);
explicit time_put_byname(const string&, size_t refs = 0);
protected:
~time_put_byname();
};
}
22.4.6 The monetary category [category.monetary]
1 These templates handle monetary formats. A template parameter indicates whether local or international
monetary formats are to be used.
2 All specifications of member functions for money_put and money_get in the subclauses of 22.4.6 only apply
to the specializations required in Tables 81 and 82 (22.3.1.1.1). Their members use their ios_base&, ios_-
base :: iostate&, and fill arguments as described in (22.4), and the moneypunct<> and ctype<> facets,
to determine formatting details.
22.4.6.1 Class template money_get [locale.money.get]
namespace std {
template <class charT,
class InputIterator = istreambuf_iterator<charT> >
class money_get : public locale::facet {
public:
typedef charT char_type;
typedef InputIterator iter_type;
typedef basic_string<charT> string_type;
explicit money_get(size_t refs = 0);
iter_type get(iter_type s, iter_type end, bool intl,
ios_base& f, ios_base::iostate& err,
long double& units) const;
iter_type get(iter_type s, iter_type end, bool intl,
ios_base& f, ios_base::iostate& err,
string_type& digits) const;
static locale::id id;
protected:
~money_get();
virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
ios_base::iostate& err, long double& units) const;
virtual iter_type do_get(iter_type, iter_type, bool, ios_base&,
ios_base::iostate& err, string_type& digits) const;
};
}
§ 22.4.6.1 704

 c ISO/IEC N3242=11-0012
22.4.6.1.1 money_get members [locale.money.get.members]
iter_type get(iter_type s, iter_type end, bool intl,
ios_base& f, ios_base::iostate& err,
long double& quant) const;
iter_type get(s, iter_type end, bool intl, ios_base&f,
ios_base::iostate& err, string_type& quant) const;
1 Returns: do_get(s, end, intl, f, err, quant)
22.4.6.1.2 money_get virtual functions [locale.money.get.virtuals]
iter_type do_get(iter_type s, iter_type end, bool intl,
ios_base& str, ios_base::iostate& err,
long double& units) const;
iter_type do_get(iter_type s, iter_type end, bool intl,
ios_base& str, ios_base::iostate& err,
string_type& digits) const;
1 Effects: Reads characters from s to parse and construct a monetary value according to the format specified by a moneypunct<charT,Intl> facet reference mp and the character mapping specified by a ctype<charT> facet reference ct obtained from the locale returned by str.getloc(),
and str.flags(). If a valid sequence is recognized, does not change err; otherwise, sets err to
(err|str.failbit), or (err|str.failbit|str.eofbit) if no more characters are available, and
does not change units or digits. Uses the pattern returned by mp.neg_format() to parse all values.
The result is returned as an integral value stored in units or as a sequence of digits possibly preceded by a minus sign (as produced by ct.widen(c) where c is ’-’ or in the range from ’0’ through
’9’, inclusive) stored in digits. [ Example: The sequence $1,056.23 in a common United States
locale would yield, for units, 105623, or, for digits, "105623". — end example ] If mp.grouping()
indicates that no thousands separators are permitted, any such characters are not read, and parsing
is terminated at the point where they first appear. Otherwise, thousands separators are optional; if
present, they are checked for correct placement only after all format components have been read.
2 Where money_base::space or money_base::none appears as the last element in the format pattern, no
white space is consumed. Otherwise, where money_base::space appears in any of the initial elements
of the format pattern, at least one white space character is required. Where money_base::none
appears in any of the initial elements of the format pattern, white space is allowed but not required.
If (str.flags() & str.showbase) is false, the currency symbol is optional and is consumed only if
other characters are needed to complete the format; otherwise, the currency symbol is required.
3 If the first character (if any) in the string pos returned by mp.positive_sign() or the string neg
returned by mp.negative_sign() is recognized in the position indicated by sign in the format pattern,
it is consumed and any remaining characters in the string are required after all the other format
components. [ Example: If showbase is off, then for a neg value of "()" and a currency symbol of
"L", in "(100 L)" the "L" is consumed; but if neg is "-", the "L" in "-100 L" is not consumed.
— end example ] If pos or neg is empty, the sign component is optional, and if no sign is detected, the
result is given the sign that corresponds to the source of the empty string. Otherwise, the character
in the indicated position must match the first character of pos or neg, and the result is given the
corresponding sign. If the first character of pos is equal to the first character of neg, or if both strings
are empty, the result is given a positive sign.
4 Digits in the numeric monetary component are extracted and placed in digits, or into a character
buffer buf1 for conversion to produce a value for units, in the order in which they appear, preceded
§ 22.4.6.1.2 705

 c ISO/IEC N3242=11-0012
by a minus sign if and only if the result is negative. The value units is produced as if by253
for (int i = 0; i < n; ++i)
buf2[i] = src[find(atoms, atoms+sizeof(src), buf1[i]) - atoms];
buf2[n] = 0;
sscanf(buf2, "%Lf", &units);
where n is the number of characters placed in buf1, buf2 is a character buffer, and the values src and
atoms are defined as if by
static const char src[] = "0123456789-";
charT atoms[sizeof(src)];
ct.widen(src, src + sizeof(src) - 1, atoms);
5 Returns: An iterator pointing immediately beyond the last character recognized as part of a valid
monetary quantity.
22.4.6.2 Class template money_put [locale.money.put]
namespace std {
template <class charT,
class OutputIterator = ostreambuf_iterator<charT> >
class money_put : public locale::facet {
public:
typedef charT char_type;
typedef OutputIterator iter_type;
typedef basic_string<charT> string_type;
explicit money_put(size_t refs = 0);
iter_type put(iter_type s, bool intl, ios_base& f,
char_type fill, long double units) const;
iter_type put(iter_type s, bool intl, ios_base& f,
char_type fill, const string_type& digits) const;
static locale::id id;
protected:
~money_put();
virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
long double units) const;
virtual iter_type do_put(iter_type, bool, ios_base&, char_type fill,
const string_type& digits) const;
};
}
22.4.6.2.1 money_put members [locale.money.put.members]
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill,
long double quant) const;
iter_type put(iter_type s, bool intl, ios_base& f, char_type fill,
const string_type& quant) const;
1 Returns: do_put(s, intl, f, loc, quant)
253) The semantics here are different from ct.narrow.
§ 22.4.6.2.1 706

 c ISO/IEC N3242=11-0012
22.4.6.2.2 money_put virtual functions [locale.money.put.virtuals]
iter_type do_put(iter_type s, bool intl, ios_base& str,
char_type fill, long double units) const;
iter_type do_put(iter_type s, bool intl, ios_base& str,
char_type fill, const string_type& digits) const;
1 Effects: Writes characters to s according to the format specified by a moneypunct<charT,Intl> facet
reference mp and the character mapping specified by a ctype<charT> facet reference ct obtained from
the locale returned by str.getloc(), and str.flags(). The argument units is transformed into a
sequence of wide characters as if by
ct.widen(buf1, buf1 + sprintf(buf1, "%.0Lf", units), buf2)
for character buffers buf1 and buf2. If the first character in digits or buf2 is equal to ct.widen(’-’),
then the pattern used for formatting is the result of mp.neg_format(); otherwise the pattern is the
result of mp.pos_format(). Digit characters are written, interspersed with any thousands separators
and decimal point specified by the format, in the order they appear (after the optional leading minus
sign) in digits or buf2. In digits, only the optional leading minus sign and the immediately subsequent digit characters (as classified according to ct) are used; any trailing characters (including digits
appearing after a non-digit character) are ignored. Calls str.width(0).
2 Remarks: The currency symbol is generated if and only if (str.flags() & str.showbase) is nonzero.
If the number of characters generated for the specified format is less than the value returned by
str.width() on entry to the function, then copies of fill are inserted as necessary to pad to the specified width. For the value af equal to (str.flags() & str.adjustfield), if (af == str.internal)
is true, the fill characters are placed where none or space appears in the formatting pattern; otherwise
if (af == str.left) is true, they are placed after the other characters; otherwise, they are placed
before the other characters. [ Note: It is possible, with some combinations of format patterns and flag
values, to produce output that cannot be parsed using num_get<>::get. — end note ]
3 Returns: An iterator pointing immediately after the last character produced.
22.4.6.3 Class template moneypunct [locale.moneypunct]
namespace std {
class money_base {
public:
enum part { none, space, symbol, sign, value };
struct pattern { char field[4]; };
};
template <class charT, bool International = false>
class moneypunct : public locale::facet, public money_base {
public:
typedef charT char_type;
typedef basic_string<charT> string_type;
explicit moneypunct(size_t refs = 0);
charT decimal_point() const;
charT thousands_sep() const;
string grouping() const;
string_type curr_symbol() const;
string_type positive_sign() const;
§ 22.4.6.3 707

 c ISO/IEC N3242=11-0012
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;
static locale::id id;
static const bool intl = International;
protected:
~moneypunct();
virtual charT do_decimal_point() const;
virtual charT do_thousands_sep() const;
virtual string do_grouping() const;
virtual string_type do_curr_symbol() const;
virtual string_type do_positive_sign() const;
virtual string_type do_negative_sign() const;
virtual int do_frac_digits() const;
virtual pattern do_pos_format() const;
virtual pattern do_neg_format() const;
};
}
1 The moneypunct<> facet defines monetary formatting parameters used by money_get<> and money_put<>.
A monetary format is a sequence of four components, specified by a pattern value p, such that the part value
static_cast<part>(p.field[i]) determines the ith component of the format254 In the field member of
a pattern object, each value symbol, sign, value, and either space or none appears exactly once. The
value none, if present, is not first; the value space, if present, is neither first nor last.
2 Where none or space appears, white space is permitted in the format, except where none appears at the end,
in which case no white space is permitted. The value space indicates that at least one space is required at
that position. Where symbol appears, the sequence of characters returned by curr_symbol() is permitted,
and can be required. Where sign appears, the first (if any) of the sequence of characters returned by
positive_sign() or negative_sign() (respectively as the monetary value is non-negative or negative) is
required. Any remaining characters of the sign sequence are required after all other format components.
Where value appears, the absolute numeric monetary value is required.
3 The format of the numeric monetary value is a decimal number:
value ::= units [ decimal-point [ digits ]] |
decimal-point digits
if frac_digits() returns a positive value, or
value ::= units
otherwise. The symbol decimal-point indicates the character returned by decimal_point(). The other
symbols are defined as follows:
units ::= digits [ thousands-sep units ]
digits ::= adigit [ digits ]
In the syntax specification, the symbol adigit is any of the values ct.widen(c) for c in the range ’0’
through ’9’, inclusive, and ct is a reference of type const ctype<charT>& obtained as described in the
definitions of money_get<> and money_put<>. The symbol thousands-sep is the character returned by
254) An array of char, rather than an array of part, is specified for pattern::field purely for efficiency.
§ 22.4.6.3 708

 c ISO/IEC N3242=11-0012
thousands_sep(). The space character used is the value ct.widen(’ ’). White space characters are those
characters c for which ci.is(space,c) returns true. The number of digits required after the decimal point
(if any) is exactly the value returned by frac_digits().
4 The placement of thousands-separator characters (if any) is determined by the value returned by grouping(),
defined identically as the member numpunct<>::do_grouping().
22.4.6.3.1 moneypunct members [locale.moneypunct.members]
charT decimal_point() const;
charT thousands_sep() const;
string grouping() const;
string_type curr_symbol() const;
string_type positive_sign() const;
string_type negative_sign() const;
int frac_digits() const;
pattern pos_format() const;
pattern neg_format() const;
1 Each of these functions F returns the result of calling the corresponding virtual member function do_F().
22.4.6.3.2 moneypunct virtual functions [locale.moneypunct.virtuals]
charT do_decimal_point() const;
1 Returns: The radix separator to use in case do_frac_digits() is greater than zero.255
charT do_thousands_sep() const;
2 Returns: The digit group separator to use in case do_grouping() specifies a digit grouping pattern.256
string do_grouping() const;
3 Returns: A pattern defined identically as, but not necessarily equal to, the result of numpunct<charT>::do_-
grouping().257
string_type do_curr_symbol() const;
4 Returns: A string to use as the currency identifier symbol.258
string_type do_positive_sign() const;
string_type do_negative_sign() const;
5 Returns: do_positive_sign() returns the string to use to indicate a positive monetary value;259
do_negative_sign() returns the string to use to indicate a negative value.
int do_frac_digits() const;
6 Returns: The number of digits after the decimal radix separator, if any.260
pattern do_pos_format() const;
pattern do_neg_format() const;
255) In common U.S. locales this is ’.’.
256) In common U.S. locales this is ’,’.
257) To specify grouping by 3s, the value is "\003" not "3".
258) For international specializations (second template parameter true) this is typically four characters long, usually three
letters and a space.
259) This is usually the empty string.
260) In common U.S. locales, this is 2.
§ 22.4.6.3.2 709

 c ISO/IEC N3242=11-0012
7 Returns: The specializations required in Table 82 (22.3.1.1.1), namely moneypunct<char>, moneypunct<
wchar_t>, moneypunct<char,true>, and moneypunct<wchar_t,true>, return an object of type pattern
initialized to { symbol, sign, none, value }.261
22.4.6.4 Class template moneypunct_byname [locale.moneypunct.byname]
namespace std {
template <class charT, bool Intl = false>
class moneypunct_byname : public moneypunct<charT, Intl> {
public:
typedef money_base::pattern pattern;
typedef basic_string<charT> string_type;
explicit moneypunct_byname(const char*, size_t refs = 0);
explicit moneypunct_byname(const string&, size_t refs = 0);
protected:
~moneypunct_byname();
};
}
22.4.7 The message retrieval category [category.messages]
1 Class messages<charT> implements retrieval of strings from message catalogs.
22.4.7.1 Class template messages [locale.messages]
namespace std {
class messages_base {
public:
typedef int catalog;
};
template <class charT>
class messages : public locale::facet, public messages_base {
public:
typedef charT char_type;
typedef basic_string<charT> string_type;
explicit messages(size_t refs = 0);
catalog open(const basic_string<char>& fn, const locale&) const;
string_type get(catalog c, int set, int msgid,
const string_type& dfault) const;
void close(catalog c) const;
static locale::id id;
protected:
~messages();
virtual catalog do_open(const basic_string<char>&, const locale&) const;
virtual string_type do_get(catalog, int set, int msgid,
const string_type& dfault) const;
virtual void do_close(catalog) const;
261) Note that the international symbol returned by do_curr_sym() usually contains a space, itself; for example, "USD ".
§ 22.4.7.1 710

 c ISO/IEC N3242=11-0012
};
}
1 Values of type messages_base::catalog usable as arguments to members get and close can be obtained
only by calling member open.
22.4.7.1.1 messages members [locale.messages.members]
catalog open(const basic_string<char>& name, const locale& loc) const;
1 Returns: do_open(name, loc).
string_type get(catalog cat, int set, int msgid,
const string_type& dfault) const;
2 Returns: do_get(cat, set, msgid, dfault).
void close(catalog cat) const;
3 Effects: Calls do_close(cat).
22.4.7.1.2 messages virtual functions [locale.messages.virtuals]
catalog do_open(const basic_string<char>& name,
const locale& loc) const;
1 Returns: A value that may be passed to get() to retrieve a message from the message catalog identified
by the string name according to an implementation-defined mapping. The result can be used until it
is passed to close().
2 Returns a value less than 0 if no such catalog can be opened.
3 Remarks: The locale argument loc is used for character set code conversion when retrieving messages,
if needed.
string_type do_get(catalog cat, int set, int msgid,
const string_type& dfault) const;
4 Requires: cat shall be a catalog obtained from open() and not yet closed.
5 Returns: A message identified by arguments set, msgid, and dfault, according to an implementationdefined mapping. If no such message can be found, returns dfault.
void do_close(catalog cat) const;
6 Requires: cat shall be a catalog obtained from open() and not yet closed.
7 Effects: Releases unspecified resources associated with cat.
8 Remarks: The limit on such resources, if any, is implementation-defined.
22.4.7.2 Class template messages_byname [locale.messages.byname]
namespace std {
template <class charT>
class messages_byname : public messages<charT> {
public:
typedef messages_base::catalog catalog;
typedef basic_string<charT> string_type;
§ 22.4.7.2 711

 c ISO/IEC N3242=11-0012
explicit messages_byname(const char*, size_t refs = 0);
explicit messages_byname(const string&, size_t refs = 0);
protected:
~messages_byname();
};
}
22.4.8 Program-defined facets [facets.examples]
1 A C++ program may define facets to be added to a locale and used identically as the built-in facets. To
create a new facet interface, C++ programs simply derive from locale::facet a class containing a static
member: static locale::id id.
2 [ Note: The locale member function templates verify its type and storage class. — end note ]
3 [ Example: Traditional global localization is still easy:
#include <iostream>
#include <locale>
int main(int argc, char** argv) {
using namespace std;
locale::global(locale("")); // set the global locale
// imbue it on all the std streams
cin.imbue(locale());
cout.imbue(locale());
cerr.imbue(locale());
wcin.imbue(locale());
wcout.imbue(locale());
wcerr.imbue(locale());
return MyObject(argc, argv).doit();
} —
end example ]
4 [ Example: Greater flexibility is possible:
#include <iostream>
#include <locale>
int main() {
using namespace std;
cin.imbue(locale("")); // the user’s preferred locale
cout.imbue(locale::classic());
double f;
while (cin >> f) cout << f << endl;
return (cin.fail() != 0);
}
In a European locale, with input 3.456,78, output is 3456.78. — end example ]
5 This can be important even for simple programs, which may need to write a data file in a fixed format,
regardless of a user’s preference.
6 [ Example: Here is an example of the use of locales in a library interface.
// file: Date.h
#include <iosfwd>
§ 22.4.8 712

 c ISO/IEC N3242=11-0012
#include <string>
#include <locale>
class Date {
public:
Date(unsigned day, unsigned month, unsigned year);
std::string asString(const std::locale& = std::locale());
};
std::istream& operator>>(std::istream& s, Date& d);
std::ostream& operator<<(std::ostream& s, Date d);
7 This example illustrates two architectural uses of class locale.
8 The first is as a default argument in Date::asString(), where the default is the global (presumably userpreferred) locale.
9 The second is in the operators << and >>, where a locale “hitchhikes” on another object, in this case a
stream, to the point where it is needed.
// file: Date.C
#include "Date" // includes <ctime>
#include <sstream>
std::string Date::asString(const std::locale& l) {
using namespace std;
ostringstream s; s.imbue(l);
s << *this; return s.str();
}
std::istream& operator>>(std::istream& s, Date& d) {
using namespace std;
istream::sentry cerberos(s);
if (cerberos) {
ios_base::iostate err = goodbit;
struct tm t;
use_facet< time_get<char> >(s.getloc()).get_date(s, 0, s, err, &t);
if (!err) d = Date(t.tm_day, t.tm_mon + 1, t.tm_year + 1900);
s.setstate(err);
}
return s;
}
— end example ]
10 A locale object may be extended with a new facet simply by constructing it with an instance of a class
derived from locale::facet. The only member a C++ program must define is the static member id, which
identifies your class interface as a new facet.
11 [ Example: Classifying Japanese characters:
// file: <jctype>
#include <locale>
namespace My {
using namespace std;
class JCtype : public locale::facet {
public:
static locale::id id; // required for use as a new locale facet
§ 22.4.8 713

 c ISO/IEC N3242=11-0012
bool is_kanji (wchar_t c) const;
JCtype() { }
protected:
~JCtype() { }
};
}
// file: filt.C
#include <iostream>
#include <locale>
#include "jctype" // above
std::locale::id My::JCtype::id; // the static JCtype member declared above.
int main() {
using namespace std;
typedef ctype<wchar_t> wctype;
locale loc(locale(""), // the user’s preferred locale ...
new My::JCtype); // and a new feature ...
wchar_t c = use_facet<wctype>(loc).widen(’!’);
if (!use_facet<My::JCtype>(loc).is_kanji(c))
cout << "no it isn’t!" << endl;
return 0;
}
12 The new facet is used exactly like the built-in facets. — end example ]
13 [ Example: Replacing an existing facet is even easier. Here we do The code does not define a member id
because we are it is reusing the numpunct<charT> facet interface:
// file: my_bool.C
#include <iostream>
#include <locale>
#include <string>
namespace My {
using namespace std;
typedef numpunct_byname<char> cnumpunct;
class BoolNames : public cnumpunct {
protected:
string do_truename() const { return "Oui Oui!"; }
string do_falsename() const { return "Mais Non!"; }
~BoolNames() { }
public:
BoolNames(const char* name) : cnumpunct(name) { }
};
}
int main(int argc, char** argv) {
using namespace std;
// make the user’s preferred locale, except for...
locale loc(locale(""), new My::BoolNames(""));
cout.imbue(loc);
cout << boolalpha << "Any arguments today? " << (argc > 1) << endl;
return 0;
}
§ 22.4.8 714

 c ISO/IEC N3242=11-0012
— end example ]
22.5 Standard code conversion facets [locale.stdcvt]
1 The header <codecvt> provides code conversion facets for various character encodings.
2 Header <codecvt> synopsis
namespace std {
enum codecvt_mode {
consume_header = 4,
generate_header = 2,
little_endian = 1
};
template<class Elem, unsigned long Maxcode = 0x10ffff,
codecvt_mode Mode = (codecvt_mode)0>
class codecvt_utf8
: public codecvt<Elem, char, mbstate_t> {
// unspecified
};
template<class Elem, unsigned long Maxcode = 0x10ffff,
codecvt_mode Mode = (codecvt_mode)0>
class codecvt_utf16
: public codecvt<Elem, char, mbstate_t> {
// unspecified
};
template<class Elem, unsigned long Maxcode = 0x10ffff,
codecvt_mode Mode = (codecvt_mode)0>
class codecvt_utf8_utf16
: public codecvt<Elem, char, mbstate_t> {
// unspecified
};
}
3 For each of the three code conversion facets codecvt_utf8, codecvt_utf16, and codecvt_utf8_utf16:
— Elem is the wide-character type, such as wchar_t, char16_t, or char32_t.
— Maxcode is the largest wide-character code that the facet will read or write without reporting a conversion error.
— If (Mode & consume_header), the facet shall consume an initial header sequence, if present, when
reading a multibyte sequence to determine the endianness of the subsequent multibyte sequence to be
read.
— If (Mode & generate_header), the facet shall generate an initial header sequence when writing a
multibyte sequence to advertise the endianness of the subsequent multibyte sequence to be written.
— If (Mode & little_endian), the facet shall generate a multibyte sequence in little-endian order, as
opposed to the default big-endian order.
4 For the facet codecvt_utf8:
— The facet shall convert between UTF-8 multibyte sequences and UCS2 or UCS4 (depending on the
size of Elem) within the program.
§ 22.5 715

 c ISO/IEC N3242=11-0012
— Endianness shall not affect how multibyte sequences are read or written.
— The multibyte sequences may be written as either a text or a binary file.
5 For the facet codecvt_utf16:
— The facet shall convert between UTF-16 multibyte sequences and UCS2 or UCS4 (depending on the
size of Elem) within the program.
— Multibyte sequences shall be read or written according to the Mode flag, as set out above.
— The multibyte sequences may be written only as a binary file. Attempting to write to a text file
produces undefined behavior.
6 For the facet codecvt_utf8_utf16:
— The facet shall convert between UTF-8 multibyte sequences and UTF-16 (one or two 16-bit codes)
within the program.
— Endianness shall not affect how multibyte sequences are read or written.
— The multibyte sequences may be written as either a text or a binary file.
See also: ISO/IEC 10646-1:1993.
22.6 C library locales [c.locales]
1 Table 93 describes header <clocale>.
Table 93 — Header <clocale> synopsis
Type Name(s)
Macros: LC_ALL LC_COLLATE LC_CTYPE
LC_MONETARY LC_NUMERIC LC_TIME
NULL
Struct: lconv
Functions: localeconv setlocale
2 The contents are the same as the Standard C library header <locale.h>.
3 Calls to the function setlocale may introduce a data race (17.6.5.9) with other calls to setlocale or with
calls to the functions listed in Table 94.
Table 94 — Potential setlocale data races
fprintf isprint iswdigit localeconv tolower
fscanf ispunct iswgraph mblen toupper
isalnum isspace iswlower mbstowcs towlower
isalpha isupper iswprint mbtowc towupper
isblank iswalnum iswpunct setlocale wcscoll
iscntrl iswalpha iswspace strcoll wcstod
isdigit iswblank iswupper strerror wcstombs
isgraph iswcntrl iswxdigit strtod wcsxfrm
islower iswctype isxdigit strxfrm wctomb
See also: ISO C Clause 7.4.
§ 22.6 716

 c ISO/IEC N3242=11-0012
23 Containers library [containers]
23.1 General [containers.general]
1 This Clause describes components that C++ programs may use to organize collections of information.
2 The following subclauses describe container requirements, and components for sequence containers and
associative containers, as summarized in Table 95.
Table 95 — Containers library summary
Subclause Header(s)
23.2 Requirements
23.3 Sequence containers <array>
<deque>
<forward_list>
<list>
<vector>
23.4 Associative containers <map>
<set>
23.5 Unordered associative containers <unordered_map>
<unordered_set>
23.6 Container adaptors <queue>
<stack>
23.2 Container requirements [container.requirements]
23.2.1 General container requirements [container.requirements.general]
1 Containers are objects that store other objects. They control allocation and deallocation of these objects
through constructors, destructors, insert and erase operations.
2 All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the
contained objects. [ Example: the copy constructor of type vector <vector<int> > has linear complexity,
even though the complexity of copying each contained vector<int> is itself linear. — end example ]
3 For the components affected by this subclause that declare an allocator_type, objects stored in these
components shall be constructed using the allocator_traits<allocator_type>::construct function and
destroyed using the allocator_traits<allocator_type>::destroy function (20.6.8.2). These functions
are called only for the container’s element type, not for internal types used by the container. [ Note: This
means, for example, that a node-based container might need to construct nodes containing aligned buffers
and call construct to place the element into the buffer. — end note ]
4 In Tables 96 and 97, X denotes a container class containing objects of type T, a and b denote values of type
X, u denotes an identifier, r denotes a non-const value of type X, and rv denotes a non-const rvalue of type
X.
§ 23.2.1 717

 c ISO/IEC N3242=11-0012
Table 96 — Container requirements
Expression Return type Operational Assertion/note Complexity
semantics pre-/post-condition
X::value_-
type
T Requires: T is
Destructible
compile time
X::reference lvalue of T compile time
X::const_-
reference
const lvalue of
T
compile time
X::iterator iterator type
whose value
type is T
any iterator category
that meets the
forward iterator
requirements.
convertible to
X::const_iterator.
compile time
X::const_-
iterator
constant
iterator type
whose value
type is T
any iterator category
that meets the
forward iterator
requirements.
compile time
X::difference_type
signed integral
integer type
is identical to the
difference type of
X::iterator and
X::const_iterator
compile time
X::size_type unsigned
integral
integer type
size_type can
represent any
non-negative value of
difference_type
compile time
X u; post: u.empty()
returns true
constant
X() post: X().empty()
returns true
constant
X(a) Requires:T is
CopyInsertable into
X (see below).
post: a == X(a).
linear
X u(a)
X u = a;
Requires:T is
CopyInsertable into
X (see below).
post: u == a
linear
X u(rv)
X u = rv
post: u shall be
equal to the value
that rv had before
this construction
(Note B)
a = rv X& All existing elements
of a are either move
assigned to or
destroyed
a shall be equal to
the value that rv
had before this
assignment
linear
§ 23.2.1 718

 c ISO/IEC N3242=11-0012
Table 96 — Container requirements (continued)
Expression Return type Operational Assertion/note Complexity
semantics pre-/post-condition
(&a)->∼X() void note: the destructor
is applied to every
element of a; all the
memory is
deallocated.
linear
a.begin() iterator;
const_-
iterator for
constant a
constant
a.end() iterator;
const_-
iterator for
constant a
constant
a.cbegin() const_-
iterator
const_cast<X
const&>(a).begin();
constant
a.cend() const_-
iterator
const_cast<X
const&>(a).end();
constant
a == b convertible to
bool
== is an equivalence
relation.
distance(a.begin(),
a.end()) ==
distance(b.begin(),
b.end()) &&
equal(a.begin(),
a.end(),
b.begin())
Requires: T is
EqualityComparable
linear
a != b convertible to
bool
Equivalent to: !(a
== b)
linear
a.swap(b) void exchanges the
contents of a and b
(Note A)
swap(a, b) void a.swap(b) (Note A)
r = a X& post: r == a. linear
a.size() size_type distance(a.begin(),
a.end())
constant
a.max_size() size_type distance(begin(),
end()) for the
largest possible
container
constant
a.empty() convertible to
bool
a.begin() ==
a.end()
constant
Notes: the algorithms equal() and lexicographical_compare() are is defined in Clause 25. Those entries
marked “(Note A)” or “(Note B)” have linear complexity for array and have constant complexity for all
other standard containers.
5 The member function size() returns the number of elements in the container. The number of elements is
§ 23.2.1 719

 c ISO/IEC N3242=11-0012
defined by the rules of constructors, inserts, and erases.
6 begin() returns an iterator referring to the first element in the container. end() returns an iterator which
is the past-the-end value for the container. If the container is empty, then begin() == end();
In the expressions
i == j
i != j
i < j
i <= j
i >= j
i > j
i - j
where i and j denote objects of a container’s iterator type, either or both may be replaced by an object
of the container’s const_iterator type referring to the same element with no change in semantics.
7 Unless otherwise specified, all containers defined in this clause obtain memory using an allocator (see 17.6.3.5).
Copy constructors for these container types obtain an allocator by calling allocator_traits<allocator_-
type>::select_on_container_copy_construction on their first parameters. Move constructors obtain an
allocator by move construction of from the allocator belonging to the container being moved. Such move
construction of the allocator shall not exit via an exception. All other constructors for these container types
take an Allocator& argument (17.6.3.5), an allocator whose value type is the same as the container’s value
type. [ Note: If an invocation of a constructor uses the default value of an optional allocator argument, then
the Allocator type must support value initialization. — end note ] A copy of this allocator is used for any
memory allocation performed, by these constructors and by all member functions, during the lifetime of each
container object or until the allocator is replaced. The allocator may be replaced only via assignment or
swap(). Allocator replacement is performed by copy assignment, move assignment, or swapping of the allocator only if allocator_traits<allocator_type>::propagate_on_container_copy_assignment::value,
allocator_traits<allocator_type>::propagate_on_container_move_assignment::value, or allocator_-
traits<allocator_type>::propagate_on_container_swap::value is true within the implementation of
the corresponding container operation. The behavior of a call to a container’s swap function is undefined
unless the objects being swapped have allocators that compare equal or allocator_traits<allocator_-
type>::propagate_on_container_swap::value is true. In all container types defined in this Clause, the
member get_allocator() returns a copy of the allocator used to construct the container or, if that allocator
has been replaced, a copy of the most recent replacement.
8 The expression a.swap(b), for containers a and b of a standard container type other than array, shall exchange the values of a and b without invoking any move, copy, or swap operations on the individual container
elements. Any Compare, Pred, or Hash objects belonging to a and b shall be swappable and shall be exchanged by unqualified calls to non-member swap. If allocator_traits<allocator_type>::propagate_-
on_container_swap::value is true, then the allocators of a and b shall also be exchanged using an unqualified call to non-member swap. Otherwise, they shall not be swapped, and the behavior is undefined unless
a.get_allocator() == b.get_allocator(). Every iterator referring to an element in one container before
the swap shall refer to the same element in the other container after the swap. It is unspecified whether an
iterator with value a.end() before the swap will have value b.end() after the swap.
9 If the iterator type of a container belongs to the bidirectional or random access iterator categories (24.2),
the container is called reversible and satisfies the additional requirements in Table 97.
§ 23.2.1 720

 c ISO/IEC N3242=11-0012
Table 97 — Reversible container requirements
Expression Return type Assertion/note Complexity
pre-/post-condition
X::reverse_-
iterator
iterator type whose value type
is T
reverse_iterator<iterator> compile time
X::const_-
reverse_-
iterator
iterator type whose value type
is const T
reverse_iterator<const_-
iterator>
compile time
a.rbegin() reverse_iterator;
const_reverse_iterator for
constant a
reverse_iterator(end()) constant
a.rend() reverse_iterator;
const_reverse_iterator for
constant a
reverse_iterator(begin()) constant
a.crbegin(); const_reverse_iterator const_cast<X
const&>(a).rbegin();
constant
a.crend(); const_reverse_iterator const_cast<X
const&>(a).rend();
constant
10 Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.3.4, and 23.3.6.5) all container types defined in this
Clause meet the following additional requirements:
— if an exception is thrown by an insert() function while inserting a single element, that function has
no effects.
— if an exception is thrown by a push_back() or push_front() function, that function has no effects.
— no erase(), clear(), pop_back() or pop_front() function throws an exception.
— no copy constructor or assignment operator of a returned iterator throws an exception.
— no swap() function throws an exception.
— no swap() function invalidates any references, pointers, or iterators referring to the elements of the
containers being swapped. [ Note: The end() iterator does not refer to any element, so it may be
invalidated. — end note ]
11 Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a
container member function or passing a container as an argument to a library function shall not invalidate
iterators to, or change the values of, objects within that container.
12 Table 98 lists operations that are provided for some types of containers but not others. Those containers
for which the listed operations are provided shall implement the semantics described in Table 98 unless
otherwise stated.
§ 23.2.1 721

 c ISO/IEC N3242=11-0012
Table 98 — Optional container operations
Expression Return type Operational Assertion/note Complexity
semantics pre-/post-condition
a < b convertible to
bool
lexicographical_-
compare(
a.begin(),
a.end(),
b.begin(),
b.end())
pre: < is defined for
values of T. < is a
total ordering
relationship.
linear
a > b convertible to
bool
b < a linear
a <= b convertible to
bool
!(a > b) linear
a >= b convertible to
bool
!(a < b) linear
Note: the algorithm lexicographical_compare() is defined in Clause 25.
13 All of the containers defined in this Clause and in (21.4) except array meet the additional requirements of
an allocator-aware container, as described in Table 99.
Given a container type X having an allocator_type of identical to A and a value_type of identical to T
and given an lvalue m of type A, a pointer p of type T*, a value an expression v of type T, and a value rv of
type rvalue of an rvalue rv of type T, the following terms are defined. (If X is not allocator-aware, the terms
below are defined as if A were std::allocator<T>.)
— T is CopyInsertable into X means that the following expression is well-formed:
allocator_traits<A>::construct(m, p, v);
— T is MoveInsertable into X means that the following expression is well-formed:
allocator_traits<A>::construct(m, p, rv);
— T is EmplaceConstructible into X from args, for zero or more arguments args, means that the
following expression is well-formed:
allocator_traits<A>::construct(m, p, args);
[ Note: A container calls allocator_traits<A>::construct(m, p, args) to construct an element at p
using args. The default construct in std::allocator will call ::new((void*)p) T(args), but specialized
allocators may choose a different definition. — end note ]
14 In Table 99, X denotes an allocator-aware container class with a value_type of T using allocator of type A,
u denotes a variable, a and b denote non-const lvalues of type X, t denotes an lvalue or a const rvalue of
type X, rv denotes a non-const rvalue of type X, m is a value of type A, and Q is an allocator type.
§ 23.2.1 722

 c ISO/IEC N3242=11-0012
Table 99 — Allocator-aware container requirements
Expression Return type Assertion/note Complexity
pre-/post-condition
allocator_-
type
A Requires:allocator_-
type::value_type is the same
as X::value_type.
compile time
get_-
allocator()
A constant
X() Requires: A is
DefaultConstructible.
constant
X u; post: u.empty() returns true,
u.get_allocator() == A()
X(m) post: u.empty() returns true, constant
X u(m); u.get_allocator() == m
X(t, m) Requires: T is CopyInsertable
into X.
linear
X u(t, m); post: u == t,
get_allocator() == m
X(rv)
X u(rv)
Requires: move construction of
A shall not exit via an
exception.
post: u shall have the same
elements as rv had before this
construction; the value of
get_allocator() shall be the
same as the value of
rv.get_allocator() before
this construction.
constant
X(rv, m) Requires: T is MoveInsertable
into X.
constant if m
== rv.get_-
allocator(),
otherwise
linear
X u(rv, m); post: u shall have the same
elements, or copies of the
elements, that rv had before
this construction,
get_allocator() == m
a = t X& Requires: T is CopyInsertable
into X and CopyAssignable.
post: a == t
linear
§ 23.2.1 723

 c ISO/IEC N3242=11-0012
Table 99 — Allocator-aware container requirements (continued)
Expression Return type Assertion/note Complexity
pre-/post-condition
a = rv X& Requires: If allocator_-
traits<allocator_type>
::propagate_on_container_-
move_assignment::value is
false, T is MoveInsertable
into X and MoveAssignable.
All existing elements of a are
either move assigned to or
destroyed.
post: a shall be equal to the
value that rv had before this
assignment.
linear
a.swap(b) void exchanges the contents of a and
b
constant
23.2.2 Container data races [container.requirements.dataraces]
1 For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be
const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at
and, except in associative or unordered associative containers, operator[].
2 Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting vector<bool>, are modified concurrently.
3 [ Note: For a vector<int> x with a size greater than one, x[1] = 5 and *x.begin() = 10 can be executed
concurrently without a data race, but x[0] = 5 and *x.begin() = 10 executed concurrently may result in
a data race. As an exception to the general rule, for a vector<bool> y, y[0] = true may race with y[1]
= true. — end note ]
23.2.3 Sequence containers [sequence.reqmts]
1 A sequence container organizes a finite set of objects, all of the same type, into a strictly linear arrangement.
The library provides four basic kinds of sequence containers: vector, forward_list, list, and deque. In
addition, array is provided as a sequence container which provides limited sequence operations because it
has a fixed number of elements. The library also provides container adaptors that make it easy to construct
abstract data types, such as stacks or queues, out of the basic sequence container kinds (or out of other
kinds of sequence containers that the user might define).
2 The sequence containers offer the programmer different complexity trade-offs and should be used accordingly.
vector or array is the type of sequence container that should be used by default. list or forward_list
should be used when there are frequent insertions and deletions from the middle of the sequence. deque is
the data structure of choice when most insertions and deletions take place at the beginning or at the end of
the sequence.
3 In Tables 100 and 101, X denotes a sequence container class, a denotes a value of X containing elements
of type T, A denotes X::allocator_type if it exists and std::allocator<T> if it doesn’t, i and j denote
iterators satisfying input iterator requirements and refer to elements implicitly convertible to value_type,
[i, j) denotes a valid range, il designates an object of type initializer_list<value_type>, n denotes
§ 23.2.3 724

 c ISO/IEC N3242=11-0012
a value of X::size_type, p denotes a valid const iterator to a, q denotes a valid dereferenceable const
iterator to a, [q1, q2) denotes a valid range of const iterators in a, t denotes an lvalue or a const rvalue of
X::value_type, and rv denotes a non-const rvalue of X::value_type. Args denotes a template parameter
pack; args denotes a function parameter pack with the pattern Args&&.
4 The complexities of the expressions are sequence dependent.
Table 100 — Sequence container requirements (in addition to container)
Expression Return type Assertion/note
pre-/post-condition
X(n, t)
X a(n, t)
Requires:T shall be CopyInsertable into X.
post: distance(begin(), end()) == n
Constructs a sequence container with n copies
of t
X(i, j)
X a(i, j)
Requires: T shall be EmplaceConstructible
into X from *i. For vector, if the iterator
does not meet the forward iterator
requirements (24.2.5), T shall also be
MoveInsertable into X. Each iterator in the
range [i,j) shall be dereferenced exactly
once.
post: distance(begin(), end()) ==
distance(i, j)
Constructs a sequence container equal to the
range [i, j)
X(il); Equivalent to X(il.begin(), il.end())
a = il; X& Requires: T is CopyInsertable into X and
CopyAssignable. Assigns the range
[il.begin(),il.end()) into a. All existing
elements of a are either assigned to or
destroyed.
Returns: *this.
a.emplace(p, args); iterator Requires: T is EmplaceConstructible into X
from args. For vector and deque, T is also
MoveInsertable into X and MoveAssignable.
Effects: Inserts an object of type T
constructed with
std::forward<Args>(args)... before p.
a.insert(p,t) iterator Requires:T shall be CopyInsertable into X. For
vector and deque, T shall also be
CopyAssignable.
Effects: Inserts a copy of t before p.
a.insert(p,rv) iterator Requires: T shall be MoveInsertable into X.
For vector and deque, T shall also be
MoveAssignable.
Effects: Inserts a copy of rv before p.
a.insert(p,n,t) iterator Requires:T shall be CopyInsertable into X and
CopyAssignable.
Inserts n copies of t before p.
§ 23.2.3 725

 c ISO/IEC N3242=11-0012
Table 100 — Sequence container requirements (in addition to container) (continued)
Expression Return type Assertion/note
pre-/post-condition
a.insert(p,i,j) iterator Requires:T shall be EmplaceConstructible
into X from *i. For vector, if the iterator
does not meet the forward iterator
requirements (24.2.5), T shall also be
MoveInsertable into X and MoveAssignable.
Each iterator in the range [i,j) shall be
dereferenced exactly once.
pre: i and j are not iterators into a.
Inserts copies of elements in [i, j) before p
a.insert(p, il); iterator a.insert(p, il.begin(), il.end()).
a.erase(q) iterator Requires: For vector and deque, T shall be
MoveAssignable.
Effects: Erases the element pointed to by q
a.erase(q1,q2) iterator Requires: For vector and deque, T shall be
MoveAssignable.
Effects: Erases the elements in the range [q1,
q2).
a.clear() void Destroys all elements in a. Invalidates all
references, pointers, and iterators referring to
the elements of a and may invalidate the
past-the-end iterator.
post: a.empty() returns true
a.assign(i,j) void Requires: T shall be EmplaceConstructible
into X from *i and assignable from *i. For
vector, if the iterator does not meet the
forward iterator requirements (24.2.5), T shall
also be MoveInsertable into X.
Each iterator in the range [i,j) shall be
dereferenced exactly once.
pre: i, j are not iterators into a.
Replaces elements in a with a copy of [i, j).
a.assign(il) void a.assign(il.begin(), il.end()).
a.assign(n,t) void Requires:T shall be CopyInsertable into X and
CopyAssignable.
pre: t is not a reference into a.
Replaces elements in a with n copies of t.
5 iterator and const_iterator types for sequence containers shall be at least of the forward iterator category.
6 The iterator returned from a.insert(p, t) points to the copy of t inserted into a.
7 The iterator returned from a.insert(p, rv) points to the copy of rv inserted into a.
8 The iterator returned from a.insert(p, n, t) points to the copy of the first element inserted into a, or p
if n == 0.
§ 23.2.3 726

 c ISO/IEC N3242=11-0012
9 The iterator returned from a.insert(p, i, j) points to the copy of the first element inserted into a, or p
if i == j.
10 The iterator returned from a.insert(p, i1) points to the copy of the first element inserted into a, or p if
i1 is empty.
11 The iterator returned from a.emplace(p, args) points to the new element constructed from args into a.
12 The iterator returned from a.erase(q) points to the element immediately following q prior to the element
being erased. If no such element exists, a.end() is returned.
13 The iterator returned by a.erase(q1,q2) points to the element pointed to by q2 prior to any elements
being erased. If no such element exists, a.end() is returned.
14 For every sequence container defined in this Clause and in Clause 21:
— If the constructor
template <class InputIterator>
X(InputIterator first, InputIterator last,
const allocator_type& alloc = allocator_type())
is called with a type InputIterator that does not qualify as an input iterator, then the constructor
shall not participate in overload resolution.
— If the member functions of the forms:
template <class InputIterator> // such as insert()
rt fx1(const_iterator p, InputIterator first, InputIterator last);
template <class InputIterator> // such as append(), assign()
rt fx2(InputIterator first, InputIterator last);
template <class InputIterator> // such as replace()
rt fx3(const_iterator i1, const_iterator i2, InputIterator first, InputIterator last);
are called with a type InputIterator that does not qualify as an input iterator, then these functions
shall not participate in overload resolution.
15 The extent to which an implementation determines that a type cannot be an input iterator is unspecified,
except that as a minimum integral types shall not qualify as input iterators.
16 Table 101 lists operations that are provided for some types of sequence containers but not others. An
implementation shall provide these operations for all container types shown in the “container” column, and
shall implement them so as to take amortized constant time.
Table 101 — Optional sequence container operations
Expression Return type Operational semantics Container
a.front() reference; const_reference
for constant a
*a.begin() basic_-
string,
array, deque,
forward_-
list, list,
vector
§ 23.2.3 727

 c ISO/IEC N3242=11-0012
Table 101 — Optional sequence container operations (continued)
Expression Return type Operational semantics Container
a.back() reference; const_reference
for constant a
{ auto tmp = a.end();
--tmp;
return *tmp; }
basic_-
string,
array, deque,
list, vector
a.emplace_-
front(args)
void Prepends an object of type T
constructed with
std::forward<Args>(args)....
Requires: T shall be
EmplaceConstructible into X
from args.
deque,
forward_-
list,
list
a.emplace_-
back(args)
void Appends an object of type T
constructed with
std::forward<Args>(args)....
Requires: T shall be
EmplaceConstructible into X
from args. For vector, T shall
also be MoveInsertable into X.
deque, list,
vector
a.push_-
front(t)
void Prepends a copy of t.
Requires: T shall be
CopyInsertable into X.
deque,
forward_-
list,
list
a.push_-
front(rv)
void Prepends a copy of rv.
Requires: T shall be
MoveInsertable into X.
deque,
forward_-
list,
list
a.push_-
back(t)
void Appends a copy of t.
Requires: T shall be
CopyInsertable into X.
basic_-
string,
deque, list,
vector
a.push_-
back(rv)
void Appends a copy of rv.
Requires: T shall be
MoveInsertable into X.
basic_-
string,
deque, list,
vector
a.pop_-
front()
void Destroys the first element.
Requires: a.empty() shall be
false.
deque,
forward_-
list,
list
a.pop_back() void Destroys the last element.
Requires: a.empty() shall be
false.
basic_-
string,
deque, list,
vector
a[n] reference; const_reference
for constant a
*(a.begin() + n) basic_-
string,
array, deque,
vector
§ 23.2.3 728

 c ISO/IEC N3242=11-0012
Table 101 — Optional sequence container operations (continued)
Expression Return type Operational semantics Container
a.at(n) reference; const_reference
for constant a
*(a.begin() + n) basic_-
string,
array, deque,
vector
17 The member function at() provides bounds-checked access to container elements. at() throws out_of_-
range if n >= a.size().
23.2.4 Associative containers [associative.reqmts]
1 Associative containers provide fast retrieval of data based on keys. The library provides four basic kinds of
associative containers: set, multiset, map and multimap.
2 Each associative container is parameterized on Key and an ordering relation Compare that induces a strict
weak ordering (25.4) on elements of Key. In addition, map and multimap associate an arbitrary type T with
the Key. The object of type Compare is called the comparison object of a container.
3 The phrase “equivalence of keys” means the equivalence relation imposed by the comparison and not the
operator== on keys. That is, two keys k1 and k2 are considered to be equivalent if for the comparison
object comp, comp(k1, k2) == false && comp(k2, k1) == false. For any two keys k1 and k2 in the
same container, calling comp(k1, k2) shall always return the same value.
4 An associative container supports unique keys if it may contain at most one element for each key. Otherwise,
it supports equivalent keys. The set and map classes support unique keys; the multiset and multimap classes
support equivalent keys. For multiset and multimap, insert and erase preserve the relative ordering of
equivalent elements.
5 For set and multiset the value type is the same as the key type. For map and multimap it is equal to
pair<const Key, T>. Keys in an associative container are immutable.
6 iterator of an associative container is of the bidirectional iterator category. For associative containers where
the value type is the same as the key type, both iterator and const_iterator are constant iterators. It is
unspecified whether or not iterator and const_iterator are the same type. [ Note: iterator and const_-
iterator have identical semantics in this case, and iterator is convertible to const_iterator. Users can
avoid violating the One Definition Rule by always using const_iterator in their function parameter lists.
— end note ]
7 The associative containers meet all the requirements of Allocator-aware containers (23.2.1), except that
for map and multimap, the requirements placed on value_type in Table 96 apply instead to key_type and
mapped_type. [ Note: For example, key_type and mapped_type are sometimes required to be CopyAssignable
even though the associated value_type, pair<const key_type, mapped_type>, is not CopyAssignable.
— end note ]
8 In Table 102, X denotes an associative container class, a denotes a value of X, a_uniq denotes a value of
X when X supports unique keys, a_eq denotes a value of X when X supports multiple keys, u denotes an
identifier, i and j satisfy input iterator requirements and refer to elements implicitly convertible to value_-
type, [i,j) denotes a valid range, p denotes a valid const iterator to a, q denotes a valid dereferenceable
const iterator to a, [q1, q2) denotes a valid range of const iterators in a, il designates an object of type
§ 23.2.4 72