30 Remarks: The expression inside noexcept is equivalent to:
is_nothrow_assignable<T1&, U&&>::value &&
is_nothrow_assignable<T2&, V&&>::value
31 Requires: is_assignable<first_type&, U&&>::value is true and is_assignable<second_type&,
V&&>::value is true.
32 Effects: Assigns to first with std::forward<first_typeU>(p.first) and to second with
std::forward<second_typeV >(p.second).
33 Returns: *this.
void swap(pair& p) noexcept;
34 Remarks: The expression inside noexcept is equivalent to:
noexcept(swap(first, p.first)) &&
noexcept(swap(second, p.second))
35 Requires: first shall be swappable with (17.6.3.2) p.first and second shall be swappable with
p.second.
36 Effects: Swaps first with p.first and second with p.second.
20.3.3 Specialized algorithms [pairs.spec]
template <class T1, class T2>
bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
1 Returns: x.first == y.first && x.second == y.second.
template <class T1, class T2>
bool operator<(const pair<T1, T2>& x, const pair<T1, T2>& y);
2 Returns: x.first < y.first || (!(y.first < x.first) && x.second < y.second).
template <class T1, class T2>
bool operator!=(const pair<T1, T2>& x, const pair<T1, T2>& y);
3 Returns: !(x == y)
template <class T1, class T2>
bool operator>(const pair<T1, T2>& x, const pair<T1, T2>& y);
4 Returns: y < x
template <class T1, class T2>
bool operator>=(const pair<T1, T2>& x, const pair<T1, T2>& y);
5 Returns: !(x < y)
template <class T1, class T2>
bool operator<=(const pair<T1, T2>& x, const pair<T1, T2>& y);
6 Returns: !(y < x)
template<class T1, class T2> void swap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));
7 Effects: x.swap(y)
§ 20.3.3 501

 c ISO/IEC N3242=11-0012
template <class T1, class T2>
pair<V1, V2> make_pair(T1&& x, T2&& y) noexcept;
8 The expression inside noexcept is equivalent to:
is_nothrow_constructible<V1, T1&&>::value &&
is_nothrow_constructible<V2, T2&&>::value
9 Returns: pair<V1, V2>(std::forward<T1>(x), std::forward<T2>(y));
where V1 and V2 are determined as follows: Let Ui be decay<Ti>::type for each Ti. Then each Vi is
X& if Ui equals reference_wrapper<X>, otherwise Vi is Ui.
10 [ Example: In place of:
return pair<int, double>(5, 3.1415926); // explicit types
a C++ program may contain:
return make_pair(5, 3.1415926); // types are deduced
— end example ]
20.3.4 Tuple-like access to pair [pair.astuple]
tuple_size<pair<T1, T2> >::value
1 Returns: Integral constant expression.
2 Value: 2.
tuple_element<0, pair<T1, T2> >::type
3 Value: the type T1.
tuple_element<1, pair<T1, T2> >::type
4 Value: the type T2.
template<size_t I, class T1, class T2>
typename tuple_element<I, std::pair<T1, T2> >::type& get(pair<T1, T2>&) noexcept;
template<size_t I, class T1, class T2>
const typename tuple_element<I, std::pair<T1, T2> >::type& get(const pair<T1, T2>&) noexcept;
5 Returns: If I == 0 returns p.first; if I == 1 returns p.second; otherwise the program is ill-formed.
template<size_t I, class T1, class T2>
typename tuple_element<I, std::pair<T1, T2> >::type&& get(std::pair<T1, T2>&&) noexcept;
6 Returns: If I == 0 returns std::forward<T1&&>(p.first); if I == 1 returns std::forward<T2&&>(p.second);
otherwise the program is ill-formed.
20.3.5 Piecewise construction [pair.piecewise]
struct piecewise_construct_t { };
constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();
§ 20.3.5 502

 c ISO/IEC N3242=11-0012
1 The struct piecewise_construct_t is an empty structure type used as a unique type to disambiguate
constructor and function overloading. Specifically, pair has a constructor with piecewise_construct_t as
the first argument, immediately followed by two tuple (20.4) arguments used for piecewise construction of
the elements of the pair object.
20.4 Tuples [tuple]
20.4.1 In general [tuple.general]
1 This subclause describes the tuple library that provides a tuple type as the class template tuple that can
be instantiated with any number of arguments. Each template argument specifies the type of an element
in the tuple. Consequently, tuples are heterogeneous, fixed-size collections of values. An instantiation of
tuple with two arguments is similar to an instantiation of pair with the same two arguments. See 20.3.
2 Header <tuple> synopsis
namespace std {
// 20.4.2, class template tuple:
template <class... Types> class tuple;
// 20.4.2.4, tuple creation functions:
const unspecified ignore;
template <class... Types>
tuple<VTypes...> make_tuple(Types&&...);
template <class... Types>
tuple<Types...> forward_as_tuple(Types&&...) noexcept;
template<class... Types>
tuple<Types&...> tie(Types&...) noexcept;
template <class... TTypes, class... UTypes>
tuple<TTypes..., UTypes...> tuple_cat(const tuple<TTypes...>&, const tuple<UTypes...>&);
